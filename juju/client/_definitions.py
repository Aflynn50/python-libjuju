# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

from juju.client.facade import ReturnMapping, Type


class APIHostPortsResult(Type):
    _toSchema = {'servers': 'servers'}
    _toPy = {'servers': 'servers'}
    def __init__(self, servers=None, **unknown_fields):
        '''
        servers : typing.Sequence[~HostPort]
        '''
        if servers is not None and not isinstance(servers, list):
            raise Exception('Expected servers to be of type Sequence')

        self.servers = [HostPort.from_json(o) for o in servers or []]
        self.unknown_fields = unknown_fields



class Action(Type):
    _toSchema = {'name': 'name', 'parameters': 'parameters', 'receiver': 'receiver', 'tag': 'tag'}
    _toPy = {'name': 'name', 'parameters': 'parameters', 'receiver': 'receiver', 'tag': 'tag'}
    def __init__(self, name=None, parameters=None, receiver=None, tag=None, **unknown_fields):
        '''
        name : str
        parameters : typing.Mapping[str, typing.Any]
        receiver : str
        tag : str
        '''
        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if parameters is not None and not isinstance(parameters, dict):
            raise Exception('Expected parameters to be of type Mapping')

        if receiver is not None and not isinstance(receiver, (bytes, str)):
            raise Exception('Expected receiver to be of type str')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.name = name
        self.parameters = parameters
        self.receiver = receiver
        self.tag = tag
        self.unknown_fields = unknown_fields



class ActionExecutionResult(Type):
    _toSchema = {'action_tag': 'action-tag', 'message': 'message', 'results': 'results', 'status': 'status'}
    _toPy = {'action-tag': 'action_tag', 'message': 'message', 'results': 'results', 'status': 'status'}
    def __init__(self, action_tag=None, message=None, results=None, status=None, **unknown_fields):
        '''
        action_tag : str
        message : str
        results : typing.Mapping[str, typing.Any]
        status : str
        '''
        if action_tag is not None and not isinstance(action_tag, (bytes, str)):
            raise Exception('Expected action_tag to be of type str')

        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        if results is not None and not isinstance(results, dict):
            raise Exception('Expected results to be of type Mapping')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        self.action_tag = action_tag
        self.message = message
        self.results = results
        self.status = status
        self.unknown_fields = unknown_fields



class ActionExecutionResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ActionExecutionResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ActionExecutionResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ActionPruneArgs(Type):
    _toSchema = {'max_history_mb': 'max-history-mb', 'max_history_time': 'max-history-time'}
    _toPy = {'max-history-mb': 'max_history_mb', 'max-history-time': 'max_history_time'}
    def __init__(self, max_history_mb=None, max_history_time=None, **unknown_fields):
        '''
        max_history_mb : int
        max_history_time : int
        '''
        if max_history_mb is not None and not isinstance(max_history_mb, int):
            raise Exception('Expected max_history_mb to be of type int')

        if max_history_time is not None and not isinstance(max_history_time, int):
            raise Exception('Expected max_history_time to be of type int')

        self.max_history_mb = max_history_mb
        self.max_history_time = max_history_time
        self.unknown_fields = unknown_fields



class ActionResult(Type):
    _toSchema = {'action': 'action', 'completed': 'completed', 'enqueued': 'enqueued', 'error': 'error', 'message': 'message', 'output': 'output', 'started': 'started', 'status': 'status'}
    _toPy = {'action': 'action', 'completed': 'completed', 'enqueued': 'enqueued', 'error': 'error', 'message': 'message', 'output': 'output', 'started': 'started', 'status': 'status'}
    def __init__(self, action=None, completed=None, enqueued=None, error=None, message=None, output=None, started=None, status=None, **unknown_fields):
        '''
        action : Action
        completed : str
        enqueued : str
        error : Error
        message : str
        output : typing.Mapping[str, typing.Any]
        started : str
        status : str
        '''
        if action is not None and not isinstance(action, Action):
            raise Exception('Expected action to be of type Action')

        if completed is not None and not isinstance(completed, (bytes, str)):
            raise Exception('Expected completed to be of type str')

        if enqueued is not None and not isinstance(enqueued, (bytes, str)):
            raise Exception('Expected enqueued to be of type str')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        if output is not None and not isinstance(output, dict):
            raise Exception('Expected output to be of type Mapping')

        if started is not None and not isinstance(started, (bytes, str)):
            raise Exception('Expected started to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        self.action = Action.from_json(action) if action else None
        self.completed = completed
        self.enqueued = enqueued
        self.error = Error.from_json(error) if error else None
        self.message = message
        self.output = output
        self.started = started
        self.status = status
        self.unknown_fields = unknown_fields



class ActionResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ActionResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ActionResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ActionSpec(Type):
    _toSchema = {'description': 'description', 'params': 'params'}
    _toPy = {'description': 'description', 'params': 'params'}
    def __init__(self, description=None, params=None, **unknown_fields):
        '''
        description : str
        params : typing.Mapping[str, typing.Any]
        '''
        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if params is not None and not isinstance(params, dict):
            raise Exception('Expected params to be of type Mapping')

        self.description = description
        self.params = params
        self.unknown_fields = unknown_fields



class Actions(Type):
    _toSchema = {'actions': 'actions'}
    _toPy = {'actions': 'actions'}
    def __init__(self, actions=None, **unknown_fields):
        '''
        actions : typing.Sequence[~Action]
        '''
        if actions is not None and not isinstance(actions, list):
            raise Exception('Expected actions to be of type Sequence')

        self.actions = [Action.from_json(o) for o in actions or []]
        self.unknown_fields = unknown_fields



class ActionsByName(Type):
    _toSchema = {'actions': 'actions', 'error': 'error', 'name': 'name'}
    _toPy = {'actions': 'actions', 'error': 'error', 'name': 'name'}
    def __init__(self, actions=None, error=None, name=None, **unknown_fields):
        '''
        actions : typing.Sequence[~ActionResult]
        error : Error
        name : str
        '''
        if actions is not None and not isinstance(actions, list):
            raise Exception('Expected actions to be of type Sequence')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        self.actions = [ActionResult.from_json(o) for o in actions or []]
        self.error = Error.from_json(error) if error else None
        self.name = name
        self.unknown_fields = unknown_fields



class ActionsByNames(Type):
    _toSchema = {'actions': 'actions'}
    _toPy = {'actions': 'actions'}
    def __init__(self, actions=None, **unknown_fields):
        '''
        actions : typing.Sequence[~ActionsByName]
        '''
        if actions is not None and not isinstance(actions, list):
            raise Exception('Expected actions to be of type Sequence')

        self.actions = [ActionsByName.from_json(o) for o in actions or []]
        self.unknown_fields = unknown_fields



class ActionsByReceiver(Type):
    _toSchema = {'actions': 'actions', 'error': 'error', 'receiver': 'receiver'}
    _toPy = {'actions': 'actions', 'error': 'error', 'receiver': 'receiver'}
    def __init__(self, actions=None, error=None, receiver=None, **unknown_fields):
        '''
        actions : typing.Sequence[~ActionResult]
        error : Error
        receiver : str
        '''
        if actions is not None and not isinstance(actions, list):
            raise Exception('Expected actions to be of type Sequence')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if receiver is not None and not isinstance(receiver, (bytes, str)):
            raise Exception('Expected receiver to be of type str')

        self.actions = [ActionResult.from_json(o) for o in actions or []]
        self.error = Error.from_json(error) if error else None
        self.receiver = receiver
        self.unknown_fields = unknown_fields



class ActionsByReceivers(Type):
    _toSchema = {'actions': 'actions'}
    _toPy = {'actions': 'actions'}
    def __init__(self, actions=None, **unknown_fields):
        '''
        actions : typing.Sequence[~ActionsByReceiver]
        '''
        if actions is not None and not isinstance(actions, list):
            raise Exception('Expected actions to be of type Sequence')

        self.actions = [ActionsByReceiver.from_json(o) for o in actions or []]
        self.unknown_fields = unknown_fields



class AddApplicationOffer(Type):
    _toSchema = {'application_description': 'application-description', 'application_name': 'application-name', 'endpoints': 'endpoints', 'model_tag': 'model-tag', 'offer_name': 'offer-name'}
    _toPy = {'application-description': 'application_description', 'application-name': 'application_name', 'endpoints': 'endpoints', 'model-tag': 'model_tag', 'offer-name': 'offer_name'}
    def __init__(self, application_description=None, application_name=None, endpoints=None, model_tag=None, offer_name=None, **unknown_fields):
        '''
        application_description : str
        application_name : str
        endpoints : typing.Mapping[str, str]
        model_tag : str
        offer_name : str
        '''
        if application_description is not None and not isinstance(application_description, (bytes, str)):
            raise Exception('Expected application_description to be of type str')

        if application_name is not None and not isinstance(application_name, (bytes, str)):
            raise Exception('Expected application_name to be of type str')

        if endpoints is not None and not isinstance(endpoints, dict):
            raise Exception('Expected endpoints to be of type Mapping')

        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception('Expected model_tag to be of type str')

        if offer_name is not None and not isinstance(offer_name, (bytes, str)):
            raise Exception('Expected offer_name to be of type str')

        self.application_description = application_description
        self.application_name = application_name
        self.endpoints = endpoints
        self.model_tag = model_tag
        self.offer_name = offer_name
        self.unknown_fields = unknown_fields



class AddApplicationOffers(Type):
    _toSchema = {'offers': 'Offers'}
    _toPy = {'Offers': 'offers'}
    def __init__(self, offers=None, **unknown_fields):
        '''
        offers : typing.Sequence[~AddApplicationOffer]
        '''
        if offers is not None and not isinstance(offers, list):
            raise Exception('Expected offers to be of type Sequence')

        self.offers = [AddApplicationOffer.from_json(o) for o in offers or []]
        self.unknown_fields = unknown_fields



class AddApplicationUnits(Type):
    _toSchema = {'application': 'application', 'attach_storage': 'attach-storage', 'num_units': 'num-units', 'placement': 'placement', 'policy': 'policy'}
    _toPy = {'application': 'application', 'attach-storage': 'attach_storage', 'num-units': 'num_units', 'placement': 'placement', 'policy': 'policy'}
    def __init__(self, application=None, attach_storage=None, num_units=None, placement=None, policy=None, **unknown_fields):
        '''
        application : str
        attach_storage : typing.Sequence[str]
        num_units : int
        placement : typing.Sequence[~Placement]
        policy : str
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if attach_storage is not None and not isinstance(attach_storage, list):
            raise Exception('Expected attach_storage to be of type Sequence')

        if num_units is not None and not isinstance(num_units, int):
            raise Exception('Expected num_units to be of type int')

        if placement is not None and not isinstance(placement, list):
            raise Exception('Expected placement to be of type Sequence')

        if policy is not None and not isinstance(policy, (bytes, str)):
            raise Exception('Expected policy to be of type str')

        self.application = application
        self.attach_storage = attach_storage
        self.num_units = num_units
        self.placement = [Placement.from_json(o) for o in placement or []]
        self.policy = policy
        self.unknown_fields = unknown_fields



class AddApplicationUnitsResults(Type):
    _toSchema = {'units': 'units'}
    _toPy = {'units': 'units'}
    def __init__(self, units=None, **unknown_fields):
        '''
        units : typing.Sequence[str]
        '''
        if units is not None and not isinstance(units, list):
            raise Exception('Expected units to be of type Sequence')

        self.units = units
        self.unknown_fields = unknown_fields



class AddCharm(Type):
    _toSchema = {'channel': 'channel', 'force': 'force', 'url': 'url'}
    _toPy = {'channel': 'channel', 'force': 'force', 'url': 'url'}
    def __init__(self, channel=None, force=None, url=None, **unknown_fields):
        '''
        channel : str
        force : bool
        url : str
        '''
        if channel is not None and not isinstance(channel, (bytes, str)):
            raise Exception('Expected channel to be of type str')

        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if url is not None and not isinstance(url, (bytes, str)):
            raise Exception('Expected url to be of type str')

        self.channel = channel
        self.force = force
        self.url = url
        self.unknown_fields = unknown_fields



class AddCharmWithAuthorization(Type):
    _toSchema = {'channel': 'channel', 'force': 'force', 'macaroon': 'macaroon', 'url': 'url'}
    _toPy = {'channel': 'channel', 'force': 'force', 'macaroon': 'macaroon', 'url': 'url'}
    def __init__(self, channel=None, force=None, macaroon=None, url=None, **unknown_fields):
        '''
        channel : str
        force : bool
        macaroon : Macaroon
        url : str
        '''
        if channel is not None and not isinstance(channel, (bytes, str)):
            raise Exception('Expected channel to be of type str')

        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if macaroon is not None and not isinstance(macaroon, Macaroon):
            raise Exception('Expected macaroon to be of type Macaroon')

        if url is not None and not isinstance(url, (bytes, str)):
            raise Exception('Expected url to be of type str')

        self.channel = channel
        self.force = force
        self.macaroon = Macaroon.from_json(macaroon) if macaroon else None
        self.url = url
        self.unknown_fields = unknown_fields



class AddCloudArgs(Type):
    _toSchema = {'cloud': 'cloud', 'name': 'name'}
    _toPy = {'cloud': 'cloud', 'name': 'name'}
    def __init__(self, cloud=None, name=None, **unknown_fields):
        '''
        cloud : Cloud
        name : str
        '''
        if cloud is not None and not isinstance(cloud, Cloud):
            raise Exception('Expected cloud to be of type Cloud')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        self.cloud = Cloud.from_json(cloud) if cloud else None
        self.name = name
        self.unknown_fields = unknown_fields



class AddMachineParams(Type):
    _toSchema = {'addresses': 'addresses', 'constraints': 'constraints', 'container_type': 'container-type', 'disks': 'disks', 'hardware_characteristics': 'hardware-characteristics', 'instance_id': 'instance-id', 'jobs': 'jobs', 'nonce': 'nonce', 'parent_id': 'parent-id', 'placement': 'placement', 'series': 'series'}
    _toPy = {'addresses': 'addresses', 'constraints': 'constraints', 'container-type': 'container_type', 'disks': 'disks', 'hardware-characteristics': 'hardware_characteristics', 'instance-id': 'instance_id', 'jobs': 'jobs', 'nonce': 'nonce', 'parent-id': 'parent_id', 'placement': 'placement', 'series': 'series'}
    def __init__(self, addresses=None, constraints=None, container_type=None, disks=None, hardware_characteristics=None, instance_id=None, jobs=None, nonce=None, parent_id=None, placement=None, series=None, **unknown_fields):
        '''
        addresses : typing.Sequence[~Address]
        constraints : Value
        container_type : str
        disks : typing.Sequence[~Constraints]
        hardware_characteristics : HardwareCharacteristics
        instance_id : str
        jobs : typing.Sequence[str]
        nonce : str
        parent_id : str
        placement : Placement
        series : str
        '''
        if addresses is not None and not isinstance(addresses, list):
            raise Exception('Expected addresses to be of type Sequence')

        if constraints is not None and not isinstance(constraints, Value):
            raise Exception('Expected constraints to be of type Value')

        if container_type is not None and not isinstance(container_type, (bytes, str)):
            raise Exception('Expected container_type to be of type str')

        if disks is not None and not isinstance(disks, list):
            raise Exception('Expected disks to be of type Sequence')

        if hardware_characteristics is not None and not isinstance(hardware_characteristics, HardwareCharacteristics):
            raise Exception('Expected hardware_characteristics to be of type HardwareCharacteristics')

        if instance_id is not None and not isinstance(instance_id, (bytes, str)):
            raise Exception('Expected instance_id to be of type str')

        if jobs is not None and not isinstance(jobs, list):
            raise Exception('Expected jobs to be of type Sequence')

        if nonce is not None and not isinstance(nonce, (bytes, str)):
            raise Exception('Expected nonce to be of type str')

        if parent_id is not None and not isinstance(parent_id, (bytes, str)):
            raise Exception('Expected parent_id to be of type str')

        if placement is not None and not isinstance(placement, Placement):
            raise Exception('Expected placement to be of type Placement')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        self.addresses = [Address.from_json(o) for o in addresses or []]
        self.constraints = Value.from_json(constraints) if constraints else None
        self.container_type = container_type
        self.disks = [Constraints.from_json(o) for o in disks or []]
        self.hardware_characteristics = HardwareCharacteristics.from_json(hardware_characteristics) if hardware_characteristics else None
        self.instance_id = instance_id
        self.jobs = jobs
        self.nonce = nonce
        self.parent_id = parent_id
        self.placement = Placement.from_json(placement) if placement else None
        self.series = series
        self.unknown_fields = unknown_fields



class AddMachines(Type):
    _toSchema = {'params': 'params'}
    _toPy = {'params': 'params'}
    def __init__(self, params=None, **unknown_fields):
        '''
        params : typing.Sequence[~AddMachineParams]
        '''
        if params is not None and not isinstance(params, list):
            raise Exception('Expected params to be of type Sequence')

        self.params = [AddMachineParams.from_json(o) for o in params or []]
        self.unknown_fields = unknown_fields



class AddMachinesResult(Type):
    _toSchema = {'error': 'error', 'machine': 'machine'}
    _toPy = {'error': 'error', 'machine': 'machine'}
    def __init__(self, error=None, machine=None, **unknown_fields):
        '''
        error : Error
        machine : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if machine is not None and not isinstance(machine, (bytes, str)):
            raise Exception('Expected machine to be of type str')

        self.error = Error.from_json(error) if error else None
        self.machine = machine
        self.unknown_fields = unknown_fields



class AddMachinesResults(Type):
    _toSchema = {'machines': 'machines'}
    _toPy = {'machines': 'machines'}
    def __init__(self, machines=None, **unknown_fields):
        '''
        machines : typing.Sequence[~AddMachinesResult]
        '''
        if machines is not None and not isinstance(machines, list):
            raise Exception('Expected machines to be of type Sequence')

        self.machines = [AddMachinesResult.from_json(o) for o in machines or []]
        self.unknown_fields = unknown_fields



class AddPendingResourcesArgs(Type):
    _toSchema = {'addcharmwithauthorization': 'AddCharmWithAuthorization', 'channel': 'channel', 'entity': 'Entity', 'force': 'force', 'macaroon': 'macaroon', 'resources': 'resources', 'tag': 'tag', 'url': 'url'}
    _toPy = {'AddCharmWithAuthorization': 'addcharmwithauthorization', 'Entity': 'entity', 'channel': 'channel', 'force': 'force', 'macaroon': 'macaroon', 'resources': 'resources', 'tag': 'tag', 'url': 'url'}
    def __init__(self, addcharmwithauthorization=None, entity=None, channel=None, force=None, macaroon=None, resources=None, tag=None, url=None, **unknown_fields):
        '''
        addcharmwithauthorization : AddCharmWithAuthorization
        entity : Entity
        channel : str
        force : bool
        macaroon : Macaroon
        resources : typing.Sequence[~CharmResource]
        tag : str
        url : str
        '''
        if addcharmwithauthorization is not None and not isinstance(addcharmwithauthorization, AddCharmWithAuthorization):
            raise Exception('Expected addcharmwithauthorization to be of type AddCharmWithAuthorization')

        if entity is not None and not isinstance(entity, Entity):
            raise Exception('Expected entity to be of type Entity')

        if channel is not None and not isinstance(channel, (bytes, str)):
            raise Exception('Expected channel to be of type str')

        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if macaroon is not None and not isinstance(macaroon, Macaroon):
            raise Exception('Expected macaroon to be of type Macaroon')

        if resources is not None and not isinstance(resources, list):
            raise Exception('Expected resources to be of type Sequence')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        if url is not None and not isinstance(url, (bytes, str)):
            raise Exception('Expected url to be of type str')

        self.addcharmwithauthorization = AddCharmWithAuthorization.from_json(addcharmwithauthorization) if addcharmwithauthorization else None
        self.entity = Entity.from_json(entity) if entity else None
        self.channel = channel
        self.force = force
        self.macaroon = Macaroon.from_json(macaroon) if macaroon else None
        self.resources = [CharmResource.from_json(o) for o in resources or []]
        self.tag = tag
        self.url = url
        self.unknown_fields = unknown_fields



class AddPendingResourcesResult(Type):
    _toSchema = {'error': 'error', 'errorresult': 'ErrorResult', 'pending_ids': 'pending-ids'}
    _toPy = {'ErrorResult': 'errorresult', 'error': 'error', 'pending-ids': 'pending_ids'}
    def __init__(self, errorresult=None, error=None, pending_ids=None, **unknown_fields):
        '''
        errorresult : ErrorResult
        error : Error
        pending_ids : typing.Sequence[str]
        '''
        if errorresult is not None and not isinstance(errorresult, ErrorResult):
            raise Exception('Expected errorresult to be of type ErrorResult')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if pending_ids is not None and not isinstance(pending_ids, list):
            raise Exception('Expected pending_ids to be of type Sequence')

        self.errorresult = ErrorResult.from_json(errorresult) if errorresult else None
        self.error = Error.from_json(error) if error else None
        self.pending_ids = pending_ids
        self.unknown_fields = unknown_fields



class AddRelation(Type):
    _toSchema = {'endpoints': 'endpoints', 'via_cidrs': 'via-cidrs'}
    _toPy = {'endpoints': 'endpoints', 'via-cidrs': 'via_cidrs'}
    def __init__(self, endpoints=None, via_cidrs=None, **unknown_fields):
        '''
        endpoints : typing.Sequence[str]
        via_cidrs : typing.Sequence[str]
        '''
        if endpoints is not None and not isinstance(endpoints, list):
            raise Exception('Expected endpoints to be of type Sequence')

        if via_cidrs is not None and not isinstance(via_cidrs, list):
            raise Exception('Expected via_cidrs to be of type Sequence')

        self.endpoints = endpoints
        self.via_cidrs = via_cidrs
        self.unknown_fields = unknown_fields



class AddRelationResults(Type):
    _toSchema = {'endpoints': 'endpoints'}
    _toPy = {'endpoints': 'endpoints'}
    def __init__(self, endpoints=None, **unknown_fields):
        '''
        endpoints : typing.Mapping[str, ~CharmRelation]
        '''
        if endpoints is not None and not isinstance(endpoints, dict):
            raise Exception('Expected endpoints to be of type Mapping')

        self.endpoints = endpoints
        self.unknown_fields = unknown_fields



class AddStorageDetails(Type):
    _toSchema = {'storage_tags': 'storage-tags'}
    _toPy = {'storage-tags': 'storage_tags'}
    def __init__(self, storage_tags=None, **unknown_fields):
        '''
        storage_tags : typing.Sequence[str]
        '''
        if storage_tags is not None and not isinstance(storage_tags, list):
            raise Exception('Expected storage_tags to be of type Sequence')

        self.storage_tags = storage_tags
        self.unknown_fields = unknown_fields



class AddStorageResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : AddStorageDetails
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, AddStorageDetails):
            raise Exception('Expected result to be of type AddStorageDetails')

        self.error = Error.from_json(error) if error else None
        self.result = AddStorageDetails.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class AddStorageResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~AddStorageResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [AddStorageResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class AddSubnetParams(Type):
    _toSchema = {'provider_network_id': 'provider-network-id', 'space_tag': 'space-tag', 'subnet_provider_id': 'subnet-provider-id', 'subnet_tag': 'subnet-tag', 'vlan_tag': 'vlan-tag', 'zones': 'zones'}
    _toPy = {'provider-network-id': 'provider_network_id', 'space-tag': 'space_tag', 'subnet-provider-id': 'subnet_provider_id', 'subnet-tag': 'subnet_tag', 'vlan-tag': 'vlan_tag', 'zones': 'zones'}
    def __init__(self, provider_network_id=None, space_tag=None, subnet_provider_id=None, subnet_tag=None, vlan_tag=None, zones=None, **unknown_fields):
        '''
        provider_network_id : str
        space_tag : str
        subnet_provider_id : str
        subnet_tag : str
        vlan_tag : int
        zones : typing.Sequence[str]
        '''
        if provider_network_id is not None and not isinstance(provider_network_id, (bytes, str)):
            raise Exception('Expected provider_network_id to be of type str')

        if space_tag is not None and not isinstance(space_tag, (bytes, str)):
            raise Exception('Expected space_tag to be of type str')

        if subnet_provider_id is not None and not isinstance(subnet_provider_id, (bytes, str)):
            raise Exception('Expected subnet_provider_id to be of type str')

        if subnet_tag is not None and not isinstance(subnet_tag, (bytes, str)):
            raise Exception('Expected subnet_tag to be of type str')

        if vlan_tag is not None and not isinstance(vlan_tag, int):
            raise Exception('Expected vlan_tag to be of type int')

        if zones is not None and not isinstance(zones, list):
            raise Exception('Expected zones to be of type Sequence')

        self.provider_network_id = provider_network_id
        self.space_tag = space_tag
        self.subnet_provider_id = subnet_provider_id
        self.subnet_tag = subnet_tag
        self.vlan_tag = vlan_tag
        self.zones = zones
        self.unknown_fields = unknown_fields



class AddSubnetsParams(Type):
    _toSchema = {'subnets': 'subnets'}
    _toPy = {'subnets': 'subnets'}
    def __init__(self, subnets=None, **unknown_fields):
        '''
        subnets : typing.Sequence[~AddSubnetParams]
        '''
        if subnets is not None and not isinstance(subnets, list):
            raise Exception('Expected subnets to be of type Sequence')

        self.subnets = [AddSubnetParams.from_json(o) for o in subnets or []]
        self.unknown_fields = unknown_fields



class AddUser(Type):
    _toSchema = {'display_name': 'display-name', 'password': 'password', 'username': 'username'}
    _toPy = {'display-name': 'display_name', 'password': 'password', 'username': 'username'}
    def __init__(self, display_name=None, password=None, username=None, **unknown_fields):
        '''
        display_name : str
        password : str
        username : str
        '''
        if display_name is not None and not isinstance(display_name, (bytes, str)):
            raise Exception('Expected display_name to be of type str')

        if password is not None and not isinstance(password, (bytes, str)):
            raise Exception('Expected password to be of type str')

        if username is not None and not isinstance(username, (bytes, str)):
            raise Exception('Expected username to be of type str')

        self.display_name = display_name
        self.password = password
        self.username = username
        self.unknown_fields = unknown_fields



class AddUserResult(Type):
    _toSchema = {'error': 'error', 'secret_key': 'secret-key', 'tag': 'tag'}
    _toPy = {'error': 'error', 'secret-key': 'secret_key', 'tag': 'tag'}
    def __init__(self, error=None, secret_key=None, tag=None, **unknown_fields):
        '''
        error : Error
        secret_key : typing.Sequence[int]
        tag : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if secret_key is not None and not isinstance(secret_key, list):
            raise Exception('Expected secret_key to be of type Sequence')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.error = Error.from_json(error) if error else None
        self.secret_key = secret_key
        self.tag = tag
        self.unknown_fields = unknown_fields



class AddUserResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~AddUserResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [AddUserResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class AddUsers(Type):
    _toSchema = {'users': 'users'}
    _toPy = {'users': 'users'}
    def __init__(self, users=None, **unknown_fields):
        '''
        users : typing.Sequence[~AddUser]
        '''
        if users is not None and not isinstance(users, list):
            raise Exception('Expected users to be of type Sequence')

        self.users = [AddUser.from_json(o) for o in users or []]
        self.unknown_fields = unknown_fields



class Address(Type):
    _toSchema = {'scope': 'scope', 'space_id': 'space-id', 'space_name': 'space-name', 'type_': 'type', 'value': 'value'}
    _toPy = {'scope': 'scope', 'space-id': 'space_id', 'space-name': 'space_name', 'type': 'type_', 'value': 'value'}
    def __init__(self, scope=None, space_id=None, space_name=None, type_=None, value=None, **unknown_fields):
        '''
        scope : str
        space_id : str
        space_name : str
        type_ : str
        value : str
        '''
        if scope is not None and not isinstance(scope, (bytes, str)):
            raise Exception('Expected scope to be of type str')

        if space_id is not None and not isinstance(space_id, (bytes, str)):
            raise Exception('Expected space_id to be of type str')

        if space_name is not None and not isinstance(space_name, (bytes, str)):
            raise Exception('Expected space_name to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        if value is not None and not isinstance(value, (bytes, str)):
            raise Exception('Expected value to be of type str')

        self.scope = scope
        self.space_id = space_id
        self.space_name = space_name
        self.type_ = type_
        self.value = value
        self.unknown_fields = unknown_fields



class AdoptResourcesArgs(Type):
    _toSchema = {'model_tag': 'model-tag', 'source_controller_version': 'source-controller-version'}
    _toPy = {'model-tag': 'model_tag', 'source-controller-version': 'source_controller_version'}
    def __init__(self, model_tag=None, source_controller_version=None, **unknown_fields):
        '''
        model_tag : str
        source_controller_version : Number
        '''
        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception('Expected model_tag to be of type str')

        if source_controller_version is not None and not isinstance(source_controller_version, Number):
            raise Exception('Expected source_controller_version to be of type Number')

        self.model_tag = model_tag
        self.source_controller_version = Number.from_json(source_controller_version) if source_controller_version else None
        self.unknown_fields = unknown_fields



class AgentGetEntitiesResult(Type):
    _toSchema = {'container_type': 'container-type', 'error': 'error', 'jobs': 'jobs', 'life': 'life'}
    _toPy = {'container-type': 'container_type', 'error': 'error', 'jobs': 'jobs', 'life': 'life'}
    def __init__(self, container_type=None, error=None, jobs=None, life=None, **unknown_fields):
        '''
        container_type : str
        error : Error
        jobs : typing.Sequence[str]
        life : str
        '''
        if container_type is not None and not isinstance(container_type, (bytes, str)):
            raise Exception('Expected container_type to be of type str')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if jobs is not None and not isinstance(jobs, list):
            raise Exception('Expected jobs to be of type Sequence')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        self.container_type = container_type
        self.error = Error.from_json(error) if error else None
        self.jobs = jobs
        self.life = life
        self.unknown_fields = unknown_fields



class AgentGetEntitiesResults(Type):
    _toSchema = {'entities': 'entities'}
    _toPy = {'entities': 'entities'}
    def __init__(self, entities=None, **unknown_fields):
        '''
        entities : typing.Sequence[~AgentGetEntitiesResult]
        '''
        if entities is not None and not isinstance(entities, list):
            raise Exception('Expected entities to be of type Sequence')

        self.entities = [AgentGetEntitiesResult.from_json(o) for o in entities or []]
        self.unknown_fields = unknown_fields



class AgentVersionResult(Type):
    _toSchema = {'version': 'version'}
    _toPy = {'version': 'version'}
    def __init__(self, version=None, **unknown_fields):
        '''
        version : Number
        '''
        if version is not None and not isinstance(version, Number):
            raise Exception('Expected version to be of type Number')

        self.version = Number.from_json(version) if version else None
        self.unknown_fields = unknown_fields



class AllWatcherId(Type):
    _toSchema = {'watcher_id': 'watcher-id'}
    _toPy = {'watcher-id': 'watcher_id'}
    def __init__(self, watcher_id=None, **unknown_fields):
        '''
        watcher_id : str
        '''
        if watcher_id is not None and not isinstance(watcher_id, (bytes, str)):
            raise Exception('Expected watcher_id to be of type str')

        self.watcher_id = watcher_id
        self.unknown_fields = unknown_fields



class AllWatcherNextResults(Type):
    _toSchema = {'deltas': 'deltas'}
    _toPy = {'deltas': 'deltas'}
    def __init__(self, deltas=None, **unknown_fields):
        '''
        deltas : typing.Sequence[~Delta]
        '''
        if deltas is not None and not isinstance(deltas, list):
            raise Exception('Expected deltas to be of type Sequence')

        self.deltas = [Delta.from_json(o) for o in deltas or []]
        self.unknown_fields = unknown_fields



class AnnotationsGetResult(Type):
    _toSchema = {'annotations': 'annotations', 'entity': 'entity', 'error': 'error'}
    _toPy = {'annotations': 'annotations', 'entity': 'entity', 'error': 'error'}
    def __init__(self, annotations=None, entity=None, error=None, **unknown_fields):
        '''
        annotations : typing.Mapping[str, str]
        entity : str
        error : ErrorResult
        '''
        if annotations is not None and not isinstance(annotations, dict):
            raise Exception('Expected annotations to be of type Mapping')

        if entity is not None and not isinstance(entity, (bytes, str)):
            raise Exception('Expected entity to be of type str')

        if error is not None and not isinstance(error, ErrorResult):
            raise Exception('Expected error to be of type ErrorResult')

        self.annotations = annotations
        self.entity = entity
        self.error = ErrorResult.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class AnnotationsGetResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~AnnotationsGetResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [AnnotationsGetResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class AnnotationsSet(Type):
    _toSchema = {'annotations': 'annotations'}
    _toPy = {'annotations': 'annotations'}
    def __init__(self, annotations=None, **unknown_fields):
        '''
        annotations : typing.Sequence[~EntityAnnotations]
        '''
        if annotations is not None and not isinstance(annotations, list):
            raise Exception('Expected annotations to be of type Sequence')

        self.annotations = [EntityAnnotations.from_json(o) for o in annotations or []]
        self.unknown_fields = unknown_fields



class ApplicationCharm(Type):
    _toSchema = {'charm_modified_version': 'charm-modified-version', 'force_upgrade': 'force-upgrade', 'sha256': 'sha256', 'url': 'url'}
    _toPy = {'charm-modified-version': 'charm_modified_version', 'force-upgrade': 'force_upgrade', 'sha256': 'sha256', 'url': 'url'}
    def __init__(self, charm_modified_version=None, force_upgrade=None, sha256=None, url=None, **unknown_fields):
        '''
        charm_modified_version : int
        force_upgrade : bool
        sha256 : str
        url : str
        '''
        if charm_modified_version is not None and not isinstance(charm_modified_version, int):
            raise Exception('Expected charm_modified_version to be of type int')

        if force_upgrade is not None and not isinstance(force_upgrade, bool):
            raise Exception('Expected force_upgrade to be of type bool')

        if sha256 is not None and not isinstance(sha256, (bytes, str)):
            raise Exception('Expected sha256 to be of type str')

        if url is not None and not isinstance(url, (bytes, str)):
            raise Exception('Expected url to be of type str')

        self.charm_modified_version = charm_modified_version
        self.force_upgrade = force_upgrade
        self.sha256 = sha256
        self.url = url
        self.unknown_fields = unknown_fields



class ApplicationCharmActionsResult(Type):
    _toSchema = {'actions': 'actions', 'application_tag': 'application-tag', 'error': 'error'}
    _toPy = {'actions': 'actions', 'application-tag': 'application_tag', 'error': 'error'}
    def __init__(self, actions=None, application_tag=None, error=None, **unknown_fields):
        '''
        actions : typing.Mapping[str, ~ActionSpec]
        application_tag : str
        error : Error
        '''
        if actions is not None and not isinstance(actions, dict):
            raise Exception('Expected actions to be of type Mapping')

        if application_tag is not None and not isinstance(application_tag, (bytes, str)):
            raise Exception('Expected application_tag to be of type str')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.actions = actions
        self.application_tag = application_tag
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class ApplicationCharmRelations(Type):
    _toSchema = {'application': 'application'}
    _toPy = {'application': 'application'}
    def __init__(self, application=None, **unknown_fields):
        '''
        application : str
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        self.application = application
        self.unknown_fields = unknown_fields



class ApplicationCharmRelationsResults(Type):
    _toSchema = {'charm_relations': 'charm-relations'}
    _toPy = {'charm-relations': 'charm_relations'}
    def __init__(self, charm_relations=None, **unknown_fields):
        '''
        charm_relations : typing.Sequence[str]
        '''
        if charm_relations is not None and not isinstance(charm_relations, list):
            raise Exception('Expected charm_relations to be of type Sequence')

        self.charm_relations = charm_relations
        self.unknown_fields = unknown_fields



class ApplicationCharmResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : ApplicationCharm
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, ApplicationCharm):
            raise Exception('Expected result to be of type ApplicationCharm')

        self.error = Error.from_json(error) if error else None
        self.result = ApplicationCharm.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class ApplicationCharmResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ApplicationCharmResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ApplicationCharmResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ApplicationConfigSet(Type):
    _toSchema = {'application': 'application', 'config': 'config', 'generation': 'generation'}
    _toPy = {'application': 'application', 'config': 'config', 'generation': 'generation'}
    def __init__(self, application=None, config=None, generation=None, **unknown_fields):
        '''
        application : str
        config : typing.Mapping[str, str]
        generation : str
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        if generation is not None and not isinstance(generation, (bytes, str)):
            raise Exception('Expected generation to be of type str')

        self.application = application
        self.config = config
        self.generation = generation
        self.unknown_fields = unknown_fields



class ApplicationConfigSetArgs(Type):
    _toSchema = {'args': 'Args'}
    _toPy = {'Args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~ApplicationConfigSet]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [ApplicationConfigSet.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class ApplicationConfigUnsetArgs(Type):
    _toSchema = {'args': 'Args'}
    _toPy = {'Args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~ApplicationUnset]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [ApplicationUnset.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class ApplicationConstraint(Type):
    _toSchema = {'constraints': 'constraints', 'error': 'error'}
    _toPy = {'constraints': 'constraints', 'error': 'error'}
    def __init__(self, constraints=None, error=None, **unknown_fields):
        '''
        constraints : Value
        error : Error
        '''
        if constraints is not None and not isinstance(constraints, Value):
            raise Exception('Expected constraints to be of type Value')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.constraints = Value.from_json(constraints) if constraints else None
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class ApplicationDeploy(Type):
    _toSchema = {'application': 'application', 'channel': 'channel', 'charm_url': 'charm-url', 'config': 'config', 'config_yaml': 'config-yaml', 'constraints': 'constraints', 'endpoint_bindings': 'endpoint-bindings', 'num_units': 'num-units', 'placement': 'placement', 'resources': 'resources', 'series': 'series', 'storage': 'storage'}
    _toPy = {'application': 'application', 'channel': 'channel', 'charm-url': 'charm_url', 'config': 'config', 'config-yaml': 'config_yaml', 'constraints': 'constraints', 'endpoint-bindings': 'endpoint_bindings', 'num-units': 'num_units', 'placement': 'placement', 'resources': 'resources', 'series': 'series', 'storage': 'storage'}
    def __init__(self, application=None, channel=None, charm_url=None, config=None, config_yaml=None, constraints=None, endpoint_bindings=None, num_units=None, placement=None, resources=None, series=None, storage=None, **unknown_fields):
        '''
        application : str
        channel : str
        charm_url : str
        config : typing.Mapping[str, str]
        config_yaml : str
        constraints : Value
        endpoint_bindings : typing.Mapping[str, str]
        num_units : int
        placement : typing.Sequence[~Placement]
        resources : typing.Mapping[str, str]
        series : str
        storage : typing.Mapping[str, ~Constraints]
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if channel is not None and not isinstance(channel, (bytes, str)):
            raise Exception('Expected channel to be of type str')

        if charm_url is not None and not isinstance(charm_url, (bytes, str)):
            raise Exception('Expected charm_url to be of type str')

        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        if config_yaml is not None and not isinstance(config_yaml, (bytes, str)):
            raise Exception('Expected config_yaml to be of type str')

        if constraints is not None and not isinstance(constraints, Value):
            raise Exception('Expected constraints to be of type Value')

        if endpoint_bindings is not None and not isinstance(endpoint_bindings, dict):
            raise Exception('Expected endpoint_bindings to be of type Mapping')

        if num_units is not None and not isinstance(num_units, int):
            raise Exception('Expected num_units to be of type int')

        if placement is not None and not isinstance(placement, list):
            raise Exception('Expected placement to be of type Sequence')

        if resources is not None and not isinstance(resources, dict):
            raise Exception('Expected resources to be of type Mapping')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        if storage is not None and not isinstance(storage, dict):
            raise Exception('Expected storage to be of type Mapping')

        self.application = application
        self.channel = channel
        self.charm_url = charm_url
        self.config = config
        self.config_yaml = config_yaml
        self.constraints = Value.from_json(constraints) if constraints else None
        self.endpoint_bindings = endpoint_bindings
        self.num_units = num_units
        self.placement = [Placement.from_json(o) for o in placement or []]
        self.resources = resources
        self.series = series
        self.storage = storage
        self.unknown_fields = unknown_fields



class ApplicationDestroy(Type):
    _toSchema = {'application': 'application'}
    _toPy = {'application': 'application'}
    def __init__(self, application=None, **unknown_fields):
        '''
        application : str
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        self.application = application
        self.unknown_fields = unknown_fields



class ApplicationExpose(Type):
    _toSchema = {'application': 'application'}
    _toPy = {'application': 'application'}
    def __init__(self, application=None, **unknown_fields):
        '''
        application : str
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        self.application = application
        self.unknown_fields = unknown_fields



class ApplicationGet(Type):
    _toSchema = {'application': 'application', 'branch': 'branch'}
    _toPy = {'application': 'application', 'branch': 'branch'}
    def __init__(self, application=None, branch=None, **unknown_fields):
        '''
        application : str
        branch : str
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if branch is not None and not isinstance(branch, (bytes, str)):
            raise Exception('Expected branch to be of type str')

        self.application = application
        self.branch = branch
        self.unknown_fields = unknown_fields



class ApplicationGetArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~ApplicationGet]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [ApplicationGet.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class ApplicationGetConfigResults(Type):
    _toSchema = {'results': 'Results'}
    _toPy = {'Results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ConfigResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ConfigResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ApplicationGetConstraintsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ApplicationConstraint]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ApplicationConstraint.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ApplicationGetResults(Type):
    _toSchema = {'application': 'application', 'application_config': 'application-config', 'channel': 'channel', 'charm': 'charm', 'config': 'config', 'constraints': 'constraints', 'series': 'series'}
    _toPy = {'application': 'application', 'application-config': 'application_config', 'channel': 'channel', 'charm': 'charm', 'config': 'config', 'constraints': 'constraints', 'series': 'series'}
    def __init__(self, application=None, application_config=None, channel=None, charm=None, config=None, constraints=None, series=None, **unknown_fields):
        '''
        application : str
        application_config : typing.Mapping[str, typing.Any]
        channel : str
        charm : str
        config : typing.Mapping[str, typing.Any]
        constraints : Value
        series : str
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if application_config is not None and not isinstance(application_config, dict):
            raise Exception('Expected application_config to be of type Mapping')

        if channel is not None and not isinstance(channel, (bytes, str)):
            raise Exception('Expected channel to be of type str')

        if charm is not None and not isinstance(charm, (bytes, str)):
            raise Exception('Expected charm to be of type str')

        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        if constraints is not None and not isinstance(constraints, Value):
            raise Exception('Expected constraints to be of type Value')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        self.application = application
        self.application_config = application_config
        self.channel = channel
        self.charm = charm
        self.config = config
        self.constraints = Value.from_json(constraints) if constraints else None
        self.series = series
        self.unknown_fields = unknown_fields



class ApplicationInfo(Type):
    _toSchema = {'channel': 'channel', 'charm': 'charm', 'constraints': 'constraints', 'endpoint_bindings': 'endpoint-bindings', 'exposed': 'exposed', 'principal': 'principal', 'remote': 'remote', 'series': 'series', 'tag': 'tag'}
    _toPy = {'channel': 'channel', 'charm': 'charm', 'constraints': 'constraints', 'endpoint-bindings': 'endpoint_bindings', 'exposed': 'exposed', 'principal': 'principal', 'remote': 'remote', 'series': 'series', 'tag': 'tag'}
    def __init__(self, channel=None, charm=None, constraints=None, endpoint_bindings=None, exposed=None, principal=None, remote=None, series=None, tag=None, **unknown_fields):
        '''
        channel : str
        charm : str
        constraints : Value
        endpoint_bindings : typing.Mapping[str, str]
        exposed : bool
        principal : bool
        remote : bool
        series : str
        tag : str
        '''
        if channel is not None and not isinstance(channel, (bytes, str)):
            raise Exception('Expected channel to be of type str')

        if charm is not None and not isinstance(charm, (bytes, str)):
            raise Exception('Expected charm to be of type str')

        if constraints is not None and not isinstance(constraints, Value):
            raise Exception('Expected constraints to be of type Value')

        if endpoint_bindings is not None and not isinstance(endpoint_bindings, dict):
            raise Exception('Expected endpoint_bindings to be of type Mapping')

        if exposed is not None and not isinstance(exposed, bool):
            raise Exception('Expected exposed to be of type bool')

        if principal is not None and not isinstance(principal, bool):
            raise Exception('Expected principal to be of type bool')

        if remote is not None and not isinstance(remote, bool):
            raise Exception('Expected remote to be of type bool')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.channel = channel
        self.charm = charm
        self.constraints = Value.from_json(constraints) if constraints else None
        self.endpoint_bindings = endpoint_bindings
        self.exposed = exposed
        self.principal = principal
        self.remote = remote
        self.series = series
        self.tag = tag
        self.unknown_fields = unknown_fields



class ApplicationInfoResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : ApplicationInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, ApplicationInfo):
            raise Exception('Expected result to be of type ApplicationInfo')

        self.error = Error.from_json(error) if error else None
        self.result = ApplicationInfo.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class ApplicationInfoResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ApplicationInfoResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ApplicationInfoResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ApplicationMetricCredential(Type):
    _toSchema = {'application': 'application', 'metrics_credentials': 'metrics-credentials'}
    _toPy = {'application': 'application', 'metrics-credentials': 'metrics_credentials'}
    def __init__(self, application=None, metrics_credentials=None, **unknown_fields):
        '''
        application : str
        metrics_credentials : typing.Sequence[int]
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if metrics_credentials is not None and not isinstance(metrics_credentials, list):
            raise Exception('Expected metrics_credentials to be of type Sequence')

        self.application = application
        self.metrics_credentials = metrics_credentials
        self.unknown_fields = unknown_fields



class ApplicationMetricCredentials(Type):
    _toSchema = {'creds': 'creds'}
    _toPy = {'creds': 'creds'}
    def __init__(self, creds=None, **unknown_fields):
        '''
        creds : typing.Sequence[~ApplicationMetricCredential]
        '''
        if creds is not None and not isinstance(creds, list):
            raise Exception('Expected creds to be of type Sequence')

        self.creds = [ApplicationMetricCredential.from_json(o) for o in creds or []]
        self.unknown_fields = unknown_fields



class ApplicationOffer(Type):
    _toSchema = {'access': 'access', 'application_description': 'application-description', 'bindings': 'bindings', 'endpoints': 'endpoints', 'offer_name': 'offer-name', 'offer_url': 'offer-url', 'source_model_tag': 'source-model-tag', 'spaces': 'spaces'}
    _toPy = {'access': 'access', 'application-description': 'application_description', 'bindings': 'bindings', 'endpoints': 'endpoints', 'offer-name': 'offer_name', 'offer-url': 'offer_url', 'source-model-tag': 'source_model_tag', 'spaces': 'spaces'}
    def __init__(self, access=None, application_description=None, bindings=None, endpoints=None, offer_name=None, offer_url=None, source_model_tag=None, spaces=None, **unknown_fields):
        '''
        access : str
        application_description : str
        bindings : typing.Mapping[str, str]
        endpoints : typing.Sequence[~RemoteEndpoint]
        offer_name : str
        offer_url : str
        source_model_tag : str
        spaces : typing.Sequence[~RemoteSpace]
        '''
        if access is not None and not isinstance(access, (bytes, str)):
            raise Exception('Expected access to be of type str')

        if application_description is not None and not isinstance(application_description, (bytes, str)):
            raise Exception('Expected application_description to be of type str')

        if bindings is not None and not isinstance(bindings, dict):
            raise Exception('Expected bindings to be of type Mapping')

        if endpoints is not None and not isinstance(endpoints, list):
            raise Exception('Expected endpoints to be of type Sequence')

        if offer_name is not None and not isinstance(offer_name, (bytes, str)):
            raise Exception('Expected offer_name to be of type str')

        if offer_url is not None and not isinstance(offer_url, (bytes, str)):
            raise Exception('Expected offer_url to be of type str')

        if source_model_tag is not None and not isinstance(source_model_tag, (bytes, str)):
            raise Exception('Expected source_model_tag to be of type str')

        if spaces is not None and not isinstance(spaces, list):
            raise Exception('Expected spaces to be of type Sequence')

        self.access = access
        self.application_description = application_description
        self.bindings = bindings
        self.endpoints = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        self.offer_name = offer_name
        self.offer_url = offer_url
        self.source_model_tag = source_model_tag
        self.spaces = [RemoteSpace.from_json(o) for o in spaces or []]
        self.unknown_fields = unknown_fields



class ApplicationOfferAdminDetails(Type):
    _toSchema = {'application_description': 'application-description', 'application_name': 'application-name', 'applicationofferdetails': 'ApplicationOfferDetails', 'bindings': 'bindings', 'charm_url': 'charm-url', 'connections': 'connections', 'endpoints': 'endpoints', 'offer_name': 'offer-name', 'offer_url': 'offer-url', 'offer_uuid': 'offer-uuid', 'source_model_tag': 'source-model-tag', 'spaces': 'spaces', 'users': 'users'}
    _toPy = {'ApplicationOfferDetails': 'applicationofferdetails', 'application-description': 'application_description', 'application-name': 'application_name', 'bindings': 'bindings', 'charm-url': 'charm_url', 'connections': 'connections', 'endpoints': 'endpoints', 'offer-name': 'offer_name', 'offer-url': 'offer_url', 'offer-uuid': 'offer_uuid', 'source-model-tag': 'source_model_tag', 'spaces': 'spaces', 'users': 'users'}
    def __init__(self, applicationofferdetails=None, application_description=None, application_name=None, bindings=None, charm_url=None, connections=None, endpoints=None, offer_name=None, offer_url=None, offer_uuid=None, source_model_tag=None, spaces=None, users=None, **unknown_fields):
        '''
        applicationofferdetails : ApplicationOfferDetails
        application_description : str
        application_name : str
        bindings : typing.Mapping[str, str]
        charm_url : str
        connections : typing.Sequence[~OfferConnection]
        endpoints : typing.Sequence[~RemoteEndpoint]
        offer_name : str
        offer_url : str
        offer_uuid : str
        source_model_tag : str
        spaces : typing.Sequence[~RemoteSpace]
        users : typing.Sequence[~OfferUserDetails]
        '''
        if applicationofferdetails is not None and not isinstance(applicationofferdetails, ApplicationOfferDetails):
            raise Exception('Expected applicationofferdetails to be of type ApplicationOfferDetails')

        if application_description is not None and not isinstance(application_description, (bytes, str)):
            raise Exception('Expected application_description to be of type str')

        if application_name is not None and not isinstance(application_name, (bytes, str)):
            raise Exception('Expected application_name to be of type str')

        if bindings is not None and not isinstance(bindings, dict):
            raise Exception('Expected bindings to be of type Mapping')

        if charm_url is not None and not isinstance(charm_url, (bytes, str)):
            raise Exception('Expected charm_url to be of type str')

        if connections is not None and not isinstance(connections, list):
            raise Exception('Expected connections to be of type Sequence')

        if endpoints is not None and not isinstance(endpoints, list):
            raise Exception('Expected endpoints to be of type Sequence')

        if offer_name is not None and not isinstance(offer_name, (bytes, str)):
            raise Exception('Expected offer_name to be of type str')

        if offer_url is not None and not isinstance(offer_url, (bytes, str)):
            raise Exception('Expected offer_url to be of type str')

        if offer_uuid is not None and not isinstance(offer_uuid, (bytes, str)):
            raise Exception('Expected offer_uuid to be of type str')

        if source_model_tag is not None and not isinstance(source_model_tag, (bytes, str)):
            raise Exception('Expected source_model_tag to be of type str')

        if spaces is not None and not isinstance(spaces, list):
            raise Exception('Expected spaces to be of type Sequence')

        if users is not None and not isinstance(users, list):
            raise Exception('Expected users to be of type Sequence')

        self.applicationofferdetails = ApplicationOfferDetails.from_json(applicationofferdetails) if applicationofferdetails else None
        self.application_description = application_description
        self.application_name = application_name
        self.bindings = bindings
        self.charm_url = charm_url
        self.connections = [OfferConnection.from_json(o) for o in connections or []]
        self.endpoints = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        self.offer_name = offer_name
        self.offer_url = offer_url
        self.offer_uuid = offer_uuid
        self.source_model_tag = source_model_tag
        self.spaces = [RemoteSpace.from_json(o) for o in spaces or []]
        self.users = [OfferUserDetails.from_json(o) for o in users or []]
        self.unknown_fields = unknown_fields



class ApplicationOfferDetails(Type):
    _toSchema = {'application_description': 'application-description', 'bindings': 'bindings', 'endpoints': 'endpoints', 'offer_name': 'offer-name', 'offer_url': 'offer-url', 'offer_uuid': 'offer-uuid', 'source_model_tag': 'source-model-tag', 'spaces': 'spaces', 'users': 'users'}
    _toPy = {'application-description': 'application_description', 'bindings': 'bindings', 'endpoints': 'endpoints', 'offer-name': 'offer_name', 'offer-url': 'offer_url', 'offer-uuid': 'offer_uuid', 'source-model-tag': 'source_model_tag', 'spaces': 'spaces', 'users': 'users'}
    def __init__(self, application_description=None, bindings=None, endpoints=None, offer_name=None, offer_url=None, offer_uuid=None, source_model_tag=None, spaces=None, users=None, **unknown_fields):
        '''
        application_description : str
        bindings : typing.Mapping[str, str]
        endpoints : typing.Sequence[~RemoteEndpoint]
        offer_name : str
        offer_url : str
        offer_uuid : str
        source_model_tag : str
        spaces : typing.Sequence[~RemoteSpace]
        users : typing.Sequence[~OfferUserDetails]
        '''
        if application_description is not None and not isinstance(application_description, (bytes, str)):
            raise Exception('Expected application_description to be of type str')

        if bindings is not None and not isinstance(bindings, dict):
            raise Exception('Expected bindings to be of type Mapping')

        if endpoints is not None and not isinstance(endpoints, list):
            raise Exception('Expected endpoints to be of type Sequence')

        if offer_name is not None and not isinstance(offer_name, (bytes, str)):
            raise Exception('Expected offer_name to be of type str')

        if offer_url is not None and not isinstance(offer_url, (bytes, str)):
            raise Exception('Expected offer_url to be of type str')

        if offer_uuid is not None and not isinstance(offer_uuid, (bytes, str)):
            raise Exception('Expected offer_uuid to be of type str')

        if source_model_tag is not None and not isinstance(source_model_tag, (bytes, str)):
            raise Exception('Expected source_model_tag to be of type str')

        if spaces is not None and not isinstance(spaces, list):
            raise Exception('Expected spaces to be of type Sequence')

        if users is not None and not isinstance(users, list):
            raise Exception('Expected users to be of type Sequence')

        self.application_description = application_description
        self.bindings = bindings
        self.endpoints = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        self.offer_name = offer_name
        self.offer_url = offer_url
        self.offer_uuid = offer_uuid
        self.source_model_tag = source_model_tag
        self.spaces = [RemoteSpace.from_json(o) for o in spaces or []]
        self.users = [OfferUserDetails.from_json(o) for o in users or []]
        self.unknown_fields = unknown_fields



class ApplicationOfferResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : ApplicationOfferAdminDetails
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, ApplicationOfferAdminDetails):
            raise Exception('Expected result to be of type ApplicationOfferAdminDetails')

        self.error = Error.from_json(error) if error else None
        self.result = ApplicationOfferAdminDetails.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class ApplicationOfferStatus(Type):
    _toSchema = {'active_connected_count': 'active-connected-count', 'application_name': 'application-name', 'charm': 'charm', 'endpoints': 'endpoints', 'err': 'err', 'offer_name': 'offer-name', 'total_connected_count': 'total-connected-count'}
    _toPy = {'active-connected-count': 'active_connected_count', 'application-name': 'application_name', 'charm': 'charm', 'endpoints': 'endpoints', 'err': 'err', 'offer-name': 'offer_name', 'total-connected-count': 'total_connected_count'}
    def __init__(self, active_connected_count=None, application_name=None, charm=None, endpoints=None, err=None, offer_name=None, total_connected_count=None, **unknown_fields):
        '''
        active_connected_count : int
        application_name : str
        charm : str
        endpoints : typing.Mapping[str, ~RemoteEndpoint]
        err : Error
        offer_name : str
        total_connected_count : int
        '''
        if active_connected_count is not None and not isinstance(active_connected_count, int):
            raise Exception('Expected active_connected_count to be of type int')

        if application_name is not None and not isinstance(application_name, (bytes, str)):
            raise Exception('Expected application_name to be of type str')

        if charm is not None and not isinstance(charm, (bytes, str)):
            raise Exception('Expected charm to be of type str')

        if endpoints is not None and not isinstance(endpoints, dict):
            raise Exception('Expected endpoints to be of type Mapping')

        if err is not None and not isinstance(err, Error):
            raise Exception('Expected err to be of type Error')

        if offer_name is not None and not isinstance(offer_name, (bytes, str)):
            raise Exception('Expected offer_name to be of type str')

        if total_connected_count is not None and not isinstance(total_connected_count, int):
            raise Exception('Expected total_connected_count to be of type int')

        self.active_connected_count = active_connected_count
        self.application_name = application_name
        self.charm = charm
        self.endpoints = endpoints
        self.err = Error.from_json(err) if err else None
        self.offer_name = offer_name
        self.total_connected_count = total_connected_count
        self.unknown_fields = unknown_fields



class ApplicationOffersResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ApplicationOfferResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ApplicationOfferResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ApplicationRelationsChange(Type):
    _toSchema = {'changed': 'changed', 'removed': 'removed'}
    _toPy = {'changed': 'changed', 'removed': 'removed'}
    def __init__(self, changed=None, removed=None, **unknown_fields):
        '''
        changed : typing.Sequence[~RelationChange]
        removed : typing.Sequence[int]
        '''
        if changed is not None and not isinstance(changed, list):
            raise Exception('Expected changed to be of type Sequence')

        if removed is not None and not isinstance(removed, list):
            raise Exception('Expected removed to be of type Sequence')

        self.changed = [RelationChange.from_json(o) for o in changed or []]
        self.removed = removed
        self.unknown_fields = unknown_fields



class ApplicationRelationsWatchResult(Type):
    _toSchema = {'applicationrelationswatcherid': 'ApplicationRelationsWatcherId', 'changes': 'changes', 'error': 'error'}
    _toPy = {'ApplicationRelationsWatcherId': 'applicationrelationswatcherid', 'changes': 'changes', 'error': 'error'}
    def __init__(self, applicationrelationswatcherid=None, changes=None, error=None, **unknown_fields):
        '''
        applicationrelationswatcherid : str
        changes : ApplicationRelationsChange
        error : Error
        '''
        if applicationrelationswatcherid is not None and not isinstance(applicationrelationswatcherid, (bytes, str)):
            raise Exception('Expected applicationrelationswatcherid to be of type str')

        if changes is not None and not isinstance(changes, ApplicationRelationsChange):
            raise Exception('Expected changes to be of type ApplicationRelationsChange')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.applicationrelationswatcherid = applicationrelationswatcherid
        self.changes = ApplicationRelationsChange.from_json(changes) if changes else None
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class ApplicationSet(Type):
    _toSchema = {'application': 'application', 'branch': 'branch', 'options': 'options'}
    _toPy = {'application': 'application', 'branch': 'branch', 'options': 'options'}
    def __init__(self, application=None, branch=None, options=None, **unknown_fields):
        '''
        application : str
        branch : str
        options : typing.Mapping[str, str]
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if branch is not None and not isinstance(branch, (bytes, str)):
            raise Exception('Expected branch to be of type str')

        if options is not None and not isinstance(options, dict):
            raise Exception('Expected options to be of type Mapping')

        self.application = application
        self.branch = branch
        self.options = options
        self.unknown_fields = unknown_fields



class ApplicationSetCharm(Type):
    _toSchema = {'application': 'application', 'channel': 'channel', 'charm_url': 'charm-url', 'config_settings': 'config-settings', 'config_settings_yaml': 'config-settings-yaml', 'force': 'force', 'force_series': 'force-series', 'force_units': 'force-units', 'generation': 'generation', 'resource_ids': 'resource-ids', 'storage_constraints': 'storage-constraints'}
    _toPy = {'application': 'application', 'channel': 'channel', 'charm-url': 'charm_url', 'config-settings': 'config_settings', 'config-settings-yaml': 'config_settings_yaml', 'force': 'force', 'force-series': 'force_series', 'force-units': 'force_units', 'generation': 'generation', 'resource-ids': 'resource_ids', 'storage-constraints': 'storage_constraints'}
    def __init__(self, application=None, channel=None, charm_url=None, config_settings=None, config_settings_yaml=None, force=None, force_series=None, force_units=None, generation=None, resource_ids=None, storage_constraints=None, **unknown_fields):
        '''
        application : str
        channel : str
        charm_url : str
        config_settings : typing.Mapping[str, str]
        config_settings_yaml : str
        force : bool
        force_series : bool
        force_units : bool
        generation : str
        resource_ids : typing.Mapping[str, str]
        storage_constraints : typing.Mapping[str, ~StorageConstraints]
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if channel is not None and not isinstance(channel, (bytes, str)):
            raise Exception('Expected channel to be of type str')

        if charm_url is not None and not isinstance(charm_url, (bytes, str)):
            raise Exception('Expected charm_url to be of type str')

        if config_settings is not None and not isinstance(config_settings, dict):
            raise Exception('Expected config_settings to be of type Mapping')

        if config_settings_yaml is not None and not isinstance(config_settings_yaml, (bytes, str)):
            raise Exception('Expected config_settings_yaml to be of type str')

        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if force_series is not None and not isinstance(force_series, bool):
            raise Exception('Expected force_series to be of type bool')

        if force_units is not None and not isinstance(force_units, bool):
            raise Exception('Expected force_units to be of type bool')

        if generation is not None and not isinstance(generation, (bytes, str)):
            raise Exception('Expected generation to be of type str')

        if resource_ids is not None and not isinstance(resource_ids, dict):
            raise Exception('Expected resource_ids to be of type Mapping')

        if storage_constraints is not None and not isinstance(storage_constraints, dict):
            raise Exception('Expected storage_constraints to be of type Mapping')

        self.application = application
        self.channel = channel
        self.charm_url = charm_url
        self.config_settings = config_settings
        self.config_settings_yaml = config_settings_yaml
        self.force = force
        self.force_series = force_series
        self.force_units = force_units
        self.generation = generation
        self.resource_ids = resource_ids
        self.storage_constraints = storage_constraints
        self.unknown_fields = unknown_fields



class ApplicationSetCharmProfile(Type):
    _toSchema = {'application': 'application', 'charm_url': 'charm-url'}
    _toPy = {'application': 'application', 'charm-url': 'charm_url'}
    def __init__(self, application=None, charm_url=None, **unknown_fields):
        '''
        application : str
        charm_url : str
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if charm_url is not None and not isinstance(charm_url, (bytes, str)):
            raise Exception('Expected charm_url to be of type str')

        self.application = application
        self.charm_url = charm_url
        self.unknown_fields = unknown_fields



class ApplicationStatus(Type):
    _toSchema = {'can_upgrade_to': 'can-upgrade-to', 'charm': 'charm', 'charm_profile': 'charm-profile', 'charm_verion': 'charm-verion', 'endpoint_bindings': 'endpoint-bindings', 'err': 'err', 'exposed': 'exposed', 'int_': 'int', 'life': 'life', 'meter_statuses': 'meter-statuses', 'provider_id': 'provider-id', 'public_address': 'public-address', 'relations': 'relations', 'series': 'series', 'status': 'status', 'subordinate_to': 'subordinate-to', 'units': 'units', 'workload_version': 'workload-version'}
    _toPy = {'can-upgrade-to': 'can_upgrade_to', 'charm': 'charm', 'charm-profile': 'charm_profile', 'charm-verion': 'charm_verion', 'endpoint-bindings': 'endpoint_bindings', 'err': 'err', 'exposed': 'exposed', 'int': 'int_', 'life': 'life', 'meter-statuses': 'meter_statuses', 'provider-id': 'provider_id', 'public-address': 'public_address', 'relations': 'relations', 'series': 'series', 'status': 'status', 'subordinate-to': 'subordinate_to', 'units': 'units', 'workload-version': 'workload_version'}
    def __init__(self, can_upgrade_to=None, charm=None, charm_profile=None, charm_verion=None, endpoint_bindings=None, err=None, exposed=None, int_=None, life=None, meter_statuses=None, provider_id=None, public_address=None, relations=None, series=None, status=None, subordinate_to=None, units=None, workload_version=None, **unknown_fields):
        '''
        can_upgrade_to : str
        charm : str
        charm_profile : str
        charm_verion : str
        endpoint_bindings : typing.Mapping[str, str]
        err : Error
        exposed : bool
        int_ : int
        life : str
        meter_statuses : typing.Mapping[str, ~MeterStatus]
        provider_id : str
        public_address : str
        relations : typing.Sequence[str]
        series : str
        status : DetailedStatus
        subordinate_to : typing.Sequence[str]
        units : typing.Mapping[str, ~UnitStatus]
        workload_version : str
        '''
        if can_upgrade_to is not None and not isinstance(can_upgrade_to, (bytes, str)):
            raise Exception('Expected can_upgrade_to to be of type str')

        if charm is not None and not isinstance(charm, (bytes, str)):
            raise Exception('Expected charm to be of type str')

        if charm_profile is not None and not isinstance(charm_profile, (bytes, str)):
            raise Exception('Expected charm_profile to be of type str')

        if charm_verion is not None and not isinstance(charm_verion, (bytes, str)):
            raise Exception('Expected charm_verion to be of type str')

        if endpoint_bindings is not None and not isinstance(endpoint_bindings, dict):
            raise Exception('Expected endpoint_bindings to be of type Mapping')

        if err is not None and not isinstance(err, Error):
            raise Exception('Expected err to be of type Error')

        if exposed is not None and not isinstance(exposed, bool):
            raise Exception('Expected exposed to be of type bool')

        if int_ is not None and not isinstance(int_, int):
            raise Exception('Expected int_ to be of type int')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if meter_statuses is not None and not isinstance(meter_statuses, dict):
            raise Exception('Expected meter_statuses to be of type Mapping')

        if provider_id is not None and not isinstance(provider_id, (bytes, str)):
            raise Exception('Expected provider_id to be of type str')

        if public_address is not None and not isinstance(public_address, (bytes, str)):
            raise Exception('Expected public_address to be of type str')

        if relations is not None and not isinstance(relations, list):
            raise Exception('Expected relations to be of type Sequence')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        if status is not None and not isinstance(status, DetailedStatus):
            raise Exception('Expected status to be of type DetailedStatus')

        if subordinate_to is not None and not isinstance(subordinate_to, list):
            raise Exception('Expected subordinate_to to be of type Sequence')

        if units is not None and not isinstance(units, dict):
            raise Exception('Expected units to be of type Mapping')

        if workload_version is not None and not isinstance(workload_version, (bytes, str)):
            raise Exception('Expected workload_version to be of type str')

        self.can_upgrade_to = can_upgrade_to
        self.charm = charm
        self.charm_profile = charm_profile
        self.charm_verion = charm_verion
        self.endpoint_bindings = endpoint_bindings
        self.err = Error.from_json(err) if err else None
        self.exposed = exposed
        self.int_ = int_
        self.life = life
        self.meter_statuses = meter_statuses
        self.provider_id = provider_id
        self.public_address = public_address
        self.relations = relations
        self.series = series
        self.status = DetailedStatus.from_json(status) if status else None
        self.subordinate_to = subordinate_to
        self.units = units
        self.workload_version = workload_version
        self.unknown_fields = unknown_fields



class ApplicationStatusResult(Type):
    _toSchema = {'application': 'application', 'error': 'error', 'units': 'units'}
    _toPy = {'application': 'application', 'error': 'error', 'units': 'units'}
    def __init__(self, application=None, error=None, units=None, **unknown_fields):
        '''
        application : StatusResult
        error : Error
        units : typing.Mapping[str, ~StatusResult]
        '''
        if application is not None and not isinstance(application, StatusResult):
            raise Exception('Expected application to be of type StatusResult')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if units is not None and not isinstance(units, dict):
            raise Exception('Expected units to be of type Mapping')

        self.application = StatusResult.from_json(application) if application else None
        self.error = Error.from_json(error) if error else None
        self.units = units
        self.unknown_fields = unknown_fields



class ApplicationStatusResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ApplicationStatusResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ApplicationStatusResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ApplicationTag(Type):
    _toSchema = {'name': 'Name'}
    _toPy = {'Name': 'name'}
    def __init__(self, name=None, **unknown_fields):
        '''
        name : str
        '''
        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        self.name = name
        self.unknown_fields = unknown_fields



class ApplicationURLs(Type):
    _toSchema = {'application_urls': 'application-urls'}
    _toPy = {'application-urls': 'application_urls'}
    def __init__(self, application_urls=None, **unknown_fields):
        '''
        application_urls : typing.Sequence[str]
        '''
        if application_urls is not None and not isinstance(application_urls, list):
            raise Exception('Expected application_urls to be of type Sequence')

        self.application_urls = application_urls
        self.unknown_fields = unknown_fields



class ApplicationUnexpose(Type):
    _toSchema = {'application': 'application'}
    _toPy = {'application': 'application'}
    def __init__(self, application=None, **unknown_fields):
        '''
        application : str
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        self.application = application
        self.unknown_fields = unknown_fields



class ApplicationUnitParams(Type):
    _toSchema = {'address': 'address', 'data': 'data', 'filesystem_info': 'filesystem-info', 'info': 'info', 'ports': 'ports', 'provider_id': 'provider-id', 'stateful': 'stateful', 'status': 'status', 'unit_tag': 'unit-tag'}
    _toPy = {'address': 'address', 'data': 'data', 'filesystem-info': 'filesystem_info', 'info': 'info', 'ports': 'ports', 'provider-id': 'provider_id', 'stateful': 'stateful', 'status': 'status', 'unit-tag': 'unit_tag'}
    def __init__(self, address=None, data=None, filesystem_info=None, info=None, ports=None, provider_id=None, stateful=None, status=None, unit_tag=None, **unknown_fields):
        '''
        address : str
        data : typing.Mapping[str, typing.Any]
        filesystem_info : typing.Sequence[~KubernetesFilesystemInfo]
        info : str
        ports : typing.Sequence[str]
        provider_id : str
        stateful : bool
        status : str
        unit_tag : str
        '''
        if address is not None and not isinstance(address, (bytes, str)):
            raise Exception('Expected address to be of type str')

        if data is not None and not isinstance(data, dict):
            raise Exception('Expected data to be of type Mapping')

        if filesystem_info is not None and not isinstance(filesystem_info, list):
            raise Exception('Expected filesystem_info to be of type Sequence')

        if info is not None and not isinstance(info, (bytes, str)):
            raise Exception('Expected info to be of type str')

        if ports is not None and not isinstance(ports, list):
            raise Exception('Expected ports to be of type Sequence')

        if provider_id is not None and not isinstance(provider_id, (bytes, str)):
            raise Exception('Expected provider_id to be of type str')

        if stateful is not None and not isinstance(stateful, bool):
            raise Exception('Expected stateful to be of type bool')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        if unit_tag is not None and not isinstance(unit_tag, (bytes, str)):
            raise Exception('Expected unit_tag to be of type str')

        self.address = address
        self.data = data
        self.filesystem_info = [KubernetesFilesystemInfo.from_json(o) for o in filesystem_info or []]
        self.info = info
        self.ports = ports
        self.provider_id = provider_id
        self.stateful = stateful
        self.status = status
        self.unit_tag = unit_tag
        self.unknown_fields = unknown_fields



class ApplicationUnset(Type):
    _toSchema = {'application': 'application', 'branch': 'branch', 'options': 'options'}
    _toPy = {'application': 'application', 'branch': 'branch', 'options': 'options'}
    def __init__(self, application=None, branch=None, options=None, **unknown_fields):
        '''
        application : str
        branch : str
        options : typing.Sequence[str]
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if branch is not None and not isinstance(branch, (bytes, str)):
            raise Exception('Expected branch to be of type str')

        if options is not None and not isinstance(options, list):
            raise Exception('Expected options to be of type Sequence')

        self.application = application
        self.branch = branch
        self.options = options
        self.unknown_fields = unknown_fields



class ApplicationUpdate(Type):
    _toSchema = {'application': 'application', 'charm_url': 'charm-url', 'constraints': 'constraints', 'force': 'force', 'force_charm_url': 'force-charm-url', 'force_series': 'force-series', 'generation': 'generation', 'min_units': 'min-units', 'settings': 'settings', 'settings_yaml': 'settings-yaml'}
    _toPy = {'application': 'application', 'charm-url': 'charm_url', 'constraints': 'constraints', 'force': 'force', 'force-charm-url': 'force_charm_url', 'force-series': 'force_series', 'generation': 'generation', 'min-units': 'min_units', 'settings': 'settings', 'settings-yaml': 'settings_yaml'}
    def __init__(self, application=None, charm_url=None, constraints=None, force=None, force_charm_url=None, force_series=None, generation=None, min_units=None, settings=None, settings_yaml=None, **unknown_fields):
        '''
        application : str
        charm_url : str
        constraints : Value
        force : bool
        force_charm_url : bool
        force_series : bool
        generation : str
        min_units : int
        settings : typing.Mapping[str, str]
        settings_yaml : str
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if charm_url is not None and not isinstance(charm_url, (bytes, str)):
            raise Exception('Expected charm_url to be of type str')

        if constraints is not None and not isinstance(constraints, Value):
            raise Exception('Expected constraints to be of type Value')

        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if force_charm_url is not None and not isinstance(force_charm_url, bool):
            raise Exception('Expected force_charm_url to be of type bool')

        if force_series is not None and not isinstance(force_series, bool):
            raise Exception('Expected force_series to be of type bool')

        if generation is not None and not isinstance(generation, (bytes, str)):
            raise Exception('Expected generation to be of type str')

        if min_units is not None and not isinstance(min_units, int):
            raise Exception('Expected min_units to be of type int')

        if settings is not None and not isinstance(settings, dict):
            raise Exception('Expected settings to be of type Mapping')

        if settings_yaml is not None and not isinstance(settings_yaml, (bytes, str)):
            raise Exception('Expected settings_yaml to be of type str')

        self.application = application
        self.charm_url = charm_url
        self.constraints = Value.from_json(constraints) if constraints else None
        self.force = force
        self.force_charm_url = force_charm_url
        self.force_series = force_series
        self.generation = generation
        self.min_units = min_units
        self.settings = settings
        self.settings_yaml = settings_yaml
        self.unknown_fields = unknown_fields



class ApplicationsCharmActionsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ApplicationCharmActionsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ApplicationCharmActionsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ApplicationsDeploy(Type):
    _toSchema = {'applications': 'applications'}
    _toPy = {'applications': 'applications'}
    def __init__(self, applications=None, **unknown_fields):
        '''
        applications : typing.Sequence[~ApplicationDeploy]
        '''
        if applications is not None and not isinstance(applications, list):
            raise Exception('Expected applications to be of type Sequence')

        self.applications = [ApplicationDeploy.from_json(o) for o in applications or []]
        self.unknown_fields = unknown_fields



class BackupsCreateArgs(Type):
    _toSchema = {'keep_copy': 'keep-copy', 'no_download': 'no-download', 'notes': 'notes'}
    _toPy = {'keep-copy': 'keep_copy', 'no-download': 'no_download', 'notes': 'notes'}
    def __init__(self, keep_copy=None, no_download=None, notes=None, **unknown_fields):
        '''
        keep_copy : bool
        no_download : bool
        notes : str
        '''
        if keep_copy is not None and not isinstance(keep_copy, bool):
            raise Exception('Expected keep_copy to be of type bool')

        if no_download is not None and not isinstance(no_download, bool):
            raise Exception('Expected no_download to be of type bool')

        if notes is not None and not isinstance(notes, (bytes, str)):
            raise Exception('Expected notes to be of type str')

        self.keep_copy = keep_copy
        self.no_download = no_download
        self.notes = notes
        self.unknown_fields = unknown_fields



class BackupsInfoArgs(Type):
    _toSchema = {'id_': 'id'}
    _toPy = {'id': 'id_'}
    def __init__(self, id_=None, **unknown_fields):
        '''
        id_ : str
        '''
        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        self.id_ = id_
        self.unknown_fields = unknown_fields



class BackupsListArgs(Type):
    _toSchema = {}
    _toPy = {}
    def __init__(self, **unknown_fields):
        '''

        '''
        self.unknown_fields = unknown_fields



class BackupsListResult(Type):
    _toSchema = {'list_': 'list'}
    _toPy = {'list': 'list_'}
    def __init__(self, list_=None, **unknown_fields):
        '''
        list_ : typing.Sequence[~BackupsMetadataResult]
        '''
        if list_ is not None and not isinstance(list_, list):
            raise Exception('Expected list_ to be of type Sequence')

        self.list_ = [BackupsMetadataResult.from_json(o) for o in list_ or []]
        self.unknown_fields = unknown_fields



class BackupsMetadataResult(Type):
    _toSchema = {'ca_cert': 'ca-cert', 'ca_private_key': 'ca-private-key', 'checksum': 'checksum', 'checksum_format': 'checksum-format', 'filename': 'filename', 'finished': 'finished', 'hostname': 'hostname', 'id_': 'id', 'machine': 'machine', 'model': 'model', 'notes': 'notes', 'series': 'series', 'size': 'size', 'started': 'started', 'stored': 'stored', 'version': 'version'}
    _toPy = {'ca-cert': 'ca_cert', 'ca-private-key': 'ca_private_key', 'checksum': 'checksum', 'checksum-format': 'checksum_format', 'filename': 'filename', 'finished': 'finished', 'hostname': 'hostname', 'id': 'id_', 'machine': 'machine', 'model': 'model', 'notes': 'notes', 'series': 'series', 'size': 'size', 'started': 'started', 'stored': 'stored', 'version': 'version'}
    def __init__(self, ca_cert=None, ca_private_key=None, checksum=None, checksum_format=None, filename=None, finished=None, hostname=None, id_=None, machine=None, model=None, notes=None, series=None, size=None, started=None, stored=None, version=None, **unknown_fields):
        '''
        ca_cert : str
        ca_private_key : str
        checksum : str
        checksum_format : str
        filename : str
        finished : str
        hostname : str
        id_ : str
        machine : str
        model : str
        notes : str
        series : str
        size : int
        started : str
        stored : str
        version : Number
        '''
        if ca_cert is not None and not isinstance(ca_cert, (bytes, str)):
            raise Exception('Expected ca_cert to be of type str')

        if ca_private_key is not None and not isinstance(ca_private_key, (bytes, str)):
            raise Exception('Expected ca_private_key to be of type str')

        if checksum is not None and not isinstance(checksum, (bytes, str)):
            raise Exception('Expected checksum to be of type str')

        if checksum_format is not None and not isinstance(checksum_format, (bytes, str)):
            raise Exception('Expected checksum_format to be of type str')

        if filename is not None and not isinstance(filename, (bytes, str)):
            raise Exception('Expected filename to be of type str')

        if finished is not None and not isinstance(finished, (bytes, str)):
            raise Exception('Expected finished to be of type str')

        if hostname is not None and not isinstance(hostname, (bytes, str)):
            raise Exception('Expected hostname to be of type str')

        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        if machine is not None and not isinstance(machine, (bytes, str)):
            raise Exception('Expected machine to be of type str')

        if model is not None and not isinstance(model, (bytes, str)):
            raise Exception('Expected model to be of type str')

        if notes is not None and not isinstance(notes, (bytes, str)):
            raise Exception('Expected notes to be of type str')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if started is not None and not isinstance(started, (bytes, str)):
            raise Exception('Expected started to be of type str')

        if stored is not None and not isinstance(stored, (bytes, str)):
            raise Exception('Expected stored to be of type str')

        if version is not None and not isinstance(version, Number):
            raise Exception('Expected version to be of type Number')

        self.ca_cert = ca_cert
        self.ca_private_key = ca_private_key
        self.checksum = checksum
        self.checksum_format = checksum_format
        self.filename = filename
        self.finished = finished
        self.hostname = hostname
        self.id_ = id_
        self.machine = machine
        self.model = model
        self.notes = notes
        self.series = series
        self.size = size
        self.started = started
        self.stored = stored
        self.version = Number.from_json(version) if version else None
        self.unknown_fields = unknown_fields



class BackupsRemoveArgs(Type):
    _toSchema = {'ids': 'ids'}
    _toPy = {'ids': 'ids'}
    def __init__(self, ids=None, **unknown_fields):
        '''
        ids : typing.Sequence[str]
        '''
        if ids is not None and not isinstance(ids, list):
            raise Exception('Expected ids to be of type Sequence')

        self.ids = ids
        self.unknown_fields = unknown_fields



class Binary(Type):
    _toSchema = {'arch': 'Arch', 'build': 'Build', 'major': 'Major', 'minor': 'Minor', 'number': 'Number', 'patch': 'Patch', 'series': 'Series', 'tag': 'Tag'}
    _toPy = {'Arch': 'arch', 'Build': 'build', 'Major': 'major', 'Minor': 'minor', 'Number': 'number', 'Patch': 'patch', 'Series': 'series', 'Tag': 'tag'}
    def __init__(self, arch=None, build=None, major=None, minor=None, number=None, patch=None, series=None, tag=None, **unknown_fields):
        '''
        arch : str
        build : int
        major : int
        minor : int
        number : Number
        patch : int
        series : str
        tag : str
        '''
        if arch is not None and not isinstance(arch, (bytes, str)):
            raise Exception('Expected arch to be of type str')

        if build is not None and not isinstance(build, int):
            raise Exception('Expected build to be of type int')

        if major is not None and not isinstance(major, int):
            raise Exception('Expected major to be of type int')

        if minor is not None and not isinstance(minor, int):
            raise Exception('Expected minor to be of type int')

        if number is not None and not isinstance(number, Number):
            raise Exception('Expected number to be of type Number')

        if patch is not None and not isinstance(patch, int):
            raise Exception('Expected patch to be of type int')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.arch = arch
        self.build = build
        self.major = major
        self.minor = minor
        self.number = Number.from_json(number) if number else None
        self.patch = patch
        self.series = series
        self.tag = tag
        self.unknown_fields = unknown_fields



class Block(Type):
    _toSchema = {'id_': 'id', 'message': 'message', 'tag': 'tag', 'type_': 'type'}
    _toPy = {'id': 'id_', 'message': 'message', 'tag': 'tag', 'type': 'type_'}
    def __init__(self, id_=None, message=None, tag=None, type_=None, **unknown_fields):
        '''
        id_ : str
        message : str
        tag : str
        type_ : str
        '''
        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.id_ = id_
        self.message = message
        self.tag = tag
        self.type_ = type_
        self.unknown_fields = unknown_fields



class BlockDevice(Type):
    _toSchema = {'busaddress': 'BusAddress', 'devicelinks': 'DeviceLinks', 'devicename': 'DeviceName', 'filesystemtype': 'FilesystemType', 'hardwareid': 'HardwareId', 'inuse': 'InUse', 'label': 'Label', 'mountpoint': 'MountPoint', 'size': 'Size', 'uuid': 'UUID', 'wwn': 'WWN'}
    _toPy = {'BusAddress': 'busaddress', 'DeviceLinks': 'devicelinks', 'DeviceName': 'devicename', 'FilesystemType': 'filesystemtype', 'HardwareId': 'hardwareid', 'InUse': 'inuse', 'Label': 'label', 'MountPoint': 'mountpoint', 'Size': 'size', 'UUID': 'uuid', 'WWN': 'wwn'}
    def __init__(self, busaddress=None, devicelinks=None, devicename=None, filesystemtype=None, hardwareid=None, inuse=None, label=None, mountpoint=None, size=None, uuid=None, wwn=None, **unknown_fields):
        '''
        busaddress : str
        devicelinks : typing.Sequence[str]
        devicename : str
        filesystemtype : str
        hardwareid : str
        inuse : bool
        label : str
        mountpoint : str
        size : int
        uuid : str
        wwn : str
        '''
        if busaddress is not None and not isinstance(busaddress, (bytes, str)):
            raise Exception('Expected busaddress to be of type str')

        if devicelinks is not None and not isinstance(devicelinks, list):
            raise Exception('Expected devicelinks to be of type Sequence')

        if devicename is not None and not isinstance(devicename, (bytes, str)):
            raise Exception('Expected devicename to be of type str')

        if filesystemtype is not None and not isinstance(filesystemtype, (bytes, str)):
            raise Exception('Expected filesystemtype to be of type str')

        if hardwareid is not None and not isinstance(hardwareid, (bytes, str)):
            raise Exception('Expected hardwareid to be of type str')

        if inuse is not None and not isinstance(inuse, bool):
            raise Exception('Expected inuse to be of type bool')

        if label is not None and not isinstance(label, (bytes, str)):
            raise Exception('Expected label to be of type str')

        if mountpoint is not None and not isinstance(mountpoint, (bytes, str)):
            raise Exception('Expected mountpoint to be of type str')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if uuid is not None and not isinstance(uuid, (bytes, str)):
            raise Exception('Expected uuid to be of type str')

        if wwn is not None and not isinstance(wwn, (bytes, str)):
            raise Exception('Expected wwn to be of type str')

        self.busaddress = busaddress
        self.devicelinks = devicelinks
        self.devicename = devicename
        self.filesystemtype = filesystemtype
        self.hardwareid = hardwareid
        self.inuse = inuse
        self.label = label
        self.mountpoint = mountpoint
        self.size = size
        self.uuid = uuid
        self.wwn = wwn
        self.unknown_fields = unknown_fields



class BlockDeviceResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : BlockDevice
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, BlockDevice):
            raise Exception('Expected result to be of type BlockDevice')

        self.error = Error.from_json(error) if error else None
        self.result = BlockDevice.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class BlockDeviceResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~BlockDeviceResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [BlockDeviceResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class BlockResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : Block
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, Block):
            raise Exception('Expected result to be of type Block')

        self.error = Error.from_json(error) if error else None
        self.result = Block.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class BlockResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~BlockResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [BlockResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class BlockSwitchParams(Type):
    _toSchema = {'message': 'message', 'type_': 'type'}
    _toPy = {'message': 'message', 'type': 'type_'}
    def __init__(self, message=None, type_=None, **unknown_fields):
        '''
        message : str
        type_ : str
        '''
        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.message = message
        self.type_ = type_
        self.unknown_fields = unknown_fields



class BoolResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : bool
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, bool):
            raise Exception('Expected result to be of type bool')

        self.error = Error.from_json(error) if error else None
        self.result = result
        self.unknown_fields = unknown_fields



class BoolResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~BoolResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [BoolResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class BranchArg(Type):
    _toSchema = {'branch': 'branch'}
    _toPy = {'branch': 'branch'}
    def __init__(self, branch=None, **unknown_fields):
        '''
        branch : str
        '''
        if branch is not None and not isinstance(branch, (bytes, str)):
            raise Exception('Expected branch to be of type str')

        self.branch = branch
        self.unknown_fields = unknown_fields



class BranchInfoArgs(Type):
    _toSchema = {'branches': 'branches', 'detailed': 'detailed'}
    _toPy = {'branches': 'branches', 'detailed': 'detailed'}
    def __init__(self, branches=None, detailed=None, **unknown_fields):
        '''
        branches : typing.Sequence[str]
        detailed : bool
        '''
        if branches is not None and not isinstance(branches, list):
            raise Exception('Expected branches to be of type Sequence')

        if detailed is not None and not isinstance(detailed, bool):
            raise Exception('Expected detailed to be of type bool')

        self.branches = branches
        self.detailed = detailed
        self.unknown_fields = unknown_fields



class BranchStatus(Type):
    _toSchema = {'assigned_units': 'assigned-units', 'created': 'created'}
    _toPy = {'assigned-units': 'assigned_units', 'created': 'created'}
    def __init__(self, assigned_units=None, created=None, **unknown_fields):
        '''
        assigned_units : typing.Sequence[str]
        created : int
        '''
        if assigned_units is not None and not isinstance(assigned_units, list):
            raise Exception('Expected assigned_units to be of type Sequence')

        if created is not None and not isinstance(created, int):
            raise Exception('Expected created to be of type int')

        self.assigned_units = assigned_units
        self.created = created
        self.unknown_fields = unknown_fields



class BranchTrackArg(Type):
    _toSchema = {'branch': 'branch', 'entities': 'entities'}
    _toPy = {'branch': 'branch', 'entities': 'entities'}
    def __init__(self, branch=None, entities=None, **unknown_fields):
        '''
        branch : str
        entities : typing.Sequence[~Entity]
        '''
        if branch is not None and not isinstance(branch, (bytes, str)):
            raise Exception('Expected branch to be of type str')

        if entities is not None and not isinstance(entities, list):
            raise Exception('Expected entities to be of type Sequence')

        self.branch = branch
        self.entities = [Entity.from_json(o) for o in entities or []]
        self.unknown_fields = unknown_fields



class BulkImportStorageParams(Type):
    _toSchema = {'storage': 'storage'}
    _toPy = {'storage': 'storage'}
    def __init__(self, storage=None, **unknown_fields):
        '''
        storage : typing.Sequence[~ImportStorageParams]
        '''
        if storage is not None and not isinstance(storage, list):
            raise Exception('Expected storage to be of type Sequence')

        self.storage = [ImportStorageParams.from_json(o) for o in storage or []]
        self.unknown_fields = unknown_fields



class BundleChange(Type):
    _toSchema = {'args': 'args', 'id_': 'id', 'method': 'method', 'requires': 'requires'}
    _toPy = {'args': 'args', 'id': 'id_', 'method': 'method', 'requires': 'requires'}
    def __init__(self, args=None, id_=None, method=None, requires=None, **unknown_fields):
        '''
        args : typing.Sequence[typing.Any]
        id_ : str
        method : str
        requires : typing.Sequence[str]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        if method is not None and not isinstance(method, (bytes, str)):
            raise Exception('Expected method to be of type str')

        if requires is not None and not isinstance(requires, list):
            raise Exception('Expected requires to be of type Sequence')

        self.args = args
        self.id_ = id_
        self.method = method
        self.requires = requires
        self.unknown_fields = unknown_fields



class BundleChangesParams(Type):
    _toSchema = {'bundleurl': 'bundleURL', 'yaml': 'yaml'}
    _toPy = {'bundleURL': 'bundleurl', 'yaml': 'yaml'}
    def __init__(self, bundleurl=None, yaml=None, **unknown_fields):
        '''
        bundleurl : str
        yaml : str
        '''
        if bundleurl is not None and not isinstance(bundleurl, (bytes, str)):
            raise Exception('Expected bundleurl to be of type str')

        if yaml is not None and not isinstance(yaml, (bytes, str)):
            raise Exception('Expected yaml to be of type str')

        self.bundleurl = bundleurl
        self.yaml = yaml
        self.unknown_fields = unknown_fields



class BundleChangesResults(Type):
    _toSchema = {'changes': 'changes', 'errors': 'errors'}
    _toPy = {'changes': 'changes', 'errors': 'errors'}
    def __init__(self, changes=None, errors=None, **unknown_fields):
        '''
        changes : typing.Sequence[~BundleChange]
        errors : typing.Sequence[str]
        '''
        if changes is not None and not isinstance(changes, list):
            raise Exception('Expected changes to be of type Sequence')

        if errors is not None and not isinstance(errors, list):
            raise Exception('Expected errors to be of type Sequence')

        self.changes = [BundleChange.from_json(o) for o in changes or []]
        self.errors = errors
        self.unknown_fields = unknown_fields



class BytesResult(Type):
    _toSchema = {'result': 'result'}
    _toPy = {'result': 'result'}
    def __init__(self, result=None, **unknown_fields):
        '''
        result : typing.Sequence[int]
        '''
        if result is not None and not isinstance(result, list):
            raise Exception('Expected result to be of type Sequence')

        self.result = result
        self.unknown_fields = unknown_fields



class ChangeModelCredentialParams(Type):
    _toSchema = {'credential_tag': 'credential-tag', 'model_tag': 'model-tag'}
    _toPy = {'credential-tag': 'credential_tag', 'model-tag': 'model_tag'}
    def __init__(self, credential_tag=None, model_tag=None, **unknown_fields):
        '''
        credential_tag : str
        model_tag : str
        '''
        if credential_tag is not None and not isinstance(credential_tag, (bytes, str)):
            raise Exception('Expected credential_tag to be of type str')

        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception('Expected model_tag to be of type str')

        self.credential_tag = credential_tag
        self.model_tag = model_tag
        self.unknown_fields = unknown_fields



class ChangeModelCredentialsParams(Type):
    _toSchema = {'model_credentials': 'model-credentials'}
    _toPy = {'model-credentials': 'model_credentials'}
    def __init__(self, model_credentials=None, **unknown_fields):
        '''
        model_credentials : typing.Sequence[~ChangeModelCredentialParams]
        '''
        if model_credentials is not None and not isinstance(model_credentials, list):
            raise Exception('Expected model_credentials to be of type Sequence')

        self.model_credentials = [ChangeModelCredentialParams.from_json(o) for o in model_credentials or []]
        self.unknown_fields = unknown_fields



class CharmActionSpec(Type):
    _toSchema = {'description': 'description', 'params': 'params'}
    _toPy = {'description': 'description', 'params': 'params'}
    def __init__(self, description=None, params=None, **unknown_fields):
        '''
        description : str
        params : typing.Mapping[str, typing.Any]
        '''
        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if params is not None and not isinstance(params, dict):
            raise Exception('Expected params to be of type Mapping')

        self.description = description
        self.params = params
        self.unknown_fields = unknown_fields



class CharmActions(Type):
    _toSchema = {'specs': 'specs'}
    _toPy = {'specs': 'specs'}
    def __init__(self, specs=None, **unknown_fields):
        '''
        specs : typing.Mapping[str, ~CharmActionSpec]
        '''
        if specs is not None and not isinstance(specs, dict):
            raise Exception('Expected specs to be of type Mapping')

        self.specs = specs
        self.unknown_fields = unknown_fields



class CharmDevice(Type):
    _toSchema = {'countmax': 'CountMax', 'countmin': 'CountMin', 'description': 'Description', 'name': 'Name', 'type_': 'Type'}
    _toPy = {'CountMax': 'countmax', 'CountMin': 'countmin', 'Description': 'description', 'Name': 'name', 'Type': 'type_'}
    def __init__(self, countmax=None, countmin=None, description=None, name=None, type_=None, **unknown_fields):
        '''
        countmax : int
        countmin : int
        description : str
        name : str
        type_ : str
        '''
        if countmax is not None and not isinstance(countmax, int):
            raise Exception('Expected countmax to be of type int')

        if countmin is not None and not isinstance(countmin, int):
            raise Exception('Expected countmin to be of type int')

        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.countmax = countmax
        self.countmin = countmin
        self.description = description
        self.name = name
        self.type_ = type_
        self.unknown_fields = unknown_fields



class CharmInfo(Type):
    _toSchema = {'actions': 'actions', 'config': 'config', 'lxd_profile': 'lxd-profile', 'meta': 'meta', 'metrics': 'metrics', 'revision': 'revision', 'url': 'url'}
    _toPy = {'actions': 'actions', 'config': 'config', 'lxd-profile': 'lxd_profile', 'meta': 'meta', 'metrics': 'metrics', 'revision': 'revision', 'url': 'url'}
    def __init__(self, actions=None, config=None, lxd_profile=None, meta=None, metrics=None, revision=None, url=None, **unknown_fields):
        '''
        actions : CharmActions
        config : typing.Mapping[str, ~CharmOption]
        lxd_profile : CharmLXDProfile
        meta : CharmMeta
        metrics : CharmMetrics
        revision : int
        url : str
        '''
        if actions is not None and not isinstance(actions, CharmActions):
            raise Exception('Expected actions to be of type CharmActions')

        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        if lxd_profile is not None and not isinstance(lxd_profile, CharmLXDProfile):
            raise Exception('Expected lxd_profile to be of type CharmLXDProfile')

        if meta is not None and not isinstance(meta, CharmMeta):
            raise Exception('Expected meta to be of type CharmMeta')

        if metrics is not None and not isinstance(metrics, CharmMetrics):
            raise Exception('Expected metrics to be of type CharmMetrics')

        if revision is not None and not isinstance(revision, int):
            raise Exception('Expected revision to be of type int')

        if url is not None and not isinstance(url, (bytes, str)):
            raise Exception('Expected url to be of type str')

        self.actions = CharmActions.from_json(actions) if actions else None
        self.config = config
        self.lxd_profile = CharmLXDProfile.from_json(lxd_profile) if lxd_profile else None
        self.meta = CharmMeta.from_json(meta) if meta else None
        self.metrics = CharmMetrics.from_json(metrics) if metrics else None
        self.revision = revision
        self.url = url
        self.unknown_fields = unknown_fields



class CharmLXDProfile(Type):
    _toSchema = {'config': 'config', 'description': 'description', 'devices': 'devices'}
    _toPy = {'config': 'config', 'description': 'description', 'devices': 'devices'}
    def __init__(self, config=None, description=None, devices=None, **unknown_fields):
        '''
        config : typing.Mapping[str, str]
        description : str
        devices : typing.Mapping[str, typing.Any]
        '''
        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if devices is not None and not isinstance(devices, dict):
            raise Exception('Expected devices to be of type Mapping')

        self.config = config
        self.description = description
        self.devices = devices
        self.unknown_fields = unknown_fields



class CharmMeta(Type):
    _toSchema = {'categories': 'categories', 'description': 'description', 'devices': 'devices', 'extra_bindings': 'extra-bindings', 'min_juju_version': 'min-juju-version', 'name': 'name', 'payload_classes': 'payload-classes', 'peers': 'peers', 'provides': 'provides', 'requires': 'requires', 'resources': 'resources', 'series': 'series', 'storage': 'storage', 'subordinate': 'subordinate', 'summary': 'summary', 'tags': 'tags', 'terms': 'terms'}
    _toPy = {'categories': 'categories', 'description': 'description', 'devices': 'devices', 'extra-bindings': 'extra_bindings', 'min-juju-version': 'min_juju_version', 'name': 'name', 'payload-classes': 'payload_classes', 'peers': 'peers', 'provides': 'provides', 'requires': 'requires', 'resources': 'resources', 'series': 'series', 'storage': 'storage', 'subordinate': 'subordinate', 'summary': 'summary', 'tags': 'tags', 'terms': 'terms'}
    def __init__(self, categories=None, description=None, devices=None, extra_bindings=None, min_juju_version=None, name=None, payload_classes=None, peers=None, provides=None, requires=None, resources=None, series=None, storage=None, subordinate=None, summary=None, tags=None, terms=None, **unknown_fields):
        '''
        categories : typing.Sequence[str]
        description : str
        devices : typing.Mapping[str, ~CharmDevice]
        extra_bindings : typing.Mapping[str, str]
        min_juju_version : str
        name : str
        payload_classes : typing.Mapping[str, ~CharmPayloadClass]
        peers : typing.Mapping[str, ~CharmRelation]
        provides : typing.Mapping[str, ~CharmRelation]
        requires : typing.Mapping[str, ~CharmRelation]
        resources : typing.Mapping[str, ~CharmResourceMeta]
        series : typing.Sequence[str]
        storage : typing.Mapping[str, ~CharmStorage]
        subordinate : bool
        summary : str
        tags : typing.Sequence[str]
        terms : typing.Sequence[str]
        '''
        if categories is not None and not isinstance(categories, list):
            raise Exception('Expected categories to be of type Sequence')

        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if devices is not None and not isinstance(devices, dict):
            raise Exception('Expected devices to be of type Mapping')

        if extra_bindings is not None and not isinstance(extra_bindings, dict):
            raise Exception('Expected extra_bindings to be of type Mapping')

        if min_juju_version is not None and not isinstance(min_juju_version, (bytes, str)):
            raise Exception('Expected min_juju_version to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if payload_classes is not None and not isinstance(payload_classes, dict):
            raise Exception('Expected payload_classes to be of type Mapping')

        if peers is not None and not isinstance(peers, dict):
            raise Exception('Expected peers to be of type Mapping')

        if provides is not None and not isinstance(provides, dict):
            raise Exception('Expected provides to be of type Mapping')

        if requires is not None and not isinstance(requires, dict):
            raise Exception('Expected requires to be of type Mapping')

        if resources is not None and not isinstance(resources, dict):
            raise Exception('Expected resources to be of type Mapping')

        if series is not None and not isinstance(series, list):
            raise Exception('Expected series to be of type Sequence')

        if storage is not None and not isinstance(storage, dict):
            raise Exception('Expected storage to be of type Mapping')

        if subordinate is not None and not isinstance(subordinate, bool):
            raise Exception('Expected subordinate to be of type bool')

        if summary is not None and not isinstance(summary, (bytes, str)):
            raise Exception('Expected summary to be of type str')

        if tags is not None and not isinstance(tags, list):
            raise Exception('Expected tags to be of type Sequence')

        if terms is not None and not isinstance(terms, list):
            raise Exception('Expected terms to be of type Sequence')

        self.categories = categories
        self.description = description
        self.devices = devices
        self.extra_bindings = extra_bindings
        self.min_juju_version = min_juju_version
        self.name = name
        self.payload_classes = payload_classes
        self.peers = peers
        self.provides = provides
        self.requires = requires
        self.resources = resources
        self.series = series
        self.storage = storage
        self.subordinate = subordinate
        self.summary = summary
        self.tags = tags
        self.terms = terms
        self.unknown_fields = unknown_fields



class CharmMetric(Type):
    _toSchema = {'description': 'description', 'type_': 'type'}
    _toPy = {'description': 'description', 'type': 'type_'}
    def __init__(self, description=None, type_=None, **unknown_fields):
        '''
        description : str
        type_ : str
        '''
        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.description = description
        self.type_ = type_
        self.unknown_fields = unknown_fields



class CharmMetrics(Type):
    _toSchema = {'metrics': 'metrics', 'plan': 'plan'}
    _toPy = {'metrics': 'metrics', 'plan': 'plan'}
    def __init__(self, metrics=None, plan=None, **unknown_fields):
        '''
        metrics : typing.Mapping[str, ~CharmMetric]
        plan : CharmPlan
        '''
        if metrics is not None and not isinstance(metrics, dict):
            raise Exception('Expected metrics to be of type Mapping')

        if plan is not None and not isinstance(plan, CharmPlan):
            raise Exception('Expected plan to be of type CharmPlan')

        self.metrics = metrics
        self.plan = CharmPlan.from_json(plan) if plan else None
        self.unknown_fields = unknown_fields



class CharmOption(Type):
    _toSchema = {'default': 'default', 'description': 'description', 'type_': 'type'}
    _toPy = {'default': 'default', 'description': 'description', 'type': 'type_'}
    def __init__(self, default=None, description=None, type_=None, **unknown_fields):
        '''
        default : typing.Mapping[str, typing.Any]
        description : str
        type_ : str
        '''
        if default is not None and not isinstance(default, dict):
            raise Exception('Expected default to be of type Mapping')

        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.default = default
        self.description = description
        self.type_ = type_
        self.unknown_fields = unknown_fields



class CharmPayloadClass(Type):
    _toSchema = {'name': 'name', 'type_': 'type'}
    _toPy = {'name': 'name', 'type': 'type_'}
    def __init__(self, name=None, type_=None, **unknown_fields):
        '''
        name : str
        type_ : str
        '''
        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.name = name
        self.type_ = type_
        self.unknown_fields = unknown_fields



class CharmPlan(Type):
    _toSchema = {'required': 'required'}
    _toPy = {'required': 'required'}
    def __init__(self, required=None, **unknown_fields):
        '''
        required : bool
        '''
        if required is not None and not isinstance(required, bool):
            raise Exception('Expected required to be of type bool')

        self.required = required
        self.unknown_fields = unknown_fields



class CharmProfilingInfoResult(Type):
    _toSchema = {'current_profiles': 'current-profiles', 'error': 'error', 'instance_id': 'instance-id', 'model_name': 'model-name', 'profile_changes': 'profile-changes'}
    _toPy = {'current-profiles': 'current_profiles', 'error': 'error', 'instance-id': 'instance_id', 'model-name': 'model_name', 'profile-changes': 'profile_changes'}
    def __init__(self, current_profiles=None, error=None, instance_id=None, model_name=None, profile_changes=None, **unknown_fields):
        '''
        current_profiles : typing.Sequence[str]
        error : Error
        instance_id : str
        model_name : str
        profile_changes : typing.Sequence[~ProfileInfoResult]
        '''
        if current_profiles is not None and not isinstance(current_profiles, list):
            raise Exception('Expected current_profiles to be of type Sequence')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if instance_id is not None and not isinstance(instance_id, (bytes, str)):
            raise Exception('Expected instance_id to be of type str')

        if model_name is not None and not isinstance(model_name, (bytes, str)):
            raise Exception('Expected model_name to be of type str')

        if profile_changes is not None and not isinstance(profile_changes, list):
            raise Exception('Expected profile_changes to be of type Sequence')

        self.current_profiles = current_profiles
        self.error = Error.from_json(error) if error else None
        self.instance_id = instance_id
        self.model_name = model_name
        self.profile_changes = [ProfileInfoResult.from_json(o) for o in profile_changes or []]
        self.unknown_fields = unknown_fields



class CharmRelation(Type):
    _toSchema = {'interface': 'interface', 'limit': 'limit', 'name': 'name', 'optional': 'optional', 'role': 'role', 'scope': 'scope'}
    _toPy = {'interface': 'interface', 'limit': 'limit', 'name': 'name', 'optional': 'optional', 'role': 'role', 'scope': 'scope'}
    def __init__(self, interface=None, limit=None, name=None, optional=None, role=None, scope=None, **unknown_fields):
        '''
        interface : str
        limit : int
        name : str
        optional : bool
        role : str
        scope : str
        '''
        if interface is not None and not isinstance(interface, (bytes, str)):
            raise Exception('Expected interface to be of type str')

        if limit is not None and not isinstance(limit, int):
            raise Exception('Expected limit to be of type int')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if optional is not None and not isinstance(optional, bool):
            raise Exception('Expected optional to be of type bool')

        if role is not None and not isinstance(role, (bytes, str)):
            raise Exception('Expected role to be of type str')

        if scope is not None and not isinstance(scope, (bytes, str)):
            raise Exception('Expected scope to be of type str')

        self.interface = interface
        self.limit = limit
        self.name = name
        self.optional = optional
        self.role = role
        self.scope = scope
        self.unknown_fields = unknown_fields



class CharmResource(Type):
    _toSchema = {'description': 'description', 'fingerprint': 'fingerprint', 'name': 'name', 'origin': 'origin', 'path': 'path', 'revision': 'revision', 'size': 'size', 'type_': 'type'}
    _toPy = {'description': 'description', 'fingerprint': 'fingerprint', 'name': 'name', 'origin': 'origin', 'path': 'path', 'revision': 'revision', 'size': 'size', 'type': 'type_'}
    def __init__(self, description=None, fingerprint=None, name=None, origin=None, path=None, revision=None, size=None, type_=None, **unknown_fields):
        '''
        description : str
        fingerprint : typing.Sequence[int]
        name : str
        origin : str
        path : str
        revision : int
        size : int
        type_ : str
        '''
        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if fingerprint is not None and not isinstance(fingerprint, list):
            raise Exception('Expected fingerprint to be of type Sequence')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if origin is not None and not isinstance(origin, (bytes, str)):
            raise Exception('Expected origin to be of type str')

        if path is not None and not isinstance(path, (bytes, str)):
            raise Exception('Expected path to be of type str')

        if revision is not None and not isinstance(revision, int):
            raise Exception('Expected revision to be of type int')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.description = description
        self.fingerprint = fingerprint
        self.name = name
        self.origin = origin
        self.path = path
        self.revision = revision
        self.size = size
        self.type_ = type_
        self.unknown_fields = unknown_fields



class CharmResourceMeta(Type):
    _toSchema = {'description': 'description', 'name': 'name', 'path': 'path', 'type_': 'type'}
    _toPy = {'description': 'description', 'name': 'name', 'path': 'path', 'type': 'type_'}
    def __init__(self, description=None, name=None, path=None, type_=None, **unknown_fields):
        '''
        description : str
        name : str
        path : str
        type_ : str
        '''
        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if path is not None and not isinstance(path, (bytes, str)):
            raise Exception('Expected path to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.description = description
        self.name = name
        self.path = path
        self.type_ = type_
        self.unknown_fields = unknown_fields



class CharmStorage(Type):
    _toSchema = {'count_max': 'count-max', 'count_min': 'count-min', 'description': 'description', 'location': 'location', 'minimum_size': 'minimum-size', 'name': 'name', 'properties': 'properties', 'read_only': 'read-only', 'shared': 'shared', 'type_': 'type'}
    _toPy = {'count-max': 'count_max', 'count-min': 'count_min', 'description': 'description', 'location': 'location', 'minimum-size': 'minimum_size', 'name': 'name', 'properties': 'properties', 'read-only': 'read_only', 'shared': 'shared', 'type': 'type_'}
    def __init__(self, count_max=None, count_min=None, description=None, location=None, minimum_size=None, name=None, properties=None, read_only=None, shared=None, type_=None, **unknown_fields):
        '''
        count_max : int
        count_min : int
        description : str
        location : str
        minimum_size : int
        name : str
        properties : typing.Sequence[str]
        read_only : bool
        shared : bool
        type_ : str
        '''
        if count_max is not None and not isinstance(count_max, int):
            raise Exception('Expected count_max to be of type int')

        if count_min is not None and not isinstance(count_min, int):
            raise Exception('Expected count_min to be of type int')

        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if location is not None and not isinstance(location, (bytes, str)):
            raise Exception('Expected location to be of type str')

        if minimum_size is not None and not isinstance(minimum_size, int):
            raise Exception('Expected minimum_size to be of type int')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if properties is not None and not isinstance(properties, list):
            raise Exception('Expected properties to be of type Sequence')

        if read_only is not None and not isinstance(read_only, bool):
            raise Exception('Expected read_only to be of type bool')

        if shared is not None and not isinstance(shared, bool):
            raise Exception('Expected shared to be of type bool')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.count_max = count_max
        self.count_min = count_min
        self.description = description
        self.location = location
        self.minimum_size = minimum_size
        self.name = name
        self.properties = properties
        self.read_only = read_only
        self.shared = shared
        self.type_ = type_
        self.unknown_fields = unknown_fields



class CharmURL(Type):
    _toSchema = {'url': 'url'}
    _toPy = {'url': 'url'}
    def __init__(self, url=None, **unknown_fields):
        '''
        url : str
        '''
        if url is not None and not isinstance(url, (bytes, str)):
            raise Exception('Expected url to be of type str')

        self.url = url
        self.unknown_fields = unknown_fields



class CharmURLs(Type):
    _toSchema = {'urls': 'urls'}
    _toPy = {'urls': 'urls'}
    def __init__(self, urls=None, **unknown_fields):
        '''
        urls : typing.Sequence[~CharmURL]
        '''
        if urls is not None and not isinstance(urls, list):
            raise Exception('Expected urls to be of type Sequence')

        self.urls = [CharmURL.from_json(o) for o in urls or []]
        self.unknown_fields = unknown_fields



class CharmsList(Type):
    _toSchema = {'names': 'names'}
    _toPy = {'names': 'names'}
    def __init__(self, names=None, **unknown_fields):
        '''
        names : typing.Sequence[str]
        '''
        if names is not None and not isinstance(names, list):
            raise Exception('Expected names to be of type Sequence')

        self.names = names
        self.unknown_fields = unknown_fields



class CharmsListResult(Type):
    _toSchema = {'charm_urls': 'charm-urls'}
    _toPy = {'charm-urls': 'charm_urls'}
    def __init__(self, charm_urls=None, **unknown_fields):
        '''
        charm_urls : typing.Sequence[str]
        '''
        if charm_urls is not None and not isinstance(charm_urls, list):
            raise Exception('Expected charm_urls to be of type Sequence')

        self.charm_urls = charm_urls
        self.unknown_fields = unknown_fields



class ClaimLeadershipBulkParams(Type):
    _toSchema = {'params': 'params'}
    _toPy = {'params': 'params'}
    def __init__(self, params=None, **unknown_fields):
        '''
        params : typing.Sequence[~ClaimLeadershipParams]
        '''
        if params is not None and not isinstance(params, list):
            raise Exception('Expected params to be of type Sequence')

        self.params = [ClaimLeadershipParams.from_json(o) for o in params or []]
        self.unknown_fields = unknown_fields



class ClaimLeadershipBulkResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ErrorResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ErrorResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ClaimLeadershipParams(Type):
    _toSchema = {'application_tag': 'application-tag', 'duration': 'duration', 'unit_tag': 'unit-tag'}
    _toPy = {'application-tag': 'application_tag', 'duration': 'duration', 'unit-tag': 'unit_tag'}
    def __init__(self, application_tag=None, duration=None, unit_tag=None, **unknown_fields):
        '''
        application_tag : str
        duration : float
        unit_tag : str
        '''
        if application_tag is not None and not isinstance(application_tag, (bytes, str)):
            raise Exception('Expected application_tag to be of type str')

        if duration is not None and not isinstance(duration, float):
            raise Exception('Expected duration to be of type float')

        if unit_tag is not None and not isinstance(unit_tag, (bytes, str)):
            raise Exception('Expected unit_tag to be of type str')

        self.application_tag = application_tag
        self.duration = duration
        self.unit_tag = unit_tag
        self.unknown_fields = unknown_fields



class Cloud(Type):
    _toSchema = {'auth_types': 'auth-types', 'ca_certificates': 'ca-certificates', 'config': 'config', 'endpoint': 'endpoint', 'host_cloud_region': 'host-cloud-region', 'identity_endpoint': 'identity-endpoint', 'region_config': 'region-config', 'regions': 'regions', 'storage_endpoint': 'storage-endpoint', 'type_': 'type'}
    _toPy = {'auth-types': 'auth_types', 'ca-certificates': 'ca_certificates', 'config': 'config', 'endpoint': 'endpoint', 'host-cloud-region': 'host_cloud_region', 'identity-endpoint': 'identity_endpoint', 'region-config': 'region_config', 'regions': 'regions', 'storage-endpoint': 'storage_endpoint', 'type': 'type_'}
    def __init__(self, auth_types=None, ca_certificates=None, config=None, endpoint=None, host_cloud_region=None, identity_endpoint=None, region_config=None, regions=None, storage_endpoint=None, type_=None, **unknown_fields):
        '''
        auth_types : typing.Sequence[str]
        ca_certificates : typing.Sequence[str]
        config : typing.Mapping[str, typing.Any]
        endpoint : str
        host_cloud_region : str
        identity_endpoint : str
        region_config : typing.Mapping[str, typing.Any]
        regions : typing.Sequence[~CloudRegion]
        storage_endpoint : str
        type_ : str
        '''
        if auth_types is not None and not isinstance(auth_types, list):
            raise Exception('Expected auth_types to be of type Sequence')

        if ca_certificates is not None and not isinstance(ca_certificates, list):
            raise Exception('Expected ca_certificates to be of type Sequence')

        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        if endpoint is not None and not isinstance(endpoint, (bytes, str)):
            raise Exception('Expected endpoint to be of type str')

        if host_cloud_region is not None and not isinstance(host_cloud_region, (bytes, str)):
            raise Exception('Expected host_cloud_region to be of type str')

        if identity_endpoint is not None and not isinstance(identity_endpoint, (bytes, str)):
            raise Exception('Expected identity_endpoint to be of type str')

        if region_config is not None and not isinstance(region_config, dict):
            raise Exception('Expected region_config to be of type Mapping')

        if regions is not None and not isinstance(regions, list):
            raise Exception('Expected regions to be of type Sequence')

        if storage_endpoint is not None and not isinstance(storage_endpoint, (bytes, str)):
            raise Exception('Expected storage_endpoint to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.auth_types = auth_types
        self.ca_certificates = ca_certificates
        self.config = config
        self.endpoint = endpoint
        self.host_cloud_region = host_cloud_region
        self.identity_endpoint = identity_endpoint
        self.region_config = region_config
        self.regions = [CloudRegion.from_json(o) for o in regions or []]
        self.storage_endpoint = storage_endpoint
        self.type_ = type_
        self.unknown_fields = unknown_fields



class CloudCredential(Type):
    _toSchema = {'attrs': 'attrs', 'auth_type': 'auth-type', 'redacted': 'redacted'}
    _toPy = {'attrs': 'attrs', 'auth-type': 'auth_type', 'redacted': 'redacted'}
    def __init__(self, attrs=None, auth_type=None, redacted=None, **unknown_fields):
        '''
        attrs : typing.Mapping[str, str]
        auth_type : str
        redacted : typing.Sequence[str]
        '''
        if attrs is not None and not isinstance(attrs, dict):
            raise Exception('Expected attrs to be of type Mapping')

        if auth_type is not None and not isinstance(auth_type, (bytes, str)):
            raise Exception('Expected auth_type to be of type str')

        if redacted is not None and not isinstance(redacted, list):
            raise Exception('Expected redacted to be of type Sequence')

        self.attrs = attrs
        self.auth_type = auth_type
        self.redacted = redacted
        self.unknown_fields = unknown_fields



class CloudCredentialArg(Type):
    _toSchema = {'cloud_name': 'cloud-name', 'credential_name': 'credential-name'}
    _toPy = {'cloud-name': 'cloud_name', 'credential-name': 'credential_name'}
    def __init__(self, cloud_name=None, credential_name=None, **unknown_fields):
        '''
        cloud_name : str
        credential_name : str
        '''
        if cloud_name is not None and not isinstance(cloud_name, (bytes, str)):
            raise Exception('Expected cloud_name to be of type str')

        if credential_name is not None and not isinstance(credential_name, (bytes, str)):
            raise Exception('Expected credential_name to be of type str')

        self.cloud_name = cloud_name
        self.credential_name = credential_name
        self.unknown_fields = unknown_fields



class CloudCredentialArgs(Type):
    _toSchema = {'credentials': 'credentials', 'include_secrets': 'include-secrets'}
    _toPy = {'credentials': 'credentials', 'include-secrets': 'include_secrets'}
    def __init__(self, credentials=None, include_secrets=None, **unknown_fields):
        '''
        credentials : typing.Sequence[~CloudCredentialArg]
        include_secrets : bool
        '''
        if credentials is not None and not isinstance(credentials, list):
            raise Exception('Expected credentials to be of type Sequence')

        if include_secrets is not None and not isinstance(include_secrets, bool):
            raise Exception('Expected include_secrets to be of type bool')

        self.credentials = [CloudCredentialArg.from_json(o) for o in credentials or []]
        self.include_secrets = include_secrets
        self.unknown_fields = unknown_fields



class CloudCredentialResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : CloudCredential
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, CloudCredential):
            raise Exception('Expected result to be of type CloudCredential')

        self.error = Error.from_json(error) if error else None
        self.result = CloudCredential.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class CloudCredentialResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~CloudCredentialResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [CloudCredentialResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class CloudDetails(Type):
    _toSchema = {'auth_types': 'auth-types', 'endpoint': 'endpoint', 'identity_endpoint': 'identity-endpoint', 'regions': 'regions', 'storage_endpoint': 'storage-endpoint', 'type_': 'type'}
    _toPy = {'auth-types': 'auth_types', 'endpoint': 'endpoint', 'identity-endpoint': 'identity_endpoint', 'regions': 'regions', 'storage-endpoint': 'storage_endpoint', 'type': 'type_'}
    def __init__(self, auth_types=None, endpoint=None, identity_endpoint=None, regions=None, storage_endpoint=None, type_=None, **unknown_fields):
        '''
        auth_types : typing.Sequence[str]
        endpoint : str
        identity_endpoint : str
        regions : typing.Sequence[~CloudRegion]
        storage_endpoint : str
        type_ : str
        '''
        if auth_types is not None and not isinstance(auth_types, list):
            raise Exception('Expected auth_types to be of type Sequence')

        if endpoint is not None and not isinstance(endpoint, (bytes, str)):
            raise Exception('Expected endpoint to be of type str')

        if identity_endpoint is not None and not isinstance(identity_endpoint, (bytes, str)):
            raise Exception('Expected identity_endpoint to be of type str')

        if regions is not None and not isinstance(regions, list):
            raise Exception('Expected regions to be of type Sequence')

        if storage_endpoint is not None and not isinstance(storage_endpoint, (bytes, str)):
            raise Exception('Expected storage_endpoint to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.auth_types = auth_types
        self.endpoint = endpoint
        self.identity_endpoint = identity_endpoint
        self.regions = [CloudRegion.from_json(o) for o in regions or []]
        self.storage_endpoint = storage_endpoint
        self.type_ = type_
        self.unknown_fields = unknown_fields



class CloudImageMetadata(Type):
    _toSchema = {'arch': 'arch', 'image_id': 'image-id', 'priority': 'priority', 'region': 'region', 'root_storage_size': 'root-storage-size', 'root_storage_type': 'root-storage-type', 'series': 'series', 'source': 'source', 'stream': 'stream', 'version': 'version', 'virt_type': 'virt-type'}
    _toPy = {'arch': 'arch', 'image-id': 'image_id', 'priority': 'priority', 'region': 'region', 'root-storage-size': 'root_storage_size', 'root-storage-type': 'root_storage_type', 'series': 'series', 'source': 'source', 'stream': 'stream', 'version': 'version', 'virt-type': 'virt_type'}
    def __init__(self, arch=None, image_id=None, priority=None, region=None, root_storage_size=None, root_storage_type=None, series=None, source=None, stream=None, version=None, virt_type=None, **unknown_fields):
        '''
        arch : str
        image_id : str
        priority : int
        region : str
        root_storage_size : int
        root_storage_type : str
        series : str
        source : str
        stream : str
        version : str
        virt_type : str
        '''
        if arch is not None and not isinstance(arch, (bytes, str)):
            raise Exception('Expected arch to be of type str')

        if image_id is not None and not isinstance(image_id, (bytes, str)):
            raise Exception('Expected image_id to be of type str')

        if priority is not None and not isinstance(priority, int):
            raise Exception('Expected priority to be of type int')

        if region is not None and not isinstance(region, (bytes, str)):
            raise Exception('Expected region to be of type str')

        if root_storage_size is not None and not isinstance(root_storage_size, int):
            raise Exception('Expected root_storage_size to be of type int')

        if root_storage_type is not None and not isinstance(root_storage_type, (bytes, str)):
            raise Exception('Expected root_storage_type to be of type str')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        if source is not None and not isinstance(source, (bytes, str)):
            raise Exception('Expected source to be of type str')

        if stream is not None and not isinstance(stream, (bytes, str)):
            raise Exception('Expected stream to be of type str')

        if version is not None and not isinstance(version, (bytes, str)):
            raise Exception('Expected version to be of type str')

        if virt_type is not None and not isinstance(virt_type, (bytes, str)):
            raise Exception('Expected virt_type to be of type str')

        self.arch = arch
        self.image_id = image_id
        self.priority = priority
        self.region = region
        self.root_storage_size = root_storage_size
        self.root_storage_type = root_storage_type
        self.series = series
        self.source = source
        self.stream = stream
        self.version = version
        self.virt_type = virt_type
        self.unknown_fields = unknown_fields



class CloudImageMetadataList(Type):
    _toSchema = {'metadata': 'metadata'}
    _toPy = {'metadata': 'metadata'}
    def __init__(self, metadata=None, **unknown_fields):
        '''
        metadata : typing.Sequence[~CloudImageMetadata]
        '''
        if metadata is not None and not isinstance(metadata, list):
            raise Exception('Expected metadata to be of type Sequence')

        self.metadata = [CloudImageMetadata.from_json(o) for o in metadata or []]
        self.unknown_fields = unknown_fields



class CloudInfo(Type):
    _toSchema = {'clouddetails': 'CloudDetails', 'users': 'users'}
    _toPy = {'CloudDetails': 'clouddetails', 'users': 'users'}
    def __init__(self, clouddetails=None, users=None, **unknown_fields):
        '''
        clouddetails : CloudDetails
        users : typing.Sequence[~CloudUserInfo]
        '''
        if clouddetails is not None and not isinstance(clouddetails, CloudDetails):
            raise Exception('Expected clouddetails to be of type CloudDetails')

        if users is not None and not isinstance(users, list):
            raise Exception('Expected users to be of type Sequence')

        self.clouddetails = CloudDetails.from_json(clouddetails) if clouddetails else None
        self.users = [CloudUserInfo.from_json(o) for o in users or []]
        self.unknown_fields = unknown_fields



class CloudInfoResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : CloudInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, CloudInfo):
            raise Exception('Expected result to be of type CloudInfo')

        self.error = Error.from_json(error) if error else None
        self.result = CloudInfo.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class CloudInfoResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~CloudInfoResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [CloudInfoResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class CloudInstanceTypesConstraint(Type):
    _toSchema = {'cloud_tag': 'cloud-tag', 'constraints': 'constraints', 'region': 'region'}
    _toPy = {'cloud-tag': 'cloud_tag', 'constraints': 'constraints', 'region': 'region'}
    def __init__(self, cloud_tag=None, constraints=None, region=None, **unknown_fields):
        '''
        cloud_tag : str
        constraints : Value
        region : str
        '''
        if cloud_tag is not None and not isinstance(cloud_tag, (bytes, str)):
            raise Exception('Expected cloud_tag to be of type str')

        if constraints is not None and not isinstance(constraints, Value):
            raise Exception('Expected constraints to be of type Value')

        if region is not None and not isinstance(region, (bytes, str)):
            raise Exception('Expected region to be of type str')

        self.cloud_tag = cloud_tag
        self.constraints = Value.from_json(constraints) if constraints else None
        self.region = region
        self.unknown_fields = unknown_fields



class CloudInstanceTypesConstraints(Type):
    _toSchema = {'constraints': 'constraints'}
    _toPy = {'constraints': 'constraints'}
    def __init__(self, constraints=None, **unknown_fields):
        '''
        constraints : typing.Sequence[~CloudInstanceTypesConstraint]
        '''
        if constraints is not None and not isinstance(constraints, list):
            raise Exception('Expected constraints to be of type Sequence')

        self.constraints = [CloudInstanceTypesConstraint.from_json(o) for o in constraints or []]
        self.unknown_fields = unknown_fields



class CloudRegion(Type):
    _toSchema = {'endpoint': 'endpoint', 'identity_endpoint': 'identity-endpoint', 'name': 'name', 'storage_endpoint': 'storage-endpoint'}
    _toPy = {'endpoint': 'endpoint', 'identity-endpoint': 'identity_endpoint', 'name': 'name', 'storage-endpoint': 'storage_endpoint'}
    def __init__(self, endpoint=None, identity_endpoint=None, name=None, storage_endpoint=None, **unknown_fields):
        '''
        endpoint : str
        identity_endpoint : str
        name : str
        storage_endpoint : str
        '''
        if endpoint is not None and not isinstance(endpoint, (bytes, str)):
            raise Exception('Expected endpoint to be of type str')

        if identity_endpoint is not None and not isinstance(identity_endpoint, (bytes, str)):
            raise Exception('Expected identity_endpoint to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if storage_endpoint is not None and not isinstance(storage_endpoint, (bytes, str)):
            raise Exception('Expected storage_endpoint to be of type str')

        self.endpoint = endpoint
        self.identity_endpoint = identity_endpoint
        self.name = name
        self.storage_endpoint = storage_endpoint
        self.unknown_fields = unknown_fields



class CloudResult(Type):
    _toSchema = {'cloud': 'cloud', 'error': 'error'}
    _toPy = {'cloud': 'cloud', 'error': 'error'}
    def __init__(self, cloud=None, error=None, **unknown_fields):
        '''
        cloud : Cloud
        error : Error
        '''
        if cloud is not None and not isinstance(cloud, Cloud):
            raise Exception('Expected cloud to be of type Cloud')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.cloud = Cloud.from_json(cloud) if cloud else None
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class CloudResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~CloudResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [CloudResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class CloudSpec(Type):
    _toSchema = {'cacertificates': 'cacertificates', 'credential': 'credential', 'endpoint': 'endpoint', 'identity_endpoint': 'identity-endpoint', 'name': 'name', 'region': 'region', 'storage_endpoint': 'storage-endpoint', 'type_': 'type'}
    _toPy = {'cacertificates': 'cacertificates', 'credential': 'credential', 'endpoint': 'endpoint', 'identity-endpoint': 'identity_endpoint', 'name': 'name', 'region': 'region', 'storage-endpoint': 'storage_endpoint', 'type': 'type_'}
    def __init__(self, cacertificates=None, credential=None, endpoint=None, identity_endpoint=None, name=None, region=None, storage_endpoint=None, type_=None, **unknown_fields):
        '''
        cacertificates : typing.Sequence[str]
        credential : CloudCredential
        endpoint : str
        identity_endpoint : str
        name : str
        region : str
        storage_endpoint : str
        type_ : str
        '''
        if cacertificates is not None and not isinstance(cacertificates, list):
            raise Exception('Expected cacertificates to be of type Sequence')

        if credential is not None and not isinstance(credential, CloudCredential):
            raise Exception('Expected credential to be of type CloudCredential')

        if endpoint is not None and not isinstance(endpoint, (bytes, str)):
            raise Exception('Expected endpoint to be of type str')

        if identity_endpoint is not None and not isinstance(identity_endpoint, (bytes, str)):
            raise Exception('Expected identity_endpoint to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if region is not None and not isinstance(region, (bytes, str)):
            raise Exception('Expected region to be of type str')

        if storage_endpoint is not None and not isinstance(storage_endpoint, (bytes, str)):
            raise Exception('Expected storage_endpoint to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.cacertificates = cacertificates
        self.credential = CloudCredential.from_json(credential) if credential else None
        self.endpoint = endpoint
        self.identity_endpoint = identity_endpoint
        self.name = name
        self.region = region
        self.storage_endpoint = storage_endpoint
        self.type_ = type_
        self.unknown_fields = unknown_fields



class CloudSpecResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : CloudSpec
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, CloudSpec):
            raise Exception('Expected result to be of type CloudSpec')

        self.error = Error.from_json(error) if error else None
        self.result = CloudSpec.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class CloudSpecResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~CloudSpecResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [CloudSpecResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class CloudUserInfo(Type):
    _toSchema = {'access': 'access', 'display_name': 'display-name', 'user': 'user'}
    _toPy = {'access': 'access', 'display-name': 'display_name', 'user': 'user'}
    def __init__(self, access=None, display_name=None, user=None, **unknown_fields):
        '''
        access : str
        display_name : str
        user : str
        '''
        if access is not None and not isinstance(access, (bytes, str)):
            raise Exception('Expected access to be of type str')

        if display_name is not None and not isinstance(display_name, (bytes, str)):
            raise Exception('Expected display_name to be of type str')

        if user is not None and not isinstance(user, (bytes, str)):
            raise Exception('Expected user to be of type str')

        self.access = access
        self.display_name = display_name
        self.user = user
        self.unknown_fields = unknown_fields



class CloudsResult(Type):
    _toSchema = {'clouds': 'clouds'}
    _toPy = {'clouds': 'clouds'}
    def __init__(self, clouds=None, **unknown_fields):
        '''
        clouds : typing.Mapping[str, ~Cloud]
        '''
        if clouds is not None and not isinstance(clouds, dict):
            raise Exception('Expected clouds to be of type Mapping')

        self.clouds = clouds
        self.unknown_fields = unknown_fields



class ConfigResult(Type):
    _toSchema = {'config': 'config', 'error': 'error'}
    _toPy = {'config': 'config', 'error': 'error'}
    def __init__(self, config=None, error=None, **unknown_fields):
        '''
        config : typing.Mapping[str, typing.Any]
        error : Error
        '''
        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.config = config
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class ConfigSettingsResult(Type):
    _toSchema = {'error': 'error', 'settings': 'settings'}
    _toPy = {'error': 'error', 'settings': 'settings'}
    def __init__(self, error=None, settings=None, **unknown_fields):
        '''
        error : Error
        settings : typing.Mapping[str, typing.Any]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if settings is not None and not isinstance(settings, dict):
            raise Exception('Expected settings to be of type Mapping')

        self.error = Error.from_json(error) if error else None
        self.settings = settings
        self.unknown_fields = unknown_fields



class ConfigSettingsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ConfigSettingsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ConfigSettingsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ConfigValue(Type):
    _toSchema = {'source': 'source', 'value': 'value'}
    _toPy = {'source': 'source', 'value': 'value'}
    def __init__(self, source=None, value=None, **unknown_fields):
        '''
        source : str
        value : typing.Mapping[str, typing.Any]
        '''
        if source is not None and not isinstance(source, (bytes, str)):
            raise Exception('Expected source to be of type str')

        if value is not None and not isinstance(value, dict):
            raise Exception('Expected value to be of type Mapping')

        self.source = source
        self.value = value
        self.unknown_fields = unknown_fields



class Constraints(Type):
    _toSchema = {'count': 'Count', 'pool': 'Pool', 'size': 'Size'}
    _toPy = {'Count': 'count', 'Pool': 'pool', 'Size': 'size'}
    def __init__(self, count=None, pool=None, size=None, **unknown_fields):
        '''
        count : int
        pool : str
        size : int
        '''
        if count is not None and not isinstance(count, int):
            raise Exception('Expected count to be of type int')

        if pool is not None and not isinstance(pool, (bytes, str)):
            raise Exception('Expected pool to be of type str')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        self.count = count
        self.pool = pool
        self.size = size
        self.unknown_fields = unknown_fields



class ConstraintsResult(Type):
    _toSchema = {'constraints': 'constraints', 'error': 'error'}
    _toPy = {'constraints': 'constraints', 'error': 'error'}
    def __init__(self, constraints=None, error=None, **unknown_fields):
        '''
        constraints : Value
        error : Error
        '''
        if constraints is not None and not isinstance(constraints, Value):
            raise Exception('Expected constraints to be of type Value')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.constraints = Value.from_json(constraints) if constraints else None
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class ConstraintsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ConstraintsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ConstraintsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ConsumeApplicationArg(Type):
    _toSchema = {'application_alias': 'application-alias', 'application_description': 'application-description', 'applicationofferdetails': 'ApplicationOfferDetails', 'bindings': 'bindings', 'endpoints': 'endpoints', 'external_controller': 'external-controller', 'macaroon': 'macaroon', 'offer_name': 'offer-name', 'offer_url': 'offer-url', 'offer_uuid': 'offer-uuid', 'source_model_tag': 'source-model-tag', 'spaces': 'spaces', 'users': 'users'}
    _toPy = {'ApplicationOfferDetails': 'applicationofferdetails', 'application-alias': 'application_alias', 'application-description': 'application_description', 'bindings': 'bindings', 'endpoints': 'endpoints', 'external-controller': 'external_controller', 'macaroon': 'macaroon', 'offer-name': 'offer_name', 'offer-url': 'offer_url', 'offer-uuid': 'offer_uuid', 'source-model-tag': 'source_model_tag', 'spaces': 'spaces', 'users': 'users'}
    def __init__(self, applicationofferdetails=None, application_alias=None, application_description=None, bindings=None, endpoints=None, external_controller=None, macaroon=None, offer_name=None, offer_url=None, offer_uuid=None, source_model_tag=None, spaces=None, users=None, **unknown_fields):
        '''
        applicationofferdetails : ApplicationOfferDetails
        application_alias : str
        application_description : str
        bindings : typing.Mapping[str, str]
        endpoints : typing.Sequence[~RemoteEndpoint]
        external_controller : ExternalControllerInfo
        macaroon : Macaroon
        offer_name : str
        offer_url : str
        offer_uuid : str
        source_model_tag : str
        spaces : typing.Sequence[~RemoteSpace]
        users : typing.Sequence[~OfferUserDetails]
        '''
        if applicationofferdetails is not None and not isinstance(applicationofferdetails, ApplicationOfferDetails):
            raise Exception('Expected applicationofferdetails to be of type ApplicationOfferDetails')

        if application_alias is not None and not isinstance(application_alias, (bytes, str)):
            raise Exception('Expected application_alias to be of type str')

        if application_description is not None and not isinstance(application_description, (bytes, str)):
            raise Exception('Expected application_description to be of type str')

        if bindings is not None and not isinstance(bindings, dict):
            raise Exception('Expected bindings to be of type Mapping')

        if endpoints is not None and not isinstance(endpoints, list):
            raise Exception('Expected endpoints to be of type Sequence')

        if external_controller is not None and not isinstance(external_controller, ExternalControllerInfo):
            raise Exception('Expected external_controller to be of type ExternalControllerInfo')

        if macaroon is not None and not isinstance(macaroon, Macaroon):
            raise Exception('Expected macaroon to be of type Macaroon')

        if offer_name is not None and not isinstance(offer_name, (bytes, str)):
            raise Exception('Expected offer_name to be of type str')

        if offer_url is not None and not isinstance(offer_url, (bytes, str)):
            raise Exception('Expected offer_url to be of type str')

        if offer_uuid is not None and not isinstance(offer_uuid, (bytes, str)):
            raise Exception('Expected offer_uuid to be of type str')

        if source_model_tag is not None and not isinstance(source_model_tag, (bytes, str)):
            raise Exception('Expected source_model_tag to be of type str')

        if spaces is not None and not isinstance(spaces, list):
            raise Exception('Expected spaces to be of type Sequence')

        if users is not None and not isinstance(users, list):
            raise Exception('Expected users to be of type Sequence')

        self.applicationofferdetails = ApplicationOfferDetails.from_json(applicationofferdetails) if applicationofferdetails else None
        self.application_alias = application_alias
        self.application_description = application_description
        self.bindings = bindings
        self.endpoints = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        self.external_controller = ExternalControllerInfo.from_json(external_controller) if external_controller else None
        self.macaroon = Macaroon.from_json(macaroon) if macaroon else None
        self.offer_name = offer_name
        self.offer_url = offer_url
        self.offer_uuid = offer_uuid
        self.source_model_tag = source_model_tag
        self.spaces = [RemoteSpace.from_json(o) for o in spaces or []]
        self.users = [OfferUserDetails.from_json(o) for o in users or []]
        self.unknown_fields = unknown_fields



class ConsumeApplicationArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~ConsumeApplicationArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [ConsumeApplicationArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class ConsumeApplicationResult(Type):
    _toSchema = {'error': 'error', 'local_name': 'local-name'}
    _toPy = {'error': 'error', 'local-name': 'local_name'}
    def __init__(self, error=None, local_name=None, **unknown_fields):
        '''
        error : Error
        local_name : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if local_name is not None and not isinstance(local_name, (bytes, str)):
            raise Exception('Expected local_name to be of type str')

        self.error = Error.from_json(error) if error else None
        self.local_name = local_name
        self.unknown_fields = unknown_fields



class ConsumeApplicationResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ConsumeApplicationResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ConsumeApplicationResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ConsumeOfferDetails(Type):
    _toSchema = {'external_controller': 'external-controller', 'macaroon': 'macaroon', 'offer': 'offer'}
    _toPy = {'external-controller': 'external_controller', 'macaroon': 'macaroon', 'offer': 'offer'}
    def __init__(self, external_controller=None, macaroon=None, offer=None, **unknown_fields):
        '''
        external_controller : ExternalControllerInfo
        macaroon : Macaroon
        offer : ApplicationOfferDetails
        '''
        if external_controller is not None and not isinstance(external_controller, ExternalControllerInfo):
            raise Exception('Expected external_controller to be of type ExternalControllerInfo')

        if macaroon is not None and not isinstance(macaroon, Macaroon):
            raise Exception('Expected macaroon to be of type Macaroon')

        if offer is not None and not isinstance(offer, ApplicationOfferDetails):
            raise Exception('Expected offer to be of type ApplicationOfferDetails')

        self.external_controller = ExternalControllerInfo.from_json(external_controller) if external_controller else None
        self.macaroon = Macaroon.from_json(macaroon) if macaroon else None
        self.offer = ApplicationOfferDetails.from_json(offer) if offer else None
        self.unknown_fields = unknown_fields



class ConsumeOfferDetailsResult(Type):
    _toSchema = {'consumeofferdetails': 'ConsumeOfferDetails', 'error': 'error', 'external_controller': 'external-controller', 'macaroon': 'macaroon', 'offer': 'offer'}
    _toPy = {'ConsumeOfferDetails': 'consumeofferdetails', 'error': 'error', 'external-controller': 'external_controller', 'macaroon': 'macaroon', 'offer': 'offer'}
    def __init__(self, consumeofferdetails=None, error=None, external_controller=None, macaroon=None, offer=None, **unknown_fields):
        '''
        consumeofferdetails : ConsumeOfferDetails
        error : Error
        external_controller : ExternalControllerInfo
        macaroon : Macaroon
        offer : ApplicationOfferDetails
        '''
        if consumeofferdetails is not None and not isinstance(consumeofferdetails, ConsumeOfferDetails):
            raise Exception('Expected consumeofferdetails to be of type ConsumeOfferDetails')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if external_controller is not None and not isinstance(external_controller, ExternalControllerInfo):
            raise Exception('Expected external_controller to be of type ExternalControllerInfo')

        if macaroon is not None and not isinstance(macaroon, Macaroon):
            raise Exception('Expected macaroon to be of type Macaroon')

        if offer is not None and not isinstance(offer, ApplicationOfferDetails):
            raise Exception('Expected offer to be of type ApplicationOfferDetails')

        self.consumeofferdetails = ConsumeOfferDetails.from_json(consumeofferdetails) if consumeofferdetails else None
        self.error = Error.from_json(error) if error else None
        self.external_controller = ExternalControllerInfo.from_json(external_controller) if external_controller else None
        self.macaroon = Macaroon.from_json(macaroon) if macaroon else None
        self.offer = ApplicationOfferDetails.from_json(offer) if offer else None
        self.unknown_fields = unknown_fields



class ConsumeOfferDetailsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ConsumeOfferDetailsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ConsumeOfferDetailsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ContainerConfig(Type):
    _toSchema = {'apt_mirror': 'apt-mirror', 'apt_proxy': 'apt-proxy', 'authorized_keys': 'authorized-keys', 'cloudinit_userdata': 'cloudinit-userdata', 'container_inherit_properties': 'container-inherit-properties', 'juju_proxy': 'juju-proxy', 'legacy_proxy': 'legacy-proxy', 'provider_type': 'provider-type', 'snap_proxy': 'snap-proxy', 'ssl_hostname_verification': 'ssl-hostname-verification', 'updatebehavior': 'UpdateBehavior'}
    _toPy = {'UpdateBehavior': 'updatebehavior', 'apt-mirror': 'apt_mirror', 'apt-proxy': 'apt_proxy', 'authorized-keys': 'authorized_keys', 'cloudinit-userdata': 'cloudinit_userdata', 'container-inherit-properties': 'container_inherit_properties', 'juju-proxy': 'juju_proxy', 'legacy-proxy': 'legacy_proxy', 'provider-type': 'provider_type', 'snap-proxy': 'snap_proxy', 'ssl-hostname-verification': 'ssl_hostname_verification'}
    def __init__(self, updatebehavior=None, apt_mirror=None, apt_proxy=None, authorized_keys=None, cloudinit_userdata=None, container_inherit_properties=None, juju_proxy=None, legacy_proxy=None, provider_type=None, snap_proxy=None, ssl_hostname_verification=None, **unknown_fields):
        '''
        updatebehavior : UpdateBehavior
        apt_mirror : str
        apt_proxy : Settings
        authorized_keys : str
        cloudinit_userdata : typing.Mapping[str, typing.Any]
        container_inherit_properties : str
        juju_proxy : Settings
        legacy_proxy : Settings
        provider_type : str
        snap_proxy : Settings
        ssl_hostname_verification : bool
        '''
        if updatebehavior is not None and not isinstance(updatebehavior, UpdateBehavior):
            raise Exception('Expected updatebehavior to be of type UpdateBehavior')

        if apt_mirror is not None and not isinstance(apt_mirror, (bytes, str)):
            raise Exception('Expected apt_mirror to be of type str')

        if apt_proxy is not None and not isinstance(apt_proxy, Settings):
            raise Exception('Expected apt_proxy to be of type Settings')

        if authorized_keys is not None and not isinstance(authorized_keys, (bytes, str)):
            raise Exception('Expected authorized_keys to be of type str')

        if cloudinit_userdata is not None and not isinstance(cloudinit_userdata, dict):
            raise Exception('Expected cloudinit_userdata to be of type Mapping')

        if container_inherit_properties is not None and not isinstance(container_inherit_properties, (bytes, str)):
            raise Exception('Expected container_inherit_properties to be of type str')

        if juju_proxy is not None and not isinstance(juju_proxy, Settings):
            raise Exception('Expected juju_proxy to be of type Settings')

        if legacy_proxy is not None and not isinstance(legacy_proxy, Settings):
            raise Exception('Expected legacy_proxy to be of type Settings')

        if provider_type is not None and not isinstance(provider_type, (bytes, str)):
            raise Exception('Expected provider_type to be of type str')

        if snap_proxy is not None and not isinstance(snap_proxy, Settings):
            raise Exception('Expected snap_proxy to be of type Settings')

        if ssl_hostname_verification is not None and not isinstance(ssl_hostname_verification, bool):
            raise Exception('Expected ssl_hostname_verification to be of type bool')

        self.updatebehavior = UpdateBehavior.from_json(updatebehavior) if updatebehavior else None
        self.apt_mirror = apt_mirror
        self.apt_proxy = Settings.from_json(apt_proxy) if apt_proxy else None
        self.authorized_keys = authorized_keys
        self.cloudinit_userdata = cloudinit_userdata
        self.container_inherit_properties = container_inherit_properties
        self.juju_proxy = Settings.from_json(juju_proxy) if juju_proxy else None
        self.legacy_proxy = Settings.from_json(legacy_proxy) if legacy_proxy else None
        self.provider_type = provider_type
        self.snap_proxy = Settings.from_json(snap_proxy) if snap_proxy else None
        self.ssl_hostname_verification = ssl_hostname_verification
        self.unknown_fields = unknown_fields



class ContainerLXDProfile(Type):
    _toSchema = {'name': 'name', 'profile': 'profile'}
    _toPy = {'name': 'name', 'profile': 'profile'}
    def __init__(self, name=None, profile=None, **unknown_fields):
        '''
        name : str
        profile : CharmLXDProfile
        '''
        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if profile is not None and not isinstance(profile, CharmLXDProfile):
            raise Exception('Expected profile to be of type CharmLXDProfile')

        self.name = name
        self.profile = CharmLXDProfile.from_json(profile) if profile else None
        self.unknown_fields = unknown_fields



class ContainerManagerConfig(Type):
    _toSchema = {'config': 'config'}
    _toPy = {'config': 'config'}
    def __init__(self, config=None, **unknown_fields):
        '''
        config : typing.Mapping[str, str]
        '''
        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        self.config = config
        self.unknown_fields = unknown_fields



class ContainerManagerConfigParams(Type):
    _toSchema = {'type_': 'type'}
    _toPy = {'type': 'type_'}
    def __init__(self, type_=None, **unknown_fields):
        '''
        type_ : str
        '''
        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.type_ = type_
        self.unknown_fields = unknown_fields



class ContainerProfileResult(Type):
    _toSchema = {'error': 'error', 'lxd_profiles': 'lxd-profiles'}
    _toPy = {'error': 'error', 'lxd-profiles': 'lxd_profiles'}
    def __init__(self, error=None, lxd_profiles=None, **unknown_fields):
        '''
        error : Error
        lxd_profiles : typing.Sequence[~ContainerLXDProfile]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if lxd_profiles is not None and not isinstance(lxd_profiles, list):
            raise Exception('Expected lxd_profiles to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.lxd_profiles = [ContainerLXDProfile.from_json(o) for o in lxd_profiles or []]
        self.unknown_fields = unknown_fields



class ContainerProfileResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ContainerProfileResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ContainerProfileResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ContainerTypeResult(Type):
    _toSchema = {'container_type': 'container-type', 'error': 'error'}
    _toPy = {'container-type': 'container_type', 'error': 'error'}
    def __init__(self, container_type=None, error=None, **unknown_fields):
        '''
        container_type : str
        error : Error
        '''
        if container_type is not None and not isinstance(container_type, (bytes, str)):
            raise Exception('Expected container_type to be of type str')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.container_type = container_type
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class ControllerAPIInfoResult(Type):
    _toSchema = {'addresses': 'addresses', 'cacert': 'cacert', 'error': 'error'}
    _toPy = {'addresses': 'addresses', 'cacert': 'cacert', 'error': 'error'}
    def __init__(self, addresses=None, cacert=None, error=None, **unknown_fields):
        '''
        addresses : typing.Sequence[str]
        cacert : str
        error : Error
        '''
        if addresses is not None and not isinstance(addresses, list):
            raise Exception('Expected addresses to be of type Sequence')

        if cacert is not None and not isinstance(cacert, (bytes, str)):
            raise Exception('Expected cacert to be of type str')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.addresses = addresses
        self.cacert = cacert
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class ControllerAPIInfoResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ControllerAPIInfoResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ControllerAPIInfoResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ControllerConfigResult(Type):
    _toSchema = {'config': 'config'}
    _toPy = {'config': 'config'}
    def __init__(self, config=None, **unknown_fields):
        '''
        config : typing.Mapping[str, typing.Any]
        '''
        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        self.config = config
        self.unknown_fields = unknown_fields



class ControllerConfigSet(Type):
    _toSchema = {'config': 'config'}
    _toPy = {'config': 'config'}
    def __init__(self, config=None, **unknown_fields):
        '''
        config : typing.Mapping[str, typing.Any]
        '''
        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        self.config = config
        self.unknown_fields = unknown_fields



class ControllerCredentialInfo(Type):
    _toSchema = {'content': 'content', 'models': 'models'}
    _toPy = {'content': 'content', 'models': 'models'}
    def __init__(self, content=None, models=None, **unknown_fields):
        '''
        content : CredentialContent
        models : typing.Sequence[~ModelAccess]
        '''
        if content is not None and not isinstance(content, CredentialContent):
            raise Exception('Expected content to be of type CredentialContent')

        if models is not None and not isinstance(models, list):
            raise Exception('Expected models to be of type Sequence')

        self.content = CredentialContent.from_json(content) if content else None
        self.models = [ModelAccess.from_json(o) for o in models or []]
        self.unknown_fields = unknown_fields



class ControllersChangeResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : ControllersChanges
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, ControllersChanges):
            raise Exception('Expected result to be of type ControllersChanges')

        self.error = Error.from_json(error) if error else None
        self.result = ControllersChanges.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class ControllersChangeResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ControllersChangeResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ControllersChangeResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ControllersChanges(Type):
    _toSchema = {'added': 'added', 'converted': 'converted', 'demoted': 'demoted', 'maintained': 'maintained', 'promoted': 'promoted', 'removed': 'removed'}
    _toPy = {'added': 'added', 'converted': 'converted', 'demoted': 'demoted', 'maintained': 'maintained', 'promoted': 'promoted', 'removed': 'removed'}
    def __init__(self, added=None, converted=None, demoted=None, maintained=None, promoted=None, removed=None, **unknown_fields):
        '''
        added : typing.Sequence[str]
        converted : typing.Sequence[str]
        demoted : typing.Sequence[str]
        maintained : typing.Sequence[str]
        promoted : typing.Sequence[str]
        removed : typing.Sequence[str]
        '''
        if added is not None and not isinstance(added, list):
            raise Exception('Expected added to be of type Sequence')

        if converted is not None and not isinstance(converted, list):
            raise Exception('Expected converted to be of type Sequence')

        if demoted is not None and not isinstance(demoted, list):
            raise Exception('Expected demoted to be of type Sequence')

        if maintained is not None and not isinstance(maintained, list):
            raise Exception('Expected maintained to be of type Sequence')

        if promoted is not None and not isinstance(promoted, list):
            raise Exception('Expected promoted to be of type Sequence')

        if removed is not None and not isinstance(removed, list):
            raise Exception('Expected removed to be of type Sequence')

        self.added = added
        self.converted = converted
        self.demoted = demoted
        self.maintained = maintained
        self.promoted = promoted
        self.removed = removed
        self.unknown_fields = unknown_fields



class ControllersSpec(Type):
    _toSchema = {'constraints': 'constraints', 'num_controllers': 'num-controllers', 'placement': 'placement', 'series': 'series'}
    _toPy = {'constraints': 'constraints', 'num-controllers': 'num_controllers', 'placement': 'placement', 'series': 'series'}
    def __init__(self, constraints=None, num_controllers=None, placement=None, series=None, **unknown_fields):
        '''
        constraints : Value
        num_controllers : int
        placement : typing.Sequence[str]
        series : str
        '''
        if constraints is not None and not isinstance(constraints, Value):
            raise Exception('Expected constraints to be of type Value')

        if num_controllers is not None and not isinstance(num_controllers, int):
            raise Exception('Expected num_controllers to be of type int')

        if placement is not None and not isinstance(placement, list):
            raise Exception('Expected placement to be of type Sequence')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        self.constraints = Value.from_json(constraints) if constraints else None
        self.num_controllers = num_controllers
        self.placement = placement
        self.series = series
        self.unknown_fields = unknown_fields



class ControllersSpecs(Type):
    _toSchema = {'specs': 'specs'}
    _toPy = {'specs': 'specs'}
    def __init__(self, specs=None, **unknown_fields):
        '''
        specs : typing.Sequence[~ControllersSpec]
        '''
        if specs is not None and not isinstance(specs, list):
            raise Exception('Expected specs to be of type Sequence')

        self.specs = [ControllersSpec.from_json(o) for o in specs or []]
        self.unknown_fields = unknown_fields



class CreateSpaceParams(Type):
    _toSchema = {'provider_id': 'provider-id', 'public': 'public', 'space_tag': 'space-tag', 'subnet_tags': 'subnet-tags'}
    _toPy = {'provider-id': 'provider_id', 'public': 'public', 'space-tag': 'space_tag', 'subnet-tags': 'subnet_tags'}
    def __init__(self, provider_id=None, public=None, space_tag=None, subnet_tags=None, **unknown_fields):
        '''
        provider_id : str
        public : bool
        space_tag : str
        subnet_tags : typing.Sequence[str]
        '''
        if provider_id is not None and not isinstance(provider_id, (bytes, str)):
            raise Exception('Expected provider_id to be of type str')

        if public is not None and not isinstance(public, bool):
            raise Exception('Expected public to be of type bool')

        if space_tag is not None and not isinstance(space_tag, (bytes, str)):
            raise Exception('Expected space_tag to be of type str')

        if subnet_tags is not None and not isinstance(subnet_tags, list):
            raise Exception('Expected subnet_tags to be of type Sequence')

        self.provider_id = provider_id
        self.public = public
        self.space_tag = space_tag
        self.subnet_tags = subnet_tags
        self.unknown_fields = unknown_fields



class CreateSpacesParams(Type):
    _toSchema = {'spaces': 'spaces'}
    _toPy = {'spaces': 'spaces'}
    def __init__(self, spaces=None, **unknown_fields):
        '''
        spaces : typing.Sequence[~CreateSpaceParams]
        '''
        if spaces is not None and not isinstance(spaces, list):
            raise Exception('Expected spaces to be of type Sequence')

        self.spaces = [CreateSpaceParams.from_json(o) for o in spaces or []]
        self.unknown_fields = unknown_fields



class CredentialContent(Type):
    _toSchema = {'attrs': 'attrs', 'auth_type': 'auth-type', 'cloud': 'cloud', 'name': 'name'}
    _toPy = {'attrs': 'attrs', 'auth-type': 'auth_type', 'cloud': 'cloud', 'name': 'name'}
    def __init__(self, attrs=None, auth_type=None, cloud=None, name=None, **unknown_fields):
        '''
        attrs : typing.Mapping[str, str]
        auth_type : str
        cloud : str
        name : str
        '''
        if attrs is not None and not isinstance(attrs, dict):
            raise Exception('Expected attrs to be of type Mapping')

        if auth_type is not None and not isinstance(auth_type, (bytes, str)):
            raise Exception('Expected auth_type to be of type str')

        if cloud is not None and not isinstance(cloud, (bytes, str)):
            raise Exception('Expected cloud to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        self.attrs = attrs
        self.auth_type = auth_type
        self.cloud = cloud
        self.name = name
        self.unknown_fields = unknown_fields



class CredentialContentResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : ControllerCredentialInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, ControllerCredentialInfo):
            raise Exception('Expected result to be of type ControllerCredentialInfo')

        self.error = Error.from_json(error) if error else None
        self.result = ControllerCredentialInfo.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class CredentialContentResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~CredentialContentResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [CredentialContentResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class Delta(Type):
    _toSchema = {'entity': 'entity', 'removed': 'removed'}
    _toPy = {'entity': 'entity', 'removed': 'removed'}
    def __init__(self, entity=None, removed=None, **unknown_fields):
        '''
        entity : typing.Mapping[str, typing.Any]
        removed : bool
        '''
        if entity is not None and not isinstance(entity, dict):
            raise Exception('Expected entity to be of type Mapping')

        if removed is not None and not isinstance(removed, bool):
            raise Exception('Expected removed to be of type bool')

        self.entity = entity
        self.removed = removed
        self.unknown_fields = unknown_fields



class DeployerConnectionValues(Type):
    _toSchema = {'api_addresses': 'api-addresses'}
    _toPy = {'api-addresses': 'api_addresses'}
    def __init__(self, api_addresses=None, **unknown_fields):
        '''
        api_addresses : typing.Sequence[str]
        '''
        if api_addresses is not None and not isinstance(api_addresses, list):
            raise Exception('Expected api_addresses to be of type Sequence')

        self.api_addresses = api_addresses
        self.unknown_fields = unknown_fields



class DestroyApplicationInfo(Type):
    _toSchema = {'destroyed_storage': 'destroyed-storage', 'destroyed_units': 'destroyed-units', 'detached_storage': 'detached-storage'}
    _toPy = {'destroyed-storage': 'destroyed_storage', 'destroyed-units': 'destroyed_units', 'detached-storage': 'detached_storage'}
    def __init__(self, destroyed_storage=None, destroyed_units=None, detached_storage=None, **unknown_fields):
        '''
        destroyed_storage : typing.Sequence[~Entity]
        destroyed_units : typing.Sequence[~Entity]
        detached_storage : typing.Sequence[~Entity]
        '''
        if destroyed_storage is not None and not isinstance(destroyed_storage, list):
            raise Exception('Expected destroyed_storage to be of type Sequence')

        if destroyed_units is not None and not isinstance(destroyed_units, list):
            raise Exception('Expected destroyed_units to be of type Sequence')

        if detached_storage is not None and not isinstance(detached_storage, list):
            raise Exception('Expected detached_storage to be of type Sequence')

        self.destroyed_storage = [Entity.from_json(o) for o in destroyed_storage or []]
        self.destroyed_units = [Entity.from_json(o) for o in destroyed_units or []]
        self.detached_storage = [Entity.from_json(o) for o in detached_storage or []]
        self.unknown_fields = unknown_fields



class DestroyApplicationOffers(Type):
    _toSchema = {'force': 'force', 'offer_urls': 'offer-urls'}
    _toPy = {'force': 'force', 'offer-urls': 'offer_urls'}
    def __init__(self, force=None, offer_urls=None, **unknown_fields):
        '''
        force : bool
        offer_urls : typing.Sequence[str]
        '''
        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if offer_urls is not None and not isinstance(offer_urls, list):
            raise Exception('Expected offer_urls to be of type Sequence')

        self.force = force
        self.offer_urls = offer_urls
        self.unknown_fields = unknown_fields



class DestroyApplicationParams(Type):
    _toSchema = {'application_tag': 'application-tag', 'destroy_storage': 'destroy-storage', 'force': 'force', 'max_wait': 'max-wait'}
    _toPy = {'application-tag': 'application_tag', 'destroy-storage': 'destroy_storage', 'force': 'force', 'max-wait': 'max_wait'}
    def __init__(self, application_tag=None, destroy_storage=None, force=None, max_wait=None, **unknown_fields):
        '''
        application_tag : str
        destroy_storage : bool
        force : bool
        max_wait : int
        '''
        if application_tag is not None and not isinstance(application_tag, (bytes, str)):
            raise Exception('Expected application_tag to be of type str')

        if destroy_storage is not None and not isinstance(destroy_storage, bool):
            raise Exception('Expected destroy_storage to be of type bool')

        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if max_wait is not None and not isinstance(max_wait, int):
            raise Exception('Expected max_wait to be of type int')

        self.application_tag = application_tag
        self.destroy_storage = destroy_storage
        self.force = force
        self.max_wait = max_wait
        self.unknown_fields = unknown_fields



class DestroyApplicationResult(Type):
    _toSchema = {'error': 'error', 'info': 'info'}
    _toPy = {'error': 'error', 'info': 'info'}
    def __init__(self, error=None, info=None, **unknown_fields):
        '''
        error : Error
        info : DestroyApplicationInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if info is not None and not isinstance(info, DestroyApplicationInfo):
            raise Exception('Expected info to be of type DestroyApplicationInfo')

        self.error = Error.from_json(error) if error else None
        self.info = DestroyApplicationInfo.from_json(info) if info else None
        self.unknown_fields = unknown_fields



class DestroyApplicationResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~DestroyApplicationResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [DestroyApplicationResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class DestroyApplicationUnits(Type):
    _toSchema = {'unit_names': 'unit-names'}
    _toPy = {'unit-names': 'unit_names'}
    def __init__(self, unit_names=None, **unknown_fields):
        '''
        unit_names : typing.Sequence[str]
        '''
        if unit_names is not None and not isinstance(unit_names, list):
            raise Exception('Expected unit_names to be of type Sequence')

        self.unit_names = unit_names
        self.unknown_fields = unknown_fields



class DestroyApplicationsParams(Type):
    _toSchema = {'applications': 'applications'}
    _toPy = {'applications': 'applications'}
    def __init__(self, applications=None, **unknown_fields):
        '''
        applications : typing.Sequence[~DestroyApplicationParams]
        '''
        if applications is not None and not isinstance(applications, list):
            raise Exception('Expected applications to be of type Sequence')

        self.applications = [DestroyApplicationParams.from_json(o) for o in applications or []]
        self.unknown_fields = unknown_fields



class DestroyConsumedApplicationParams(Type):
    _toSchema = {'application_tag': 'application-tag'}
    _toPy = {'application-tag': 'application_tag'}
    def __init__(self, application_tag=None, **unknown_fields):
        '''
        application_tag : str
        '''
        if application_tag is not None and not isinstance(application_tag, (bytes, str)):
            raise Exception('Expected application_tag to be of type str')

        self.application_tag = application_tag
        self.unknown_fields = unknown_fields



class DestroyConsumedApplicationsParams(Type):
    _toSchema = {'applications': 'applications'}
    _toPy = {'applications': 'applications'}
    def __init__(self, applications=None, **unknown_fields):
        '''
        applications : typing.Sequence[~DestroyConsumedApplicationParams]
        '''
        if applications is not None and not isinstance(applications, list):
            raise Exception('Expected applications to be of type Sequence')

        self.applications = [DestroyConsumedApplicationParams.from_json(o) for o in applications or []]
        self.unknown_fields = unknown_fields



class DestroyControllerArgs(Type):
    _toSchema = {'destroy_models': 'destroy-models', 'destroy_storage': 'destroy-storage'}
    _toPy = {'destroy-models': 'destroy_models', 'destroy-storage': 'destroy_storage'}
    def __init__(self, destroy_models=None, destroy_storage=None, **unknown_fields):
        '''
        destroy_models : bool
        destroy_storage : bool
        '''
        if destroy_models is not None and not isinstance(destroy_models, bool):
            raise Exception('Expected destroy_models to be of type bool')

        if destroy_storage is not None and not isinstance(destroy_storage, bool):
            raise Exception('Expected destroy_storage to be of type bool')

        self.destroy_models = destroy_models
        self.destroy_storage = destroy_storage
        self.unknown_fields = unknown_fields



class DestroyMachineInfo(Type):
    _toSchema = {'destroyed_storage': 'destroyed-storage', 'destroyed_units': 'destroyed-units', 'detached_storage': 'detached-storage'}
    _toPy = {'destroyed-storage': 'destroyed_storage', 'destroyed-units': 'destroyed_units', 'detached-storage': 'detached_storage'}
    def __init__(self, destroyed_storage=None, destroyed_units=None, detached_storage=None, **unknown_fields):
        '''
        destroyed_storage : typing.Sequence[~Entity]
        destroyed_units : typing.Sequence[~Entity]
        detached_storage : typing.Sequence[~Entity]
        '''
        if destroyed_storage is not None and not isinstance(destroyed_storage, list):
            raise Exception('Expected destroyed_storage to be of type Sequence')

        if destroyed_units is not None and not isinstance(destroyed_units, list):
            raise Exception('Expected destroyed_units to be of type Sequence')

        if detached_storage is not None and not isinstance(detached_storage, list):
            raise Exception('Expected detached_storage to be of type Sequence')

        self.destroyed_storage = [Entity.from_json(o) for o in destroyed_storage or []]
        self.destroyed_units = [Entity.from_json(o) for o in destroyed_units or []]
        self.detached_storage = [Entity.from_json(o) for o in detached_storage or []]
        self.unknown_fields = unknown_fields



class DestroyMachineResult(Type):
    _toSchema = {'error': 'error', 'info': 'info'}
    _toPy = {'error': 'error', 'info': 'info'}
    def __init__(self, error=None, info=None, **unknown_fields):
        '''
        error : Error
        info : DestroyMachineInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if info is not None and not isinstance(info, DestroyMachineInfo):
            raise Exception('Expected info to be of type DestroyMachineInfo')

        self.error = Error.from_json(error) if error else None
        self.info = DestroyMachineInfo.from_json(info) if info else None
        self.unknown_fields = unknown_fields



class DestroyMachineResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~DestroyMachineResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [DestroyMachineResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class DestroyMachines(Type):
    _toSchema = {'force': 'force', 'machine_names': 'machine-names'}
    _toPy = {'force': 'force', 'machine-names': 'machine_names'}
    def __init__(self, force=None, machine_names=None, **unknown_fields):
        '''
        force : bool
        machine_names : typing.Sequence[str]
        '''
        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if machine_names is not None and not isinstance(machine_names, list):
            raise Exception('Expected machine_names to be of type Sequence')

        self.force = force
        self.machine_names = machine_names
        self.unknown_fields = unknown_fields



class DestroyMachinesParams(Type):
    _toSchema = {'force': 'force', 'keep': 'keep', 'machine_tags': 'machine-tags', 'max_wait': 'max-wait'}
    _toPy = {'force': 'force', 'keep': 'keep', 'machine-tags': 'machine_tags', 'max-wait': 'max_wait'}
    def __init__(self, force=None, keep=None, machine_tags=None, max_wait=None, **unknown_fields):
        '''
        force : bool
        keep : bool
        machine_tags : typing.Sequence[str]
        max_wait : int
        '''
        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if keep is not None and not isinstance(keep, bool):
            raise Exception('Expected keep to be of type bool')

        if machine_tags is not None and not isinstance(machine_tags, list):
            raise Exception('Expected machine_tags to be of type Sequence')

        if max_wait is not None and not isinstance(max_wait, int):
            raise Exception('Expected max_wait to be of type int')

        self.force = force
        self.keep = keep
        self.machine_tags = machine_tags
        self.max_wait = max_wait
        self.unknown_fields = unknown_fields



class DestroyModelParams(Type):
    _toSchema = {'destroy_storage': 'destroy-storage', 'force': 'force', 'max_wait': 'max-wait', 'model_tag': 'model-tag'}
    _toPy = {'destroy-storage': 'destroy_storage', 'force': 'force', 'max-wait': 'max_wait', 'model-tag': 'model_tag'}
    def __init__(self, destroy_storage=None, force=None, max_wait=None, model_tag=None, **unknown_fields):
        '''
        destroy_storage : bool
        force : bool
        max_wait : int
        model_tag : str
        '''
        if destroy_storage is not None and not isinstance(destroy_storage, bool):
            raise Exception('Expected destroy_storage to be of type bool')

        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if max_wait is not None and not isinstance(max_wait, int):
            raise Exception('Expected max_wait to be of type int')

        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception('Expected model_tag to be of type str')

        self.destroy_storage = destroy_storage
        self.force = force
        self.max_wait = max_wait
        self.model_tag = model_tag
        self.unknown_fields = unknown_fields



class DestroyModelsParams(Type):
    _toSchema = {'models': 'models'}
    _toPy = {'models': 'models'}
    def __init__(self, models=None, **unknown_fields):
        '''
        models : typing.Sequence[~DestroyModelParams]
        '''
        if models is not None and not isinstance(models, list):
            raise Exception('Expected models to be of type Sequence')

        self.models = [DestroyModelParams.from_json(o) for o in models or []]
        self.unknown_fields = unknown_fields



class DestroyRelation(Type):
    _toSchema = {'endpoints': 'endpoints', 'force': 'force', 'max_wait': 'max-wait', 'relation_id': 'relation-id'}
    _toPy = {'endpoints': 'endpoints', 'force': 'force', 'max-wait': 'max_wait', 'relation-id': 'relation_id'}
    def __init__(self, endpoints=None, force=None, max_wait=None, relation_id=None, **unknown_fields):
        '''
        endpoints : typing.Sequence[str]
        force : bool
        max_wait : int
        relation_id : int
        '''
        if endpoints is not None and not isinstance(endpoints, list):
            raise Exception('Expected endpoints to be of type Sequence')

        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if max_wait is not None and not isinstance(max_wait, int):
            raise Exception('Expected max_wait to be of type int')

        if relation_id is not None and not isinstance(relation_id, int):
            raise Exception('Expected relation_id to be of type int')

        self.endpoints = endpoints
        self.force = force
        self.max_wait = max_wait
        self.relation_id = relation_id
        self.unknown_fields = unknown_fields



class DestroyUnitInfo(Type):
    _toSchema = {'destroyed_storage': 'destroyed-storage', 'detached_storage': 'detached-storage'}
    _toPy = {'destroyed-storage': 'destroyed_storage', 'detached-storage': 'detached_storage'}
    def __init__(self, destroyed_storage=None, detached_storage=None, **unknown_fields):
        '''
        destroyed_storage : typing.Sequence[~Entity]
        detached_storage : typing.Sequence[~Entity]
        '''
        if destroyed_storage is not None and not isinstance(destroyed_storage, list):
            raise Exception('Expected destroyed_storage to be of type Sequence')

        if detached_storage is not None and not isinstance(detached_storage, list):
            raise Exception('Expected detached_storage to be of type Sequence')

        self.destroyed_storage = [Entity.from_json(o) for o in destroyed_storage or []]
        self.detached_storage = [Entity.from_json(o) for o in detached_storage or []]
        self.unknown_fields = unknown_fields



class DestroyUnitParams(Type):
    _toSchema = {'destroy_storage': 'destroy-storage', 'force': 'force', 'max_wait': 'max-wait', 'unit_tag': 'unit-tag'}
    _toPy = {'destroy-storage': 'destroy_storage', 'force': 'force', 'max-wait': 'max_wait', 'unit-tag': 'unit_tag'}
    def __init__(self, destroy_storage=None, force=None, max_wait=None, unit_tag=None, **unknown_fields):
        '''
        destroy_storage : bool
        force : bool
        max_wait : int
        unit_tag : str
        '''
        if destroy_storage is not None and not isinstance(destroy_storage, bool):
            raise Exception('Expected destroy_storage to be of type bool')

        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if max_wait is not None and not isinstance(max_wait, int):
            raise Exception('Expected max_wait to be of type int')

        if unit_tag is not None and not isinstance(unit_tag, (bytes, str)):
            raise Exception('Expected unit_tag to be of type str')

        self.destroy_storage = destroy_storage
        self.force = force
        self.max_wait = max_wait
        self.unit_tag = unit_tag
        self.unknown_fields = unknown_fields



class DestroyUnitResult(Type):
    _toSchema = {'error': 'error', 'info': 'info'}
    _toPy = {'error': 'error', 'info': 'info'}
    def __init__(self, error=None, info=None, **unknown_fields):
        '''
        error : Error
        info : DestroyUnitInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if info is not None and not isinstance(info, DestroyUnitInfo):
            raise Exception('Expected info to be of type DestroyUnitInfo')

        self.error = Error.from_json(error) if error else None
        self.info = DestroyUnitInfo.from_json(info) if info else None
        self.unknown_fields = unknown_fields



class DestroyUnitResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~DestroyUnitResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [DestroyUnitResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class DestroyUnitsParams(Type):
    _toSchema = {'units': 'units'}
    _toPy = {'units': 'units'}
    def __init__(self, units=None, **unknown_fields):
        '''
        units : typing.Sequence[~DestroyUnitParams]
        '''
        if units is not None and not isinstance(units, list):
            raise Exception('Expected units to be of type Sequence')

        self.units = [DestroyUnitParams.from_json(o) for o in units or []]
        self.unknown_fields = unknown_fields



class DetailedStatus(Type):
    _toSchema = {'data': 'data', 'err': 'err', 'info': 'info', 'kind': 'kind', 'life': 'life', 'since': 'since', 'status': 'status', 'version': 'version'}
    _toPy = {'data': 'data', 'err': 'err', 'info': 'info', 'kind': 'kind', 'life': 'life', 'since': 'since', 'status': 'status', 'version': 'version'}
    def __init__(self, data=None, err=None, info=None, kind=None, life=None, since=None, status=None, version=None, **unknown_fields):
        '''
        data : typing.Mapping[str, typing.Any]
        err : Error
        info : str
        kind : str
        life : str
        since : str
        status : str
        version : str
        '''
        if data is not None and not isinstance(data, dict):
            raise Exception('Expected data to be of type Mapping')

        if err is not None and not isinstance(err, Error):
            raise Exception('Expected err to be of type Error')

        if info is not None and not isinstance(info, (bytes, str)):
            raise Exception('Expected info to be of type str')

        if kind is not None and not isinstance(kind, (bytes, str)):
            raise Exception('Expected kind to be of type str')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if since is not None and not isinstance(since, (bytes, str)):
            raise Exception('Expected since to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        if version is not None and not isinstance(version, (bytes, str)):
            raise Exception('Expected version to be of type str')

        self.data = data
        self.err = Error.from_json(err) if err else None
        self.info = info
        self.kind = kind
        self.life = life
        self.since = since
        self.status = status
        self.version = version
        self.unknown_fields = unknown_fields



class DeviceBridgeInfo(Type):
    _toSchema = {'bridge_name': 'bridge-name', 'host_device_name': 'host-device-name', 'mac_address': 'mac-address'}
    _toPy = {'bridge-name': 'bridge_name', 'host-device-name': 'host_device_name', 'mac-address': 'mac_address'}
    def __init__(self, bridge_name=None, host_device_name=None, mac_address=None, **unknown_fields):
        '''
        bridge_name : str
        host_device_name : str
        mac_address : str
        '''
        if bridge_name is not None and not isinstance(bridge_name, (bytes, str)):
            raise Exception('Expected bridge_name to be of type str')

        if host_device_name is not None and not isinstance(host_device_name, (bytes, str)):
            raise Exception('Expected host_device_name to be of type str')

        if mac_address is not None and not isinstance(mac_address, (bytes, str)):
            raise Exception('Expected mac_address to be of type str')

        self.bridge_name = bridge_name
        self.host_device_name = host_device_name
        self.mac_address = mac_address
        self.unknown_fields = unknown_fields



class DiscoverSpacesResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ProviderSpace]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ProviderSpace.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class DistributionGroupResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : typing.Sequence[str]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, list):
            raise Exception('Expected result to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.result = result
        self.unknown_fields = unknown_fields



class DistributionGroupResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~DistributionGroupResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [DistributionGroupResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class DumpModelRequest(Type):
    _toSchema = {'entities': 'entities', 'simplified': 'simplified'}
    _toPy = {'entities': 'entities', 'simplified': 'simplified'}
    def __init__(self, entities=None, simplified=None, **unknown_fields):
        '''
        entities : typing.Sequence[~Entity]
        simplified : bool
        '''
        if entities is not None and not isinstance(entities, list):
            raise Exception('Expected entities to be of type Sequence')

        if simplified is not None and not isinstance(simplified, bool):
            raise Exception('Expected simplified to be of type bool')

        self.entities = [Entity.from_json(o) for o in entities or []]
        self.simplified = simplified
        self.unknown_fields = unknown_fields



class Endpoint(Type):
    _toSchema = {'application_name': 'application-name', 'relation': 'relation'}
    _toPy = {'application-name': 'application_name', 'relation': 'relation'}
    def __init__(self, application_name=None, relation=None, **unknown_fields):
        '''
        application_name : str
        relation : CharmRelation
        '''
        if application_name is not None and not isinstance(application_name, (bytes, str)):
            raise Exception('Expected application_name to be of type str')

        if relation is not None and not isinstance(relation, CharmRelation):
            raise Exception('Expected relation to be of type CharmRelation')

        self.application_name = application_name
        self.relation = CharmRelation.from_json(relation) if relation else None
        self.unknown_fields = unknown_fields



class EndpointFilterAttributes(Type):
    _toSchema = {'interface': 'interface', 'name': 'name', 'role': 'role'}
    _toPy = {'interface': 'interface', 'name': 'name', 'role': 'role'}
    def __init__(self, interface=None, name=None, role=None, **unknown_fields):
        '''
        interface : str
        name : str
        role : str
        '''
        if interface is not None and not isinstance(interface, (bytes, str)):
            raise Exception('Expected interface to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if role is not None and not isinstance(role, (bytes, str)):
            raise Exception('Expected role to be of type str')

        self.interface = interface
        self.name = name
        self.role = role
        self.unknown_fields = unknown_fields



class EndpointStatus(Type):
    _toSchema = {'application': 'application', 'name': 'name', 'role': 'role', 'subordinate': 'subordinate'}
    _toPy = {'application': 'application', 'name': 'name', 'role': 'role', 'subordinate': 'subordinate'}
    def __init__(self, application=None, name=None, role=None, subordinate=None, **unknown_fields):
        '''
        application : str
        name : str
        role : str
        subordinate : bool
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if role is not None and not isinstance(role, (bytes, str)):
            raise Exception('Expected role to be of type str')

        if subordinate is not None and not isinstance(subordinate, bool):
            raise Exception('Expected subordinate to be of type bool')

        self.application = application
        self.name = name
        self.role = role
        self.subordinate = subordinate
        self.unknown_fields = unknown_fields



class Entities(Type):
    _toSchema = {'entities': 'entities'}
    _toPy = {'entities': 'entities'}
    def __init__(self, entities=None, **unknown_fields):
        '''
        entities : typing.Sequence[~Entity]
        '''
        if entities is not None and not isinstance(entities, list):
            raise Exception('Expected entities to be of type Sequence')

        self.entities = [Entity.from_json(o) for o in entities or []]
        self.unknown_fields = unknown_fields



class EntitiesCharmURL(Type):
    _toSchema = {'entities': 'entities'}
    _toPy = {'entities': 'entities'}
    def __init__(self, entities=None, **unknown_fields):
        '''
        entities : typing.Sequence[~EntityCharmURL]
        '''
        if entities is not None and not isinstance(entities, list):
            raise Exception('Expected entities to be of type Sequence')

        self.entities = [EntityCharmURL.from_json(o) for o in entities or []]
        self.unknown_fields = unknown_fields



class EntitiesPortRanges(Type):
    _toSchema = {'entities': 'entities'}
    _toPy = {'entities': 'entities'}
    def __init__(self, entities=None, **unknown_fields):
        '''
        entities : typing.Sequence[~EntityPortRange]
        '''
        if entities is not None and not isinstance(entities, list):
            raise Exception('Expected entities to be of type Sequence')

        self.entities = [EntityPortRange.from_json(o) for o in entities or []]
        self.unknown_fields = unknown_fields



class EntitiesResult(Type):
    _toSchema = {'entities': 'entities', 'error': 'error'}
    _toPy = {'entities': 'entities', 'error': 'error'}
    def __init__(self, entities=None, error=None, **unknown_fields):
        '''
        entities : typing.Sequence[~Entity]
        error : Error
        '''
        if entities is not None and not isinstance(entities, list):
            raise Exception('Expected entities to be of type Sequence')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.entities = [Entity.from_json(o) for o in entities or []]
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class EntitiesResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~EntitiesResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [EntitiesResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class EntitiesVersion(Type):
    _toSchema = {'agent_tools': 'agent-tools'}
    _toPy = {'agent-tools': 'agent_tools'}
    def __init__(self, agent_tools=None, **unknown_fields):
        '''
        agent_tools : typing.Sequence[~EntityVersion]
        '''
        if agent_tools is not None and not isinstance(agent_tools, list):
            raise Exception('Expected agent_tools to be of type Sequence')

        self.agent_tools = [EntityVersion.from_json(o) for o in agent_tools or []]
        self.unknown_fields = unknown_fields



class EntitiesWatchResult(Type):
    _toSchema = {'changes': 'changes', 'error': 'error', 'watcher_id': 'watcher-id'}
    _toPy = {'changes': 'changes', 'error': 'error', 'watcher-id': 'watcher_id'}
    def __init__(self, changes=None, error=None, watcher_id=None, **unknown_fields):
        '''
        changes : typing.Sequence[str]
        error : Error
        watcher_id : str
        '''
        if changes is not None and not isinstance(changes, list):
            raise Exception('Expected changes to be of type Sequence')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if watcher_id is not None and not isinstance(watcher_id, (bytes, str)):
            raise Exception('Expected watcher_id to be of type str')

        self.changes = changes
        self.error = Error.from_json(error) if error else None
        self.watcher_id = watcher_id
        self.unknown_fields = unknown_fields



class Entity(Type):
    _toSchema = {'tag': 'tag'}
    _toPy = {'tag': 'tag'}
    def __init__(self, tag=None, **unknown_fields):
        '''
        tag : str
        '''
        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.tag = tag
        self.unknown_fields = unknown_fields



class EntityAnnotations(Type):
    _toSchema = {'annotations': 'annotations', 'entity': 'entity'}
    _toPy = {'annotations': 'annotations', 'entity': 'entity'}
    def __init__(self, annotations=None, entity=None, **unknown_fields):
        '''
        annotations : typing.Mapping[str, str]
        entity : str
        '''
        if annotations is not None and not isinstance(annotations, dict):
            raise Exception('Expected annotations to be of type Mapping')

        if entity is not None and not isinstance(entity, (bytes, str)):
            raise Exception('Expected entity to be of type str')

        self.annotations = annotations
        self.entity = entity
        self.unknown_fields = unknown_fields



class EntityCharmURL(Type):
    _toSchema = {'charm_url': 'charm-url', 'tag': 'tag'}
    _toPy = {'charm-url': 'charm_url', 'tag': 'tag'}
    def __init__(self, charm_url=None, tag=None, **unknown_fields):
        '''
        charm_url : str
        tag : str
        '''
        if charm_url is not None and not isinstance(charm_url, (bytes, str)):
            raise Exception('Expected charm_url to be of type str')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.charm_url = charm_url
        self.tag = tag
        self.unknown_fields = unknown_fields



class EntityMacaroonArg(Type):
    _toSchema = {'macaroon': 'macaroon', 'tag': 'tag'}
    _toPy = {'macaroon': 'macaroon', 'tag': 'tag'}
    def __init__(self, macaroon=None, tag=None, **unknown_fields):
        '''
        macaroon : Macaroon
        tag : str
        '''
        if macaroon is not None and not isinstance(macaroon, Macaroon):
            raise Exception('Expected macaroon to be of type Macaroon')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.macaroon = Macaroon.from_json(macaroon) if macaroon else None
        self.tag = tag
        self.unknown_fields = unknown_fields



class EntityMacaroonArgs(Type):
    _toSchema = {'args': 'Args'}
    _toPy = {'Args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~EntityMacaroonArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [EntityMacaroonArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class EntityMetrics(Type):
    _toSchema = {'error': 'error', 'metrics': 'metrics'}
    _toPy = {'error': 'error', 'metrics': 'metrics'}
    def __init__(self, error=None, metrics=None, **unknown_fields):
        '''
        error : Error
        metrics : typing.Sequence[~MetricResult]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if metrics is not None and not isinstance(metrics, list):
            raise Exception('Expected metrics to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.metrics = [MetricResult.from_json(o) for o in metrics or []]
        self.unknown_fields = unknown_fields



class EntityPassword(Type):
    _toSchema = {'password': 'password', 'tag': 'tag'}
    _toPy = {'password': 'password', 'tag': 'tag'}
    def __init__(self, password=None, tag=None, **unknown_fields):
        '''
        password : str
        tag : str
        '''
        if password is not None and not isinstance(password, (bytes, str)):
            raise Exception('Expected password to be of type str')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.password = password
        self.tag = tag
        self.unknown_fields = unknown_fields



class EntityPasswords(Type):
    _toSchema = {'changes': 'changes'}
    _toPy = {'changes': 'changes'}
    def __init__(self, changes=None, **unknown_fields):
        '''
        changes : typing.Sequence[~EntityPassword]
        '''
        if changes is not None and not isinstance(changes, list):
            raise Exception('Expected changes to be of type Sequence')

        self.changes = [EntityPassword.from_json(o) for o in changes or []]
        self.unknown_fields = unknown_fields



class EntityPortRange(Type):
    _toSchema = {'from_port': 'from-port', 'protocol': 'protocol', 'tag': 'tag', 'to_port': 'to-port'}
    _toPy = {'from-port': 'from_port', 'protocol': 'protocol', 'tag': 'tag', 'to-port': 'to_port'}
    def __init__(self, from_port=None, protocol=None, tag=None, to_port=None, **unknown_fields):
        '''
        from_port : int
        protocol : str
        tag : str
        to_port : int
        '''
        if from_port is not None and not isinstance(from_port, int):
            raise Exception('Expected from_port to be of type int')

        if protocol is not None and not isinstance(protocol, (bytes, str)):
            raise Exception('Expected protocol to be of type str')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        if to_port is not None and not isinstance(to_port, int):
            raise Exception('Expected to_port to be of type int')

        self.from_port = from_port
        self.protocol = protocol
        self.tag = tag
        self.to_port = to_port
        self.unknown_fields = unknown_fields



class EntityStatus(Type):
    _toSchema = {'data': 'data', 'info': 'info', 'since': 'since', 'status': 'status'}
    _toPy = {'data': 'data', 'info': 'info', 'since': 'since', 'status': 'status'}
    def __init__(self, data=None, info=None, since=None, status=None, **unknown_fields):
        '''
        data : typing.Mapping[str, typing.Any]
        info : str
        since : str
        status : str
        '''
        if data is not None and not isinstance(data, dict):
            raise Exception('Expected data to be of type Mapping')

        if info is not None and not isinstance(info, (bytes, str)):
            raise Exception('Expected info to be of type str')

        if since is not None and not isinstance(since, (bytes, str)):
            raise Exception('Expected since to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        self.data = data
        self.info = info
        self.since = since
        self.status = status
        self.unknown_fields = unknown_fields



class EntityStatusArgs(Type):
    _toSchema = {'data': 'data', 'info': 'info', 'status': 'status', 'tag': 'tag'}
    _toPy = {'data': 'data', 'info': 'info', 'status': 'status', 'tag': 'tag'}
    def __init__(self, data=None, info=None, status=None, tag=None, **unknown_fields):
        '''
        data : typing.Mapping[str, typing.Any]
        info : str
        status : str
        tag : str
        '''
        if data is not None and not isinstance(data, dict):
            raise Exception('Expected data to be of type Mapping')

        if info is not None and not isinstance(info, (bytes, str)):
            raise Exception('Expected info to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.data = data
        self.info = info
        self.status = status
        self.tag = tag
        self.unknown_fields = unknown_fields



class EntityString(Type):
    _toSchema = {'tag': 'tag', 'value': 'value'}
    _toPy = {'tag': 'tag', 'value': 'value'}
    def __init__(self, tag=None, value=None, **unknown_fields):
        '''
        tag : str
        value : str
        '''
        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        if value is not None and not isinstance(value, (bytes, str)):
            raise Exception('Expected value to be of type str')

        self.tag = tag
        self.value = value
        self.unknown_fields = unknown_fields



class EntityVersion(Type):
    _toSchema = {'tag': 'tag', 'tools': 'tools'}
    _toPy = {'tag': 'tag', 'tools': 'tools'}
    def __init__(self, tag=None, tools=None, **unknown_fields):
        '''
        tag : str
        tools : Version
        '''
        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        if tools is not None and not isinstance(tools, Version):
            raise Exception('Expected tools to be of type Version')

        self.tag = tag
        self.tools = Version.from_json(tools) if tools else None
        self.unknown_fields = unknown_fields



class EntityWorkloadVersion(Type):
    _toSchema = {'tag': 'tag', 'workload_version': 'workload-version'}
    _toPy = {'tag': 'tag', 'workload-version': 'workload_version'}
    def __init__(self, tag=None, workload_version=None, **unknown_fields):
        '''
        tag : str
        workload_version : str
        '''
        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        if workload_version is not None and not isinstance(workload_version, (bytes, str)):
            raise Exception('Expected workload_version to be of type str')

        self.tag = tag
        self.workload_version = workload_version
        self.unknown_fields = unknown_fields



class EntityWorkloadVersions(Type):
    _toSchema = {'entities': 'entities'}
    _toPy = {'entities': 'entities'}
    def __init__(self, entities=None, **unknown_fields):
        '''
        entities : typing.Sequence[~EntityWorkloadVersion]
        '''
        if entities is not None and not isinstance(entities, list):
            raise Exception('Expected entities to be of type Sequence')

        self.entities = [EntityWorkloadVersion.from_json(o) for o in entities or []]
        self.unknown_fields = unknown_fields



class EnvListArgs(Type):
    _toSchema = {'patterns': 'patterns'}
    _toPy = {'patterns': 'patterns'}
    def __init__(self, patterns=None, **unknown_fields):
        '''
        patterns : typing.Sequence[str]
        '''
        if patterns is not None and not isinstance(patterns, list):
            raise Exception('Expected patterns to be of type Sequence')

        self.patterns = patterns
        self.unknown_fields = unknown_fields



class EnvListResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~Payload]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [Payload.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class Error(Type):
    _toSchema = {'code': 'code', 'info': 'info', 'message': 'message'}
    _toPy = {'code': 'code', 'info': 'info', 'message': 'message'}
    def __init__(self, code=None, info=None, message=None, **unknown_fields):
        '''
        code : str
        info : typing.Mapping[str, typing.Any]
        message : str
        '''
        if code is not None and not isinstance(code, (bytes, str)):
            raise Exception('Expected code to be of type str')

        if info is not None and not isinstance(info, dict):
            raise Exception('Expected info to be of type Mapping')

        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        self.code = code
        self.info = info
        self.message = message
        self.unknown_fields = unknown_fields



class ErrorInfo(Type):
    _toSchema = {'macaroon': 'macaroon', 'macaroon_path': 'macaroon-path'}
    _toPy = {'macaroon': 'macaroon', 'macaroon-path': 'macaroon_path'}
    def __init__(self, macaroon=None, macaroon_path=None, **unknown_fields):
        '''
        macaroon : Macaroon
        macaroon_path : str
        '''
        if macaroon is not None and not isinstance(macaroon, Macaroon):
            raise Exception('Expected macaroon to be of type Macaroon')

        if macaroon_path is not None and not isinstance(macaroon_path, (bytes, str)):
            raise Exception('Expected macaroon_path to be of type str')

        self.macaroon = Macaroon.from_json(macaroon) if macaroon else None
        self.macaroon_path = macaroon_path
        self.unknown_fields = unknown_fields



class ErrorResult(Type):
    _toSchema = {'error': 'error'}
    _toPy = {'error': 'error'}
    def __init__(self, error=None, **unknown_fields):
        '''
        error : Error
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class ErrorResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ErrorResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ErrorResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ExternalControllerInfo(Type):
    _toSchema = {'addrs': 'addrs', 'ca_cert': 'ca-cert', 'controller_alias': 'controller-alias', 'controller_tag': 'controller-tag'}
    _toPy = {'addrs': 'addrs', 'ca-cert': 'ca_cert', 'controller-alias': 'controller_alias', 'controller-tag': 'controller_tag'}
    def __init__(self, addrs=None, ca_cert=None, controller_alias=None, controller_tag=None, **unknown_fields):
        '''
        addrs : typing.Sequence[str]
        ca_cert : str
        controller_alias : str
        controller_tag : str
        '''
        if addrs is not None and not isinstance(addrs, list):
            raise Exception('Expected addrs to be of type Sequence')

        if ca_cert is not None and not isinstance(ca_cert, (bytes, str)):
            raise Exception('Expected ca_cert to be of type str')

        if controller_alias is not None and not isinstance(controller_alias, (bytes, str)):
            raise Exception('Expected controller_alias to be of type str')

        if controller_tag is not None and not isinstance(controller_tag, (bytes, str)):
            raise Exception('Expected controller_tag to be of type str')

        self.addrs = addrs
        self.ca_cert = ca_cert
        self.controller_alias = controller_alias
        self.controller_tag = controller_tag
        self.unknown_fields = unknown_fields



class ExternalControllerInfoResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : ExternalControllerInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, ExternalControllerInfo):
            raise Exception('Expected result to be of type ExternalControllerInfo')

        self.error = Error.from_json(error) if error else None
        self.result = ExternalControllerInfo.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class ExternalControllerInfoResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ExternalControllerInfoResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ExternalControllerInfoResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class FanConfigEntry(Type):
    _toSchema = {'overlay': 'overlay', 'underlay': 'underlay'}
    _toPy = {'overlay': 'overlay', 'underlay': 'underlay'}
    def __init__(self, overlay=None, underlay=None, **unknown_fields):
        '''
        overlay : str
        underlay : str
        '''
        if overlay is not None and not isinstance(overlay, (bytes, str)):
            raise Exception('Expected overlay to be of type str')

        if underlay is not None and not isinstance(underlay, (bytes, str)):
            raise Exception('Expected underlay to be of type str')

        self.overlay = overlay
        self.underlay = underlay
        self.unknown_fields = unknown_fields



class FanConfigResult(Type):
    _toSchema = {'fans': 'fans'}
    _toPy = {'fans': 'fans'}
    def __init__(self, fans=None, **unknown_fields):
        '''
        fans : typing.Sequence[~FanConfigEntry]
        '''
        if fans is not None and not isinstance(fans, list):
            raise Exception('Expected fans to be of type Sequence')

        self.fans = [FanConfigEntry.from_json(o) for o in fans or []]
        self.unknown_fields = unknown_fields



class Filesystem(Type):
    _toSchema = {'filesystem_tag': 'filesystem-tag', 'info': 'info', 'volume_tag': 'volume-tag'}
    _toPy = {'filesystem-tag': 'filesystem_tag', 'info': 'info', 'volume-tag': 'volume_tag'}
    def __init__(self, filesystem_tag=None, info=None, volume_tag=None, **unknown_fields):
        '''
        filesystem_tag : str
        info : FilesystemInfo
        volume_tag : str
        '''
        if filesystem_tag is not None and not isinstance(filesystem_tag, (bytes, str)):
            raise Exception('Expected filesystem_tag to be of type str')

        if info is not None and not isinstance(info, FilesystemInfo):
            raise Exception('Expected info to be of type FilesystemInfo')

        if volume_tag is not None and not isinstance(volume_tag, (bytes, str)):
            raise Exception('Expected volume_tag to be of type str')

        self.filesystem_tag = filesystem_tag
        self.info = FilesystemInfo.from_json(info) if info else None
        self.volume_tag = volume_tag
        self.unknown_fields = unknown_fields



class FilesystemAttachment(Type):
    _toSchema = {'filesystem_tag': 'filesystem-tag', 'info': 'info', 'machine_tag': 'machine-tag'}
    _toPy = {'filesystem-tag': 'filesystem_tag', 'info': 'info', 'machine-tag': 'machine_tag'}
    def __init__(self, filesystem_tag=None, info=None, machine_tag=None, **unknown_fields):
        '''
        filesystem_tag : str
        info : FilesystemAttachmentInfo
        machine_tag : str
        '''
        if filesystem_tag is not None and not isinstance(filesystem_tag, (bytes, str)):
            raise Exception('Expected filesystem_tag to be of type str')

        if info is not None and not isinstance(info, FilesystemAttachmentInfo):
            raise Exception('Expected info to be of type FilesystemAttachmentInfo')

        if machine_tag is not None and not isinstance(machine_tag, (bytes, str)):
            raise Exception('Expected machine_tag to be of type str')

        self.filesystem_tag = filesystem_tag
        self.info = FilesystemAttachmentInfo.from_json(info) if info else None
        self.machine_tag = machine_tag
        self.unknown_fields = unknown_fields



class FilesystemAttachmentDetails(Type):
    _toSchema = {'filesystemattachmentinfo': 'FilesystemAttachmentInfo', 'life': 'life', 'mount_point': 'mount-point', 'read_only': 'read-only'}
    _toPy = {'FilesystemAttachmentInfo': 'filesystemattachmentinfo', 'life': 'life', 'mount-point': 'mount_point', 'read-only': 'read_only'}
    def __init__(self, filesystemattachmentinfo=None, life=None, mount_point=None, read_only=None, **unknown_fields):
        '''
        filesystemattachmentinfo : FilesystemAttachmentInfo
        life : str
        mount_point : str
        read_only : bool
        '''
        if filesystemattachmentinfo is not None and not isinstance(filesystemattachmentinfo, FilesystemAttachmentInfo):
            raise Exception('Expected filesystemattachmentinfo to be of type FilesystemAttachmentInfo')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if mount_point is not None and not isinstance(mount_point, (bytes, str)):
            raise Exception('Expected mount_point to be of type str')

        if read_only is not None and not isinstance(read_only, bool):
            raise Exception('Expected read_only to be of type bool')

        self.filesystemattachmentinfo = FilesystemAttachmentInfo.from_json(filesystemattachmentinfo) if filesystemattachmentinfo else None
        self.life = life
        self.mount_point = mount_point
        self.read_only = read_only
        self.unknown_fields = unknown_fields



class FilesystemAttachmentInfo(Type):
    _toSchema = {'mount_point': 'mount-point', 'read_only': 'read-only'}
    _toPy = {'mount-point': 'mount_point', 'read-only': 'read_only'}
    def __init__(self, mount_point=None, read_only=None, **unknown_fields):
        '''
        mount_point : str
        read_only : bool
        '''
        if mount_point is not None and not isinstance(mount_point, (bytes, str)):
            raise Exception('Expected mount_point to be of type str')

        if read_only is not None and not isinstance(read_only, bool):
            raise Exception('Expected read_only to be of type bool')

        self.mount_point = mount_point
        self.read_only = read_only
        self.unknown_fields = unknown_fields



class FilesystemAttachmentParams(Type):
    _toSchema = {'filesystem_id': 'filesystem-id', 'filesystem_tag': 'filesystem-tag', 'instance_id': 'instance-id', 'machine_tag': 'machine-tag', 'mount_point': 'mount-point', 'provider': 'provider', 'read_only': 'read-only'}
    _toPy = {'filesystem-id': 'filesystem_id', 'filesystem-tag': 'filesystem_tag', 'instance-id': 'instance_id', 'machine-tag': 'machine_tag', 'mount-point': 'mount_point', 'provider': 'provider', 'read-only': 'read_only'}
    def __init__(self, filesystem_id=None, filesystem_tag=None, instance_id=None, machine_tag=None, mount_point=None, provider=None, read_only=None, **unknown_fields):
        '''
        filesystem_id : str
        filesystem_tag : str
        instance_id : str
        machine_tag : str
        mount_point : str
        provider : str
        read_only : bool
        '''
        if filesystem_id is not None and not isinstance(filesystem_id, (bytes, str)):
            raise Exception('Expected filesystem_id to be of type str')

        if filesystem_tag is not None and not isinstance(filesystem_tag, (bytes, str)):
            raise Exception('Expected filesystem_tag to be of type str')

        if instance_id is not None and not isinstance(instance_id, (bytes, str)):
            raise Exception('Expected instance_id to be of type str')

        if machine_tag is not None and not isinstance(machine_tag, (bytes, str)):
            raise Exception('Expected machine_tag to be of type str')

        if mount_point is not None and not isinstance(mount_point, (bytes, str)):
            raise Exception('Expected mount_point to be of type str')

        if provider is not None and not isinstance(provider, (bytes, str)):
            raise Exception('Expected provider to be of type str')

        if read_only is not None and not isinstance(read_only, bool):
            raise Exception('Expected read_only to be of type bool')

        self.filesystem_id = filesystem_id
        self.filesystem_tag = filesystem_tag
        self.instance_id = instance_id
        self.machine_tag = machine_tag
        self.mount_point = mount_point
        self.provider = provider
        self.read_only = read_only
        self.unknown_fields = unknown_fields



class FilesystemAttachmentParamsResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : FilesystemAttachmentParams
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, FilesystemAttachmentParams):
            raise Exception('Expected result to be of type FilesystemAttachmentParams')

        self.error = Error.from_json(error) if error else None
        self.result = FilesystemAttachmentParams.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class FilesystemAttachmentParamsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~FilesystemAttachmentParamsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [FilesystemAttachmentParamsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class FilesystemAttachmentResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : FilesystemAttachment
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, FilesystemAttachment):
            raise Exception('Expected result to be of type FilesystemAttachment')

        self.error = Error.from_json(error) if error else None
        self.result = FilesystemAttachment.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class FilesystemAttachmentResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~FilesystemAttachmentResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [FilesystemAttachmentResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class FilesystemAttachments(Type):
    _toSchema = {'filesystem_attachments': 'filesystem-attachments'}
    _toPy = {'filesystem-attachments': 'filesystem_attachments'}
    def __init__(self, filesystem_attachments=None, **unknown_fields):
        '''
        filesystem_attachments : typing.Sequence[~FilesystemAttachment]
        '''
        if filesystem_attachments is not None and not isinstance(filesystem_attachments, list):
            raise Exception('Expected filesystem_attachments to be of type Sequence')

        self.filesystem_attachments = [FilesystemAttachment.from_json(o) for o in filesystem_attachments or []]
        self.unknown_fields = unknown_fields



class FilesystemDetails(Type):
    _toSchema = {'filesystem_tag': 'filesystem-tag', 'info': 'info', 'life': 'life', 'machine_attachments': 'machine-attachments', 'status': 'status', 'storage': 'storage', 'unit_attachments': 'unit-attachments', 'volume_tag': 'volume-tag'}
    _toPy = {'filesystem-tag': 'filesystem_tag', 'info': 'info', 'life': 'life', 'machine-attachments': 'machine_attachments', 'status': 'status', 'storage': 'storage', 'unit-attachments': 'unit_attachments', 'volume-tag': 'volume_tag'}
    def __init__(self, filesystem_tag=None, info=None, life=None, machine_attachments=None, status=None, storage=None, unit_attachments=None, volume_tag=None, **unknown_fields):
        '''
        filesystem_tag : str
        info : FilesystemInfo
        life : str
        machine_attachments : typing.Mapping[str, ~FilesystemAttachmentDetails]
        status : EntityStatus
        storage : StorageDetails
        unit_attachments : typing.Mapping[str, ~FilesystemAttachmentDetails]
        volume_tag : str
        '''
        if filesystem_tag is not None and not isinstance(filesystem_tag, (bytes, str)):
            raise Exception('Expected filesystem_tag to be of type str')

        if info is not None and not isinstance(info, FilesystemInfo):
            raise Exception('Expected info to be of type FilesystemInfo')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if machine_attachments is not None and not isinstance(machine_attachments, dict):
            raise Exception('Expected machine_attachments to be of type Mapping')

        if status is not None and not isinstance(status, EntityStatus):
            raise Exception('Expected status to be of type EntityStatus')

        if storage is not None and not isinstance(storage, StorageDetails):
            raise Exception('Expected storage to be of type StorageDetails')

        if unit_attachments is not None and not isinstance(unit_attachments, dict):
            raise Exception('Expected unit_attachments to be of type Mapping')

        if volume_tag is not None and not isinstance(volume_tag, (bytes, str)):
            raise Exception('Expected volume_tag to be of type str')

        self.filesystem_tag = filesystem_tag
        self.info = FilesystemInfo.from_json(info) if info else None
        self.life = life
        self.machine_attachments = machine_attachments
        self.status = EntityStatus.from_json(status) if status else None
        self.storage = StorageDetails.from_json(storage) if storage else None
        self.unit_attachments = unit_attachments
        self.volume_tag = volume_tag
        self.unknown_fields = unknown_fields



class FilesystemDetailsListResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : typing.Sequence[~FilesystemDetails]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, list):
            raise Exception('Expected result to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.result = [FilesystemDetails.from_json(o) for o in result or []]
        self.unknown_fields = unknown_fields



class FilesystemDetailsListResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~FilesystemDetailsListResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [FilesystemDetailsListResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class FilesystemFilter(Type):
    _toSchema = {'machines': 'machines'}
    _toPy = {'machines': 'machines'}
    def __init__(self, machines=None, **unknown_fields):
        '''
        machines : typing.Sequence[str]
        '''
        if machines is not None and not isinstance(machines, list):
            raise Exception('Expected machines to be of type Sequence')

        self.machines = machines
        self.unknown_fields = unknown_fields



class FilesystemFilters(Type):
    _toSchema = {'filters': 'filters'}
    _toPy = {'filters': 'filters'}
    def __init__(self, filters=None, **unknown_fields):
        '''
        filters : typing.Sequence[~FilesystemFilter]
        '''
        if filters is not None and not isinstance(filters, list):
            raise Exception('Expected filters to be of type Sequence')

        self.filters = [FilesystemFilter.from_json(o) for o in filters or []]
        self.unknown_fields = unknown_fields



class FilesystemInfo(Type):
    _toSchema = {'filesystem_id': 'filesystem-id', 'pool': 'pool', 'size': 'size'}
    _toPy = {'filesystem-id': 'filesystem_id', 'pool': 'pool', 'size': 'size'}
    def __init__(self, filesystem_id=None, pool=None, size=None, **unknown_fields):
        '''
        filesystem_id : str
        pool : str
        size : int
        '''
        if filesystem_id is not None and not isinstance(filesystem_id, (bytes, str)):
            raise Exception('Expected filesystem_id to be of type str')

        if pool is not None and not isinstance(pool, (bytes, str)):
            raise Exception('Expected pool to be of type str')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        self.filesystem_id = filesystem_id
        self.pool = pool
        self.size = size
        self.unknown_fields = unknown_fields



class FilesystemParams(Type):
    _toSchema = {'attachment': 'attachment', 'attributes': 'attributes', 'filesystem_tag': 'filesystem-tag', 'provider': 'provider', 'size': 'size', 'tags': 'tags', 'volume_tag': 'volume-tag'}
    _toPy = {'attachment': 'attachment', 'attributes': 'attributes', 'filesystem-tag': 'filesystem_tag', 'provider': 'provider', 'size': 'size', 'tags': 'tags', 'volume-tag': 'volume_tag'}
    def __init__(self, attachment=None, attributes=None, filesystem_tag=None, provider=None, size=None, tags=None, volume_tag=None, **unknown_fields):
        '''
        attachment : FilesystemAttachmentParams
        attributes : typing.Mapping[str, typing.Any]
        filesystem_tag : str
        provider : str
        size : int
        tags : typing.Mapping[str, str]
        volume_tag : str
        '''
        if attachment is not None and not isinstance(attachment, FilesystemAttachmentParams):
            raise Exception('Expected attachment to be of type FilesystemAttachmentParams')

        if attributes is not None and not isinstance(attributes, dict):
            raise Exception('Expected attributes to be of type Mapping')

        if filesystem_tag is not None and not isinstance(filesystem_tag, (bytes, str)):
            raise Exception('Expected filesystem_tag to be of type str')

        if provider is not None and not isinstance(provider, (bytes, str)):
            raise Exception('Expected provider to be of type str')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if tags is not None and not isinstance(tags, dict):
            raise Exception('Expected tags to be of type Mapping')

        if volume_tag is not None and not isinstance(volume_tag, (bytes, str)):
            raise Exception('Expected volume_tag to be of type str')

        self.attachment = FilesystemAttachmentParams.from_json(attachment) if attachment else None
        self.attributes = attributes
        self.filesystem_tag = filesystem_tag
        self.provider = provider
        self.size = size
        self.tags = tags
        self.volume_tag = volume_tag
        self.unknown_fields = unknown_fields



class FilesystemParamsResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : FilesystemParams
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, FilesystemParams):
            raise Exception('Expected result to be of type FilesystemParams')

        self.error = Error.from_json(error) if error else None
        self.result = FilesystemParams.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class FilesystemParamsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~FilesystemParamsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [FilesystemParamsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class FilesystemResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : Filesystem
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, Filesystem):
            raise Exception('Expected result to be of type Filesystem')

        self.error = Error.from_json(error) if error else None
        self.result = Filesystem.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class FilesystemResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~FilesystemResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [FilesystemResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class Filesystems(Type):
    _toSchema = {'filesystems': 'filesystems'}
    _toPy = {'filesystems': 'filesystems'}
    def __init__(self, filesystems=None, **unknown_fields):
        '''
        filesystems : typing.Sequence[~Filesystem]
        '''
        if filesystems is not None and not isinstance(filesystems, list):
            raise Exception('Expected filesystems to be of type Sequence')

        self.filesystems = [Filesystem.from_json(o) for o in filesystems or []]
        self.unknown_fields = unknown_fields



class FindActionsByNames(Type):
    _toSchema = {'names': 'names'}
    _toPy = {'names': 'names'}
    def __init__(self, names=None, **unknown_fields):
        '''
        names : typing.Sequence[str]
        '''
        if names is not None and not isinstance(names, list):
            raise Exception('Expected names to be of type Sequence')

        self.names = names
        self.unknown_fields = unknown_fields



class FindTags(Type):
    _toSchema = {'prefixes': 'prefixes'}
    _toPy = {'prefixes': 'prefixes'}
    def __init__(self, prefixes=None, **unknown_fields):
        '''
        prefixes : typing.Sequence[str]
        '''
        if prefixes is not None and not isinstance(prefixes, list):
            raise Exception('Expected prefixes to be of type Sequence')

        self.prefixes = prefixes
        self.unknown_fields = unknown_fields



class FindTagsResults(Type):
    _toSchema = {'matches': 'matches'}
    _toPy = {'matches': 'matches'}
    def __init__(self, matches=None, **unknown_fields):
        '''
        matches : typing.Sequence[~Entity]
        '''
        if matches is not None and not isinstance(matches, list):
            raise Exception('Expected matches to be of type Sequence')

        self.matches = [Entity.from_json(o) for o in matches or []]
        self.unknown_fields = unknown_fields



class FindToolsParams(Type):
    _toSchema = {'agentstream': 'agentstream', 'arch': 'arch', 'major': 'major', 'minor': 'minor', 'number': 'number', 'series': 'series'}
    _toPy = {'agentstream': 'agentstream', 'arch': 'arch', 'major': 'major', 'minor': 'minor', 'number': 'number', 'series': 'series'}
    def __init__(self, agentstream=None, arch=None, major=None, minor=None, number=None, series=None, **unknown_fields):
        '''
        agentstream : str
        arch : str
        major : int
        minor : int
        number : Number
        series : str
        '''
        if agentstream is not None and not isinstance(agentstream, (bytes, str)):
            raise Exception('Expected agentstream to be of type str')

        if arch is not None and not isinstance(arch, (bytes, str)):
            raise Exception('Expected arch to be of type str')

        if major is not None and not isinstance(major, int):
            raise Exception('Expected major to be of type int')

        if minor is not None and not isinstance(minor, int):
            raise Exception('Expected minor to be of type int')

        if number is not None and not isinstance(number, Number):
            raise Exception('Expected number to be of type Number')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        self.agentstream = agentstream
        self.arch = arch
        self.major = major
        self.minor = minor
        self.number = Number.from_json(number) if number else None
        self.series = series
        self.unknown_fields = unknown_fields



class FindToolsResult(Type):
    _toSchema = {'error': 'error', 'list_': 'list'}
    _toPy = {'error': 'error', 'list': 'list_'}
    def __init__(self, error=None, list_=None, **unknown_fields):
        '''
        error : Error
        list_ : typing.Sequence[~Tools]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if list_ is not None and not isinstance(list_, list):
            raise Exception('Expected list_ to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.list_ = [Tools.from_json(o) for o in list_ or []]
        self.unknown_fields = unknown_fields



class FirewallRule(Type):
    _toSchema = {'known_service': 'known-service', 'whitelist_cidrs': 'whitelist-cidrs'}
    _toPy = {'known-service': 'known_service', 'whitelist-cidrs': 'whitelist_cidrs'}
    def __init__(self, known_service=None, whitelist_cidrs=None, **unknown_fields):
        '''
        known_service : str
        whitelist_cidrs : typing.Sequence[str]
        '''
        if known_service is not None and not isinstance(known_service, (bytes, str)):
            raise Exception('Expected known_service to be of type str')

        if whitelist_cidrs is not None and not isinstance(whitelist_cidrs, list):
            raise Exception('Expected whitelist_cidrs to be of type Sequence')

        self.known_service = known_service
        self.whitelist_cidrs = whitelist_cidrs
        self.unknown_fields = unknown_fields



class FirewallRuleArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~FirewallRule]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [FirewallRule.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class FullStatus(Type):
    _toSchema = {'applications': 'applications', 'branches': 'branches', 'controller_timestamp': 'controller-timestamp', 'machines': 'machines', 'model': 'model', 'offers': 'offers', 'relations': 'relations', 'remote_applications': 'remote-applications'}
    _toPy = {'applications': 'applications', 'branches': 'branches', 'controller-timestamp': 'controller_timestamp', 'machines': 'machines', 'model': 'model', 'offers': 'offers', 'relations': 'relations', 'remote-applications': 'remote_applications'}
    def __init__(self, applications=None, branches=None, controller_timestamp=None, machines=None, model=None, offers=None, relations=None, remote_applications=None, **unknown_fields):
        '''
        applications : typing.Mapping[str, ~ApplicationStatus]
        branches : typing.Mapping[str, ~BranchStatus]
        controller_timestamp : str
        machines : typing.Mapping[str, ~MachineStatus]
        model : ModelStatusInfo
        offers : typing.Mapping[str, ~ApplicationOfferStatus]
        relations : typing.Sequence[~RelationStatus]
        remote_applications : typing.Mapping[str, ~RemoteApplicationStatus]
        '''
        if applications is not None and not isinstance(applications, dict):
            raise Exception('Expected applications to be of type Mapping')

        if branches is not None and not isinstance(branches, dict):
            raise Exception('Expected branches to be of type Mapping')

        if controller_timestamp is not None and not isinstance(controller_timestamp, (bytes, str)):
            raise Exception('Expected controller_timestamp to be of type str')

        if machines is not None and not isinstance(machines, dict):
            raise Exception('Expected machines to be of type Mapping')

        if model is not None and not isinstance(model, ModelStatusInfo):
            raise Exception('Expected model to be of type ModelStatusInfo')

        if offers is not None and not isinstance(offers, dict):
            raise Exception('Expected offers to be of type Mapping')

        if relations is not None and not isinstance(relations, list):
            raise Exception('Expected relations to be of type Sequence')

        if remote_applications is not None and not isinstance(remote_applications, dict):
            raise Exception('Expected remote_applications to be of type Mapping')

        self.applications = applications
        self.branches = branches
        self.controller_timestamp = controller_timestamp
        self.machines = machines
        self.model = ModelStatusInfo.from_json(model) if model else None
        self.offers = offers
        self.relations = [RelationStatus.from_json(o) for o in relations or []]
        self.remote_applications = remote_applications
        self.unknown_fields = unknown_fields



class Generation(Type):
    _toSchema = {'applications': 'applications', 'branch': 'branch', 'created': 'created', 'created_by': 'created-by'}
    _toPy = {'applications': 'applications', 'branch': 'branch', 'created': 'created', 'created-by': 'created_by'}
    def __init__(self, applications=None, branch=None, created=None, created_by=None, **unknown_fields):
        '''
        applications : typing.Sequence[~GenerationApplication]
        branch : str
        created : int
        created_by : str
        '''
        if applications is not None and not isinstance(applications, list):
            raise Exception('Expected applications to be of type Sequence')

        if branch is not None and not isinstance(branch, (bytes, str)):
            raise Exception('Expected branch to be of type str')

        if created is not None and not isinstance(created, int):
            raise Exception('Expected created to be of type int')

        if created_by is not None and not isinstance(created_by, (bytes, str)):
            raise Exception('Expected created_by to be of type str')

        self.applications = [GenerationApplication.from_json(o) for o in applications or []]
        self.branch = branch
        self.created = created
        self.created_by = created_by
        self.unknown_fields = unknown_fields



class GenerationApplication(Type):
    _toSchema = {'application': 'application', 'config': 'config', 'pending': 'pending', 'progress': 'progress', 'tracking': 'tracking'}
    _toPy = {'application': 'application', 'config': 'config', 'pending': 'pending', 'progress': 'progress', 'tracking': 'tracking'}
    def __init__(self, application=None, config=None, pending=None, progress=None, tracking=None, **unknown_fields):
        '''
        application : str
        config : typing.Mapping[str, typing.Any]
        pending : typing.Sequence[str]
        progress : str
        tracking : typing.Sequence[str]
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        if pending is not None and not isinstance(pending, list):
            raise Exception('Expected pending to be of type Sequence')

        if progress is not None and not isinstance(progress, (bytes, str)):
            raise Exception('Expected progress to be of type str')

        if tracking is not None and not isinstance(tracking, list):
            raise Exception('Expected tracking to be of type Sequence')

        self.application = application
        self.config = config
        self.pending = pending
        self.progress = progress
        self.tracking = tracking
        self.unknown_fields = unknown_fields



class GenerationResults(Type):
    _toSchema = {'error': 'error', 'generations': 'generations'}
    _toPy = {'error': 'error', 'generations': 'generations'}
    def __init__(self, error=None, generations=None, **unknown_fields):
        '''
        error : Error
        generations : typing.Sequence[~Generation]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if generations is not None and not isinstance(generations, list):
            raise Exception('Expected generations to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.generations = [Generation.from_json(o) for o in generations or []]
        self.unknown_fields = unknown_fields



class GetApplicationConstraints(Type):
    _toSchema = {'application': 'application'}
    _toPy = {'application': 'application'}
    def __init__(self, application=None, **unknown_fields):
        '''
        application : str
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        self.application = application
        self.unknown_fields = unknown_fields



class GetConstraintsResults(Type):
    _toSchema = {'constraints': 'constraints'}
    _toPy = {'constraints': 'constraints'}
    def __init__(self, constraints=None, **unknown_fields):
        '''
        constraints : Value
        '''
        if constraints is not None and not isinstance(constraints, Value):
            raise Exception('Expected constraints to be of type Value')

        self.constraints = Value.from_json(constraints) if constraints else None
        self.unknown_fields = unknown_fields



class GetLeadershipSettingsBulkResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~GetLeadershipSettingsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [GetLeadershipSettingsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class GetLeadershipSettingsResult(Type):
    _toSchema = {'error': 'error', 'settings': 'settings'}
    _toPy = {'error': 'error', 'settings': 'settings'}
    def __init__(self, error=None, settings=None, **unknown_fields):
        '''
        error : Error
        settings : typing.Mapping[str, str]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if settings is not None and not isinstance(settings, dict):
            raise Exception('Expected settings to be of type Mapping')

        self.error = Error.from_json(error) if error else None
        self.settings = settings
        self.unknown_fields = unknown_fields



class GetTokenArg(Type):
    _toSchema = {'tag': 'tag'}
    _toPy = {'tag': 'tag'}
    def __init__(self, tag=None, **unknown_fields):
        '''
        tag : str
        '''
        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.tag = tag
        self.unknown_fields = unknown_fields



class GetTokenArgs(Type):
    _toSchema = {'args': 'Args'}
    _toPy = {'Args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~GetTokenArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [GetTokenArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class GoalState(Type):
    _toSchema = {'relations': 'relations', 'units': 'units'}
    _toPy = {'relations': 'relations', 'units': 'units'}
    def __init__(self, relations=None, units=None, **unknown_fields):
        '''
        relations : typing.Mapping[str, typing.Any]
        units : typing.Mapping[str, ~GoalStateStatus]
        '''
        if relations is not None and not isinstance(relations, dict):
            raise Exception('Expected relations to be of type Mapping')

        if units is not None and not isinstance(units, dict):
            raise Exception('Expected units to be of type Mapping')

        self.relations = relations
        self.units = units
        self.unknown_fields = unknown_fields



class GoalStateResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : GoalState
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, GoalState):
            raise Exception('Expected result to be of type GoalState')

        self.error = Error.from_json(error) if error else None
        self.result = GoalState.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class GoalStateResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~GoalStateResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [GoalStateResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class GoalStateStatus(Type):
    _toSchema = {'since': 'since', 'status': 'status'}
    _toPy = {'since': 'since', 'status': 'status'}
    def __init__(self, since=None, status=None, **unknown_fields):
        '''
        since : str
        status : str
        '''
        if since is not None and not isinstance(since, (bytes, str)):
            raise Exception('Expected since to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        self.since = since
        self.status = status
        self.unknown_fields = unknown_fields



class HAMember(Type):
    _toSchema = {'public_address': 'public-address', 'series': 'series', 'tag': 'tag'}
    _toPy = {'public-address': 'public_address', 'series': 'series', 'tag': 'tag'}
    def __init__(self, public_address=None, series=None, tag=None, **unknown_fields):
        '''
        public_address : Address
        series : str
        tag : str
        '''
        if public_address is not None and not isinstance(public_address, Address):
            raise Exception('Expected public_address to be of type Address')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.public_address = Address.from_json(public_address) if public_address else None
        self.series = series
        self.tag = tag
        self.unknown_fields = unknown_fields



class HardwareCharacteristics(Type):
    _toSchema = {'arch': 'arch', 'availability_zone': 'availability-zone', 'cpu_cores': 'cpu-cores', 'cpu_power': 'cpu-power', 'mem': 'mem', 'root_disk': 'root-disk', 'root_disk_source': 'root-disk-source', 'tags': 'tags'}
    _toPy = {'arch': 'arch', 'availability-zone': 'availability_zone', 'cpu-cores': 'cpu_cores', 'cpu-power': 'cpu_power', 'mem': 'mem', 'root-disk': 'root_disk', 'root-disk-source': 'root_disk_source', 'tags': 'tags'}
    def __init__(self, arch=None, availability_zone=None, cpu_cores=None, cpu_power=None, mem=None, root_disk=None, root_disk_source=None, tags=None, **unknown_fields):
        '''
        arch : str
        availability_zone : str
        cpu_cores : int
        cpu_power : int
        mem : int
        root_disk : int
        root_disk_source : str
        tags : typing.Sequence[str]
        '''
        if arch is not None and not isinstance(arch, (bytes, str)):
            raise Exception('Expected arch to be of type str')

        if availability_zone is not None and not isinstance(availability_zone, (bytes, str)):
            raise Exception('Expected availability_zone to be of type str')

        if cpu_cores is not None and not isinstance(cpu_cores, int):
            raise Exception('Expected cpu_cores to be of type int')

        if cpu_power is not None and not isinstance(cpu_power, int):
            raise Exception('Expected cpu_power to be of type int')

        if mem is not None and not isinstance(mem, int):
            raise Exception('Expected mem to be of type int')

        if root_disk is not None and not isinstance(root_disk, int):
            raise Exception('Expected root_disk to be of type int')

        if root_disk_source is not None and not isinstance(root_disk_source, (bytes, str)):
            raise Exception('Expected root_disk_source to be of type str')

        if tags is not None and not isinstance(tags, list):
            raise Exception('Expected tags to be of type Sequence')

        self.arch = arch
        self.availability_zone = availability_zone
        self.cpu_cores = cpu_cores
        self.cpu_power = cpu_power
        self.mem = mem
        self.root_disk = root_disk
        self.root_disk_source = root_disk_source
        self.tags = tags
        self.unknown_fields = unknown_fields



class History(Type):
    _toSchema = {'error': 'error', 'statuses': 'statuses'}
    _toPy = {'error': 'error', 'statuses': 'statuses'}
    def __init__(self, error=None, statuses=None, **unknown_fields):
        '''
        error : Error
        statuses : typing.Sequence[~DetailedStatus]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if statuses is not None and not isinstance(statuses, list):
            raise Exception('Expected statuses to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.statuses = [DetailedStatus.from_json(o) for o in statuses or []]
        self.unknown_fields = unknown_fields



class HostNetworkChange(Type):
    _toSchema = {'error': 'error', 'new_bridges': 'new-bridges', 'reconfigure_delay': 'reconfigure-delay'}
    _toPy = {'error': 'error', 'new-bridges': 'new_bridges', 'reconfigure-delay': 'reconfigure_delay'}
    def __init__(self, error=None, new_bridges=None, reconfigure_delay=None, **unknown_fields):
        '''
        error : Error
        new_bridges : typing.Sequence[~DeviceBridgeInfo]
        reconfigure_delay : int
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if new_bridges is not None and not isinstance(new_bridges, list):
            raise Exception('Expected new_bridges to be of type Sequence')

        if reconfigure_delay is not None and not isinstance(reconfigure_delay, int):
            raise Exception('Expected reconfigure_delay to be of type int')

        self.error = Error.from_json(error) if error else None
        self.new_bridges = [DeviceBridgeInfo.from_json(o) for o in new_bridges or []]
        self.reconfigure_delay = reconfigure_delay
        self.unknown_fields = unknown_fields



class HostNetworkChangeResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~HostNetworkChange]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [HostNetworkChange.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class HostPort(Type):
    _toSchema = {'address': 'Address', 'port': 'port', 'scope': 'scope', 'space_id': 'space-id', 'space_name': 'space-name', 'type_': 'type', 'value': 'value'}
    _toPy = {'Address': 'address', 'port': 'port', 'scope': 'scope', 'space-id': 'space_id', 'space-name': 'space_name', 'type': 'type_', 'value': 'value'}
    def __init__(self, address=None, port=None, scope=None, space_id=None, space_name=None, type_=None, value=None, **unknown_fields):
        '''
        address : Address
        port : int
        scope : str
        space_id : str
        space_name : str
        type_ : str
        value : str
        '''
        if address is not None and not isinstance(address, Address):
            raise Exception('Expected address to be of type Address')

        if port is not None and not isinstance(port, int):
            raise Exception('Expected port to be of type int')

        if scope is not None and not isinstance(scope, (bytes, str)):
            raise Exception('Expected scope to be of type str')

        if space_id is not None and not isinstance(space_id, (bytes, str)):
            raise Exception('Expected space_id to be of type str')

        if space_name is not None and not isinstance(space_name, (bytes, str)):
            raise Exception('Expected space_name to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        if value is not None and not isinstance(value, (bytes, str)):
            raise Exception('Expected value to be of type str')

        self.address = Address.from_json(address) if address else None
        self.port = port
        self.scope = scope
        self.space_id = space_id
        self.space_name = space_name
        self.type_ = type_
        self.value = value
        self.unknown_fields = unknown_fields



class HostedModelConfig(Type):
    _toSchema = {'cloud_spec': 'cloud-spec', 'config': 'config', 'error': 'error', 'name': 'name', 'owner': 'owner'}
    _toPy = {'cloud-spec': 'cloud_spec', 'config': 'config', 'error': 'error', 'name': 'name', 'owner': 'owner'}
    def __init__(self, cloud_spec=None, config=None, error=None, name=None, owner=None, **unknown_fields):
        '''
        cloud_spec : CloudSpec
        config : typing.Mapping[str, typing.Any]
        error : Error
        name : str
        owner : str
        '''
        if cloud_spec is not None and not isinstance(cloud_spec, CloudSpec):
            raise Exception('Expected cloud_spec to be of type CloudSpec')

        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if owner is not None and not isinstance(owner, (bytes, str)):
            raise Exception('Expected owner to be of type str')

        self.cloud_spec = CloudSpec.from_json(cloud_spec) if cloud_spec else None
        self.config = config
        self.error = Error.from_json(error) if error else None
        self.name = name
        self.owner = owner
        self.unknown_fields = unknown_fields



class HostedModelConfigsResults(Type):
    _toSchema = {'models': 'models'}
    _toPy = {'models': 'models'}
    def __init__(self, models=None, **unknown_fields):
        '''
        models : typing.Sequence[~HostedModelConfig]
        '''
        if models is not None and not isinstance(models, list):
            raise Exception('Expected models to be of type Sequence')

        self.models = [HostedModelConfig.from_json(o) for o in models or []]
        self.unknown_fields = unknown_fields



class ImageFilterParams(Type):
    _toSchema = {'images': 'images'}
    _toPy = {'images': 'images'}
    def __init__(self, images=None, **unknown_fields):
        '''
        images : typing.Sequence[~ImageSpec]
        '''
        if images is not None and not isinstance(images, list):
            raise Exception('Expected images to be of type Sequence')

        self.images = [ImageSpec.from_json(o) for o in images or []]
        self.unknown_fields = unknown_fields



class ImageMetadata(Type):
    _toSchema = {'arch': 'arch', 'created': 'created', 'kind': 'kind', 'series': 'series', 'url': 'url'}
    _toPy = {'arch': 'arch', 'created': 'created', 'kind': 'kind', 'series': 'series', 'url': 'url'}
    def __init__(self, arch=None, created=None, kind=None, series=None, url=None, **unknown_fields):
        '''
        arch : str
        created : str
        kind : str
        series : str
        url : str
        '''
        if arch is not None and not isinstance(arch, (bytes, str)):
            raise Exception('Expected arch to be of type str')

        if created is not None and not isinstance(created, (bytes, str)):
            raise Exception('Expected created to be of type str')

        if kind is not None and not isinstance(kind, (bytes, str)):
            raise Exception('Expected kind to be of type str')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        if url is not None and not isinstance(url, (bytes, str)):
            raise Exception('Expected url to be of type str')

        self.arch = arch
        self.created = created
        self.kind = kind
        self.series = series
        self.url = url
        self.unknown_fields = unknown_fields



class ImageMetadataFilter(Type):
    _toSchema = {'arches': 'arches', 'region': 'region', 'root_storage_type': 'root-storage-type', 'series': 'series', 'stream': 'stream', 'virt_type': 'virt-type'}
    _toPy = {'arches': 'arches', 'region': 'region', 'root-storage-type': 'root_storage_type', 'series': 'series', 'stream': 'stream', 'virt-type': 'virt_type'}
    def __init__(self, arches=None, region=None, root_storage_type=None, series=None, stream=None, virt_type=None, **unknown_fields):
        '''
        arches : typing.Sequence[str]
        region : str
        root_storage_type : str
        series : typing.Sequence[str]
        stream : str
        virt_type : str
        '''
        if arches is not None and not isinstance(arches, list):
            raise Exception('Expected arches to be of type Sequence')

        if region is not None and not isinstance(region, (bytes, str)):
            raise Exception('Expected region to be of type str')

        if root_storage_type is not None and not isinstance(root_storage_type, (bytes, str)):
            raise Exception('Expected root_storage_type to be of type str')

        if series is not None and not isinstance(series, list):
            raise Exception('Expected series to be of type Sequence')

        if stream is not None and not isinstance(stream, (bytes, str)):
            raise Exception('Expected stream to be of type str')

        if virt_type is not None and not isinstance(virt_type, (bytes, str)):
            raise Exception('Expected virt_type to be of type str')

        self.arches = arches
        self.region = region
        self.root_storage_type = root_storage_type
        self.series = series
        self.stream = stream
        self.virt_type = virt_type
        self.unknown_fields = unknown_fields



class ImageSpec(Type):
    _toSchema = {'arch': 'arch', 'kind': 'kind', 'series': 'series'}
    _toPy = {'arch': 'arch', 'kind': 'kind', 'series': 'series'}
    def __init__(self, arch=None, kind=None, series=None, **unknown_fields):
        '''
        arch : str
        kind : str
        series : str
        '''
        if arch is not None and not isinstance(arch, (bytes, str)):
            raise Exception('Expected arch to be of type str')

        if kind is not None and not isinstance(kind, (bytes, str)):
            raise Exception('Expected kind to be of type str')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        self.arch = arch
        self.kind = kind
        self.series = series
        self.unknown_fields = unknown_fields



class ImportStorageDetails(Type):
    _toSchema = {'storage_tag': 'storage-tag'}
    _toPy = {'storage-tag': 'storage_tag'}
    def __init__(self, storage_tag=None, **unknown_fields):
        '''
        storage_tag : str
        '''
        if storage_tag is not None and not isinstance(storage_tag, (bytes, str)):
            raise Exception('Expected storage_tag to be of type str')

        self.storage_tag = storage_tag
        self.unknown_fields = unknown_fields



class ImportStorageParams(Type):
    _toSchema = {'kind': 'kind', 'pool': 'pool', 'provider_id': 'provider-id', 'storage_name': 'storage-name'}
    _toPy = {'kind': 'kind', 'pool': 'pool', 'provider-id': 'provider_id', 'storage-name': 'storage_name'}
    def __init__(self, kind=None, pool=None, provider_id=None, storage_name=None, **unknown_fields):
        '''
        kind : int
        pool : str
        provider_id : str
        storage_name : str
        '''
        if kind is not None and not isinstance(kind, int):
            raise Exception('Expected kind to be of type int')

        if pool is not None and not isinstance(pool, (bytes, str)):
            raise Exception('Expected pool to be of type str')

        if provider_id is not None and not isinstance(provider_id, (bytes, str)):
            raise Exception('Expected provider_id to be of type str')

        if storage_name is not None and not isinstance(storage_name, (bytes, str)):
            raise Exception('Expected storage_name to be of type str')

        self.kind = kind
        self.pool = pool
        self.provider_id = provider_id
        self.storage_name = storage_name
        self.unknown_fields = unknown_fields



class ImportStorageResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : ImportStorageDetails
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, ImportStorageDetails):
            raise Exception('Expected result to be of type ImportStorageDetails')

        self.error = Error.from_json(error) if error else None
        self.result = ImportStorageDetails.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class ImportStorageResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ImportStorageResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ImportStorageResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class IngressNetworksChangeEvent(Type):
    _toSchema = {'application_token': 'application-token', 'ingress_required': 'ingress-required', 'macaroons': 'macaroons', 'networks': 'networks', 'relation_token': 'relation-token'}
    _toPy = {'application-token': 'application_token', 'ingress-required': 'ingress_required', 'macaroons': 'macaroons', 'networks': 'networks', 'relation-token': 'relation_token'}
    def __init__(self, application_token=None, ingress_required=None, macaroons=None, networks=None, relation_token=None, **unknown_fields):
        '''
        application_token : str
        ingress_required : bool
        macaroons : typing.Sequence[~Macaroon]
        networks : typing.Sequence[str]
        relation_token : str
        '''
        if application_token is not None and not isinstance(application_token, (bytes, str)):
            raise Exception('Expected application_token to be of type str')

        if ingress_required is not None and not isinstance(ingress_required, bool):
            raise Exception('Expected ingress_required to be of type bool')

        if macaroons is not None and not isinstance(macaroons, list):
            raise Exception('Expected macaroons to be of type Sequence')

        if networks is not None and not isinstance(networks, list):
            raise Exception('Expected networks to be of type Sequence')

        if relation_token is not None and not isinstance(relation_token, (bytes, str)):
            raise Exception('Expected relation_token to be of type str')

        self.application_token = application_token
        self.ingress_required = ingress_required
        self.macaroons = [Macaroon.from_json(o) for o in macaroons or []]
        self.networks = networks
        self.relation_token = relation_token
        self.unknown_fields = unknown_fields



class IngressNetworksChanges(Type):
    _toSchema = {'changes': 'changes'}
    _toPy = {'changes': 'changes'}
    def __init__(self, changes=None, **unknown_fields):
        '''
        changes : typing.Sequence[~IngressNetworksChangeEvent]
        '''
        if changes is not None and not isinstance(changes, list):
            raise Exception('Expected changes to be of type Sequence')

        self.changes = [IngressNetworksChangeEvent.from_json(o) for o in changes or []]
        self.unknown_fields = unknown_fields



class InitiateMigrationArgs(Type):
    _toSchema = {'specs': 'specs'}
    _toPy = {'specs': 'specs'}
    def __init__(self, specs=None, **unknown_fields):
        '''
        specs : typing.Sequence[~MigrationSpec]
        '''
        if specs is not None and not isinstance(specs, list):
            raise Exception('Expected specs to be of type Sequence')

        self.specs = [MigrationSpec.from_json(o) for o in specs or []]
        self.unknown_fields = unknown_fields



class InitiateMigrationResult(Type):
    _toSchema = {'error': 'error', 'migration_id': 'migration-id', 'model_tag': 'model-tag'}
    _toPy = {'error': 'error', 'migration-id': 'migration_id', 'model-tag': 'model_tag'}
    def __init__(self, error=None, migration_id=None, model_tag=None, **unknown_fields):
        '''
        error : Error
        migration_id : str
        model_tag : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if migration_id is not None and not isinstance(migration_id, (bytes, str)):
            raise Exception('Expected migration_id to be of type str')

        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception('Expected model_tag to be of type str')

        self.error = Error.from_json(error) if error else None
        self.migration_id = migration_id
        self.model_tag = model_tag
        self.unknown_fields = unknown_fields



class InitiateMigrationResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~InitiateMigrationResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [InitiateMigrationResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class InstanceInfo(Type):
    _toSchema = {'characteristics': 'characteristics', 'charm_profiles': 'charm-profiles', 'display_name': 'display-name', 'instance_id': 'instance-id', 'network_config': 'network-config', 'nonce': 'nonce', 'tag': 'tag', 'volume_attachments': 'volume-attachments', 'volumes': 'volumes'}
    _toPy = {'characteristics': 'characteristics', 'charm-profiles': 'charm_profiles', 'display-name': 'display_name', 'instance-id': 'instance_id', 'network-config': 'network_config', 'nonce': 'nonce', 'tag': 'tag', 'volume-attachments': 'volume_attachments', 'volumes': 'volumes'}
    def __init__(self, characteristics=None, charm_profiles=None, display_name=None, instance_id=None, network_config=None, nonce=None, tag=None, volume_attachments=None, volumes=None, **unknown_fields):
        '''
        characteristics : HardwareCharacteristics
        charm_profiles : typing.Sequence[str]
        display_name : str
        instance_id : str
        network_config : typing.Sequence[~NetworkConfig]
        nonce : str
        tag : str
        volume_attachments : typing.Mapping[str, ~VolumeAttachmentInfo]
        volumes : typing.Sequence[~Volume]
        '''
        if characteristics is not None and not isinstance(characteristics, HardwareCharacteristics):
            raise Exception('Expected characteristics to be of type HardwareCharacteristics')

        if charm_profiles is not None and not isinstance(charm_profiles, list):
            raise Exception('Expected charm_profiles to be of type Sequence')

        if display_name is not None and not isinstance(display_name, (bytes, str)):
            raise Exception('Expected display_name to be of type str')

        if instance_id is not None and not isinstance(instance_id, (bytes, str)):
            raise Exception('Expected instance_id to be of type str')

        if network_config is not None and not isinstance(network_config, list):
            raise Exception('Expected network_config to be of type Sequence')

        if nonce is not None and not isinstance(nonce, (bytes, str)):
            raise Exception('Expected nonce to be of type str')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        if volume_attachments is not None and not isinstance(volume_attachments, dict):
            raise Exception('Expected volume_attachments to be of type Mapping')

        if volumes is not None and not isinstance(volumes, list):
            raise Exception('Expected volumes to be of type Sequence')

        self.characteristics = HardwareCharacteristics.from_json(characteristics) if characteristics else None
        self.charm_profiles = charm_profiles
        self.display_name = display_name
        self.instance_id = instance_id
        self.network_config = [NetworkConfig.from_json(o) for o in network_config or []]
        self.nonce = nonce
        self.tag = tag
        self.volume_attachments = volume_attachments
        self.volumes = [Volume.from_json(o) for o in volumes or []]
        self.unknown_fields = unknown_fields



class InstanceType(Type):
    _toSchema = {'arches': 'arches', 'cost': 'cost', 'cpu_cores': 'cpu-cores', 'deprecated': 'deprecated', 'memory': 'memory', 'name': 'name', 'root_disk': 'root-disk', 'virt_type': 'virt-type'}
    _toPy = {'arches': 'arches', 'cost': 'cost', 'cpu-cores': 'cpu_cores', 'deprecated': 'deprecated', 'memory': 'memory', 'name': 'name', 'root-disk': 'root_disk', 'virt-type': 'virt_type'}
    def __init__(self, arches=None, cost=None, cpu_cores=None, deprecated=None, memory=None, name=None, root_disk=None, virt_type=None, **unknown_fields):
        '''
        arches : typing.Sequence[str]
        cost : int
        cpu_cores : int
        deprecated : bool
        memory : int
        name : str
        root_disk : int
        virt_type : str
        '''
        if arches is not None and not isinstance(arches, list):
            raise Exception('Expected arches to be of type Sequence')

        if cost is not None and not isinstance(cost, int):
            raise Exception('Expected cost to be of type int')

        if cpu_cores is not None and not isinstance(cpu_cores, int):
            raise Exception('Expected cpu_cores to be of type int')

        if deprecated is not None and not isinstance(deprecated, bool):
            raise Exception('Expected deprecated to be of type bool')

        if memory is not None and not isinstance(memory, int):
            raise Exception('Expected memory to be of type int')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if root_disk is not None and not isinstance(root_disk, int):
            raise Exception('Expected root_disk to be of type int')

        if virt_type is not None and not isinstance(virt_type, (bytes, str)):
            raise Exception('Expected virt_type to be of type str')

        self.arches = arches
        self.cost = cost
        self.cpu_cores = cpu_cores
        self.deprecated = deprecated
        self.memory = memory
        self.name = name
        self.root_disk = root_disk
        self.virt_type = virt_type
        self.unknown_fields = unknown_fields



class InstanceTypesResult(Type):
    _toSchema = {'cost_currency': 'cost-currency', 'cost_divisor': 'cost-divisor', 'cost_unit': 'cost-unit', 'error': 'error', 'instance_types': 'instance-types'}
    _toPy = {'cost-currency': 'cost_currency', 'cost-divisor': 'cost_divisor', 'cost-unit': 'cost_unit', 'error': 'error', 'instance-types': 'instance_types'}
    def __init__(self, cost_currency=None, cost_divisor=None, cost_unit=None, error=None, instance_types=None, **unknown_fields):
        '''
        cost_currency : str
        cost_divisor : int
        cost_unit : str
        error : Error
        instance_types : typing.Sequence[~InstanceType]
        '''
        if cost_currency is not None and not isinstance(cost_currency, (bytes, str)):
            raise Exception('Expected cost_currency to be of type str')

        if cost_divisor is not None and not isinstance(cost_divisor, int):
            raise Exception('Expected cost_divisor to be of type int')

        if cost_unit is not None and not isinstance(cost_unit, (bytes, str)):
            raise Exception('Expected cost_unit to be of type str')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if instance_types is not None and not isinstance(instance_types, list):
            raise Exception('Expected instance_types to be of type Sequence')

        self.cost_currency = cost_currency
        self.cost_divisor = cost_divisor
        self.cost_unit = cost_unit
        self.error = Error.from_json(error) if error else None
        self.instance_types = [InstanceType.from_json(o) for o in instance_types or []]
        self.unknown_fields = unknown_fields



class InstanceTypesResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~InstanceTypesResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [InstanceTypesResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class InstancesInfo(Type):
    _toSchema = {'machines': 'machines'}
    _toPy = {'machines': 'machines'}
    def __init__(self, machines=None, **unknown_fields):
        '''
        machines : typing.Sequence[~InstanceInfo]
        '''
        if machines is not None and not isinstance(machines, list):
            raise Exception('Expected machines to be of type Sequence')

        self.machines = [InstanceInfo.from_json(o) for o in machines or []]
        self.unknown_fields = unknown_fields



class IntResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : int
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, int):
            raise Exception('Expected result to be of type int')

        self.error = Error.from_json(error) if error else None
        self.result = result
        self.unknown_fields = unknown_fields



class IntResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~IntResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [IntResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class InterfaceAddress(Type):
    _toSchema = {'cidr': 'cidr', 'hostname': 'hostname', 'value': 'value'}
    _toPy = {'cidr': 'cidr', 'hostname': 'hostname', 'value': 'value'}
    def __init__(self, cidr=None, hostname=None, value=None, **unknown_fields):
        '''
        cidr : str
        hostname : str
        value : str
        '''
        if cidr is not None and not isinstance(cidr, (bytes, str)):
            raise Exception('Expected cidr to be of type str')

        if hostname is not None and not isinstance(hostname, (bytes, str)):
            raise Exception('Expected hostname to be of type str')

        if value is not None and not isinstance(value, (bytes, str)):
            raise Exception('Expected value to be of type str')

        self.cidr = cidr
        self.hostname = hostname
        self.value = value
        self.unknown_fields = unknown_fields



class InvalidateCredentialArg(Type):
    _toSchema = {'reason': 'reason'}
    _toPy = {'reason': 'reason'}
    def __init__(self, reason=None, **unknown_fields):
        '''
        reason : str
        '''
        if reason is not None and not isinstance(reason, (bytes, str)):
            raise Exception('Expected reason to be of type str')

        self.reason = reason
        self.unknown_fields = unknown_fields



class IsMasterResult(Type):
    _toSchema = {'master': 'master'}
    _toPy = {'master': 'master'}
    def __init__(self, master=None, **unknown_fields):
        '''
        master : bool
        '''
        if master is not None and not isinstance(master, bool):
            raise Exception('Expected master to be of type bool')

        self.master = master
        self.unknown_fields = unknown_fields



class IsMeteredResult(Type):
    _toSchema = {'metered': 'metered'}
    _toPy = {'metered': 'metered'}
    def __init__(self, metered=None, **unknown_fields):
        '''
        metered : bool
        '''
        if metered is not None and not isinstance(metered, bool):
            raise Exception('Expected metered to be of type bool')

        self.metered = metered
        self.unknown_fields = unknown_fields



class JobsResult(Type):
    _toSchema = {'error': 'error', 'jobs': 'jobs'}
    _toPy = {'error': 'error', 'jobs': 'jobs'}
    def __init__(self, error=None, jobs=None, **unknown_fields):
        '''
        error : Error
        jobs : typing.Sequence[str]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if jobs is not None and not isinstance(jobs, list):
            raise Exception('Expected jobs to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.jobs = jobs
        self.unknown_fields = unknown_fields



class JobsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~JobsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [JobsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class KnownServiceArgs(Type):
    _toSchema = {'known_services': 'known-services'}
    _toPy = {'known-services': 'known_services'}
    def __init__(self, known_services=None, **unknown_fields):
        '''
        known_services : typing.Sequence[str]
        '''
        if known_services is not None and not isinstance(known_services, list):
            raise Exception('Expected known_services to be of type Sequence')

        self.known_services = known_services
        self.unknown_fields = unknown_fields



class KubernetesDeploymentInfo(Type):
    _toSchema = {'deployment_type': 'deployment-type', 'service_type': 'service-type'}
    _toPy = {'deployment-type': 'deployment_type', 'service-type': 'service_type'}
    def __init__(self, deployment_type=None, service_type=None, **unknown_fields):
        '''
        deployment_type : str
        service_type : str
        '''
        if deployment_type is not None and not isinstance(deployment_type, (bytes, str)):
            raise Exception('Expected deployment_type to be of type str')

        if service_type is not None and not isinstance(service_type, (bytes, str)):
            raise Exception('Expected service_type to be of type str')

        self.deployment_type = deployment_type
        self.service_type = service_type
        self.unknown_fields = unknown_fields



class KubernetesDeviceParams(Type):
    _toSchema = {'attributes': 'Attributes', 'count': 'Count', 'type_': 'Type'}
    _toPy = {'Attributes': 'attributes', 'Count': 'count', 'Type': 'type_'}
    def __init__(self, attributes=None, count=None, type_=None, **unknown_fields):
        '''
        attributes : typing.Mapping[str, str]
        count : int
        type_ : str
        '''
        if attributes is not None and not isinstance(attributes, dict):
            raise Exception('Expected attributes to be of type Mapping')

        if count is not None and not isinstance(count, int):
            raise Exception('Expected count to be of type int')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        self.attributes = attributes
        self.count = count
        self.type_ = type_
        self.unknown_fields = unknown_fields



class KubernetesFilesystemAttachmentParams(Type):
    _toSchema = {'mount_point': 'mount-point', 'provider': 'provider', 'read_only': 'read-only'}
    _toPy = {'mount-point': 'mount_point', 'provider': 'provider', 'read-only': 'read_only'}
    def __init__(self, mount_point=None, provider=None, read_only=None, **unknown_fields):
        '''
        mount_point : str
        provider : str
        read_only : bool
        '''
        if mount_point is not None and not isinstance(mount_point, (bytes, str)):
            raise Exception('Expected mount_point to be of type str')

        if provider is not None and not isinstance(provider, (bytes, str)):
            raise Exception('Expected provider to be of type str')

        if read_only is not None and not isinstance(read_only, bool):
            raise Exception('Expected read_only to be of type bool')

        self.mount_point = mount_point
        self.provider = provider
        self.read_only = read_only
        self.unknown_fields = unknown_fields



class KubernetesFilesystemInfo(Type):
    _toSchema = {'data': 'data', 'filesystem_id': 'filesystem-id', 'info': 'info', 'mount_point': 'mount-point', 'pool': 'pool', 'read_only': 'read-only', 'size': 'size', 'status': 'status', 'storagename': 'storagename', 'volume': 'volume'}
    _toPy = {'data': 'data', 'filesystem-id': 'filesystem_id', 'info': 'info', 'mount-point': 'mount_point', 'pool': 'pool', 'read-only': 'read_only', 'size': 'size', 'status': 'status', 'storagename': 'storagename', 'volume': 'volume'}
    def __init__(self, data=None, filesystem_id=None, info=None, mount_point=None, pool=None, read_only=None, size=None, status=None, storagename=None, volume=None, **unknown_fields):
        '''
        data : typing.Mapping[str, typing.Any]
        filesystem_id : str
        info : str
        mount_point : str
        pool : str
        read_only : bool
        size : int
        status : str
        storagename : str
        volume : KubernetesVolumeInfo
        '''
        if data is not None and not isinstance(data, dict):
            raise Exception('Expected data to be of type Mapping')

        if filesystem_id is not None and not isinstance(filesystem_id, (bytes, str)):
            raise Exception('Expected filesystem_id to be of type str')

        if info is not None and not isinstance(info, (bytes, str)):
            raise Exception('Expected info to be of type str')

        if mount_point is not None and not isinstance(mount_point, (bytes, str)):
            raise Exception('Expected mount_point to be of type str')

        if pool is not None and not isinstance(pool, (bytes, str)):
            raise Exception('Expected pool to be of type str')

        if read_only is not None and not isinstance(read_only, bool):
            raise Exception('Expected read_only to be of type bool')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        if storagename is not None and not isinstance(storagename, (bytes, str)):
            raise Exception('Expected storagename to be of type str')

        if volume is not None and not isinstance(volume, KubernetesVolumeInfo):
            raise Exception('Expected volume to be of type KubernetesVolumeInfo')

        self.data = data
        self.filesystem_id = filesystem_id
        self.info = info
        self.mount_point = mount_point
        self.pool = pool
        self.read_only = read_only
        self.size = size
        self.status = status
        self.storagename = storagename
        self.volume = KubernetesVolumeInfo.from_json(volume) if volume else None
        self.unknown_fields = unknown_fields



class KubernetesFilesystemParams(Type):
    _toSchema = {'attachment': 'attachment', 'attributes': 'attributes', 'provider': 'provider', 'size': 'size', 'storagename': 'storagename', 'tags': 'tags'}
    _toPy = {'attachment': 'attachment', 'attributes': 'attributes', 'provider': 'provider', 'size': 'size', 'storagename': 'storagename', 'tags': 'tags'}
    def __init__(self, attachment=None, attributes=None, provider=None, size=None, storagename=None, tags=None, **unknown_fields):
        '''
        attachment : KubernetesFilesystemAttachmentParams
        attributes : typing.Mapping[str, typing.Any]
        provider : str
        size : int
        storagename : str
        tags : typing.Mapping[str, str]
        '''
        if attachment is not None and not isinstance(attachment, KubernetesFilesystemAttachmentParams):
            raise Exception('Expected attachment to be of type KubernetesFilesystemAttachmentParams')

        if attributes is not None and not isinstance(attributes, dict):
            raise Exception('Expected attributes to be of type Mapping')

        if provider is not None and not isinstance(provider, (bytes, str)):
            raise Exception('Expected provider to be of type str')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if storagename is not None and not isinstance(storagename, (bytes, str)):
            raise Exception('Expected storagename to be of type str')

        if tags is not None and not isinstance(tags, dict):
            raise Exception('Expected tags to be of type Mapping')

        self.attachment = KubernetesFilesystemAttachmentParams.from_json(attachment) if attachment else None
        self.attributes = attributes
        self.provider = provider
        self.size = size
        self.storagename = storagename
        self.tags = tags
        self.unknown_fields = unknown_fields



class KubernetesProvisioningInfo(Type):
    _toSchema = {'constraints': 'constraints', 'deployment_info': 'deployment-info', 'devices': 'devices', 'filesystems': 'filesystems', 'pod_spec': 'pod-spec', 'tags': 'tags', 'volumes': 'volumes'}
    _toPy = {'constraints': 'constraints', 'deployment-info': 'deployment_info', 'devices': 'devices', 'filesystems': 'filesystems', 'pod-spec': 'pod_spec', 'tags': 'tags', 'volumes': 'volumes'}
    def __init__(self, constraints=None, deployment_info=None, devices=None, filesystems=None, pod_spec=None, tags=None, volumes=None, **unknown_fields):
        '''
        constraints : Value
        deployment_info : KubernetesDeploymentInfo
        devices : typing.Sequence[~KubernetesDeviceParams]
        filesystems : typing.Sequence[~KubernetesFilesystemParams]
        pod_spec : str
        tags : typing.Mapping[str, str]
        volumes : typing.Sequence[~KubernetesVolumeParams]
        '''
        if constraints is not None and not isinstance(constraints, Value):
            raise Exception('Expected constraints to be of type Value')

        if deployment_info is not None and not isinstance(deployment_info, KubernetesDeploymentInfo):
            raise Exception('Expected deployment_info to be of type KubernetesDeploymentInfo')

        if devices is not None and not isinstance(devices, list):
            raise Exception('Expected devices to be of type Sequence')

        if filesystems is not None and not isinstance(filesystems, list):
            raise Exception('Expected filesystems to be of type Sequence')

        if pod_spec is not None and not isinstance(pod_spec, (bytes, str)):
            raise Exception('Expected pod_spec to be of type str')

        if tags is not None and not isinstance(tags, dict):
            raise Exception('Expected tags to be of type Mapping')

        if volumes is not None and not isinstance(volumes, list):
            raise Exception('Expected volumes to be of type Sequence')

        self.constraints = Value.from_json(constraints) if constraints else None
        self.deployment_info = KubernetesDeploymentInfo.from_json(deployment_info) if deployment_info else None
        self.devices = [KubernetesDeviceParams.from_json(o) for o in devices or []]
        self.filesystems = [KubernetesFilesystemParams.from_json(o) for o in filesystems or []]
        self.pod_spec = pod_spec
        self.tags = tags
        self.volumes = [KubernetesVolumeParams.from_json(o) for o in volumes or []]
        self.unknown_fields = unknown_fields



class KubernetesProvisioningInfoResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : KubernetesProvisioningInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, KubernetesProvisioningInfo):
            raise Exception('Expected result to be of type KubernetesProvisioningInfo')

        self.error = Error.from_json(error) if error else None
        self.result = KubernetesProvisioningInfo.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class KubernetesProvisioningInfoResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~KubernetesProvisioningInfoResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [KubernetesProvisioningInfoResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class KubernetesUpgradeArg(Type):
    _toSchema = {'agent_tag': 'agent-tag', 'version': 'version'}
    _toPy = {'agent-tag': 'agent_tag', 'version': 'version'}
    def __init__(self, agent_tag=None, version=None, **unknown_fields):
        '''
        agent_tag : str
        version : Number
        '''
        if agent_tag is not None and not isinstance(agent_tag, (bytes, str)):
            raise Exception('Expected agent_tag to be of type str')

        if version is not None and not isinstance(version, Number):
            raise Exception('Expected version to be of type Number')

        self.agent_tag = agent_tag
        self.version = Number.from_json(version) if version else None
        self.unknown_fields = unknown_fields



class KubernetesVolumeAttachmentParams(Type):
    _toSchema = {'provider': 'provider', 'read_only': 'read-only'}
    _toPy = {'provider': 'provider', 'read-only': 'read_only'}
    def __init__(self, provider=None, read_only=None, **unknown_fields):
        '''
        provider : str
        read_only : bool
        '''
        if provider is not None and not isinstance(provider, (bytes, str)):
            raise Exception('Expected provider to be of type str')

        if read_only is not None and not isinstance(read_only, bool):
            raise Exception('Expected read_only to be of type bool')

        self.provider = provider
        self.read_only = read_only
        self.unknown_fields = unknown_fields



class KubernetesVolumeInfo(Type):
    _toSchema = {'data': 'data', 'info': 'info', 'persistent': 'persistent', 'pool': 'pool', 'size': 'size', 'status': 'status', 'volume_id': 'volume-id'}
    _toPy = {'data': 'data', 'info': 'info', 'persistent': 'persistent', 'pool': 'pool', 'size': 'size', 'status': 'status', 'volume-id': 'volume_id'}
    def __init__(self, data=None, info=None, persistent=None, pool=None, size=None, status=None, volume_id=None, **unknown_fields):
        '''
        data : typing.Mapping[str, typing.Any]
        info : str
        persistent : bool
        pool : str
        size : int
        status : str
        volume_id : str
        '''
        if data is not None and not isinstance(data, dict):
            raise Exception('Expected data to be of type Mapping')

        if info is not None and not isinstance(info, (bytes, str)):
            raise Exception('Expected info to be of type str')

        if persistent is not None and not isinstance(persistent, bool):
            raise Exception('Expected persistent to be of type bool')

        if pool is not None and not isinstance(pool, (bytes, str)):
            raise Exception('Expected pool to be of type str')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        if volume_id is not None and not isinstance(volume_id, (bytes, str)):
            raise Exception('Expected volume_id to be of type str')

        self.data = data
        self.info = info
        self.persistent = persistent
        self.pool = pool
        self.size = size
        self.status = status
        self.volume_id = volume_id
        self.unknown_fields = unknown_fields



class KubernetesVolumeParams(Type):
    _toSchema = {'attachment': 'attachment', 'attributes': 'attributes', 'provider': 'provider', 'size': 'size', 'storagename': 'storagename', 'tags': 'tags'}
    _toPy = {'attachment': 'attachment', 'attributes': 'attributes', 'provider': 'provider', 'size': 'size', 'storagename': 'storagename', 'tags': 'tags'}
    def __init__(self, attachment=None, attributes=None, provider=None, size=None, storagename=None, tags=None, **unknown_fields):
        '''
        attachment : KubernetesVolumeAttachmentParams
        attributes : typing.Mapping[str, typing.Any]
        provider : str
        size : int
        storagename : str
        tags : typing.Mapping[str, str]
        '''
        if attachment is not None and not isinstance(attachment, KubernetesVolumeAttachmentParams):
            raise Exception('Expected attachment to be of type KubernetesVolumeAttachmentParams')

        if attributes is not None and not isinstance(attributes, dict):
            raise Exception('Expected attributes to be of type Mapping')

        if provider is not None and not isinstance(provider, (bytes, str)):
            raise Exception('Expected provider to be of type str')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if storagename is not None and not isinstance(storagename, (bytes, str)):
            raise Exception('Expected storagename to be of type str')

        if tags is not None and not isinstance(tags, dict):
            raise Exception('Expected tags to be of type Mapping')

        self.attachment = KubernetesVolumeAttachmentParams.from_json(attachment) if attachment else None
        self.attributes = attributes
        self.provider = provider
        self.size = size
        self.storagename = storagename
        self.tags = tags
        self.unknown_fields = unknown_fields



class LXDProfile(Type):
    _toSchema = {'config': 'config', 'description': 'description', 'devices': 'devices'}
    _toPy = {'config': 'config', 'description': 'description', 'devices': 'devices'}
    def __init__(self, config=None, description=None, devices=None, **unknown_fields):
        '''
        config : typing.Mapping[str, str]
        description : str
        devices : typing.Mapping[str, typing.Any]
        '''
        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if devices is not None and not isinstance(devices, dict):
            raise Exception('Expected devices to be of type Mapping')

        self.config = config
        self.description = description
        self.devices = devices
        self.unknown_fields = unknown_fields



class LXDProfileUpgradeMessages(Type):
    _toSchema = {'application': 'application', 'watcher_id': 'watcher-id'}
    _toPy = {'application': 'application', 'watcher-id': 'watcher_id'}
    def __init__(self, application=None, watcher_id=None, **unknown_fields):
        '''
        application : Entity
        watcher_id : str
        '''
        if application is not None and not isinstance(application, Entity):
            raise Exception('Expected application to be of type Entity')

        if watcher_id is not None and not isinstance(watcher_id, (bytes, str)):
            raise Exception('Expected watcher_id to be of type str')

        self.application = Entity.from_json(application) if application else None
        self.watcher_id = watcher_id
        self.unknown_fields = unknown_fields



class LXDProfileUpgradeMessagesResult(Type):
    _toSchema = {'error': 'error', 'message': 'message', 'unit_name': 'unit-name'}
    _toPy = {'error': 'error', 'message': 'message', 'unit-name': 'unit_name'}
    def __init__(self, error=None, message=None, unit_name=None, **unknown_fields):
        '''
        error : Error
        message : str
        unit_name : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        if unit_name is not None and not isinstance(unit_name, (bytes, str)):
            raise Exception('Expected unit_name to be of type str')

        self.error = Error.from_json(error) if error else None
        self.message = message
        self.unit_name = unit_name
        self.unknown_fields = unknown_fields



class LXDProfileUpgradeMessagesResults(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~LXDProfileUpgradeMessagesResult]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [LXDProfileUpgradeMessagesResult.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class LifeResult(Type):
    _toSchema = {'error': 'error', 'life': 'life'}
    _toPy = {'error': 'error', 'life': 'life'}
    def __init__(self, error=None, life=None, **unknown_fields):
        '''
        error : Error
        life : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        self.error = Error.from_json(error) if error else None
        self.life = life
        self.unknown_fields = unknown_fields



class LifeResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~LifeResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [LifeResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ListCloudImageMetadataResult(Type):
    _toSchema = {'result': 'result'}
    _toPy = {'result': 'result'}
    def __init__(self, result=None, **unknown_fields):
        '''
        result : typing.Sequence[~CloudImageMetadata]
        '''
        if result is not None and not isinstance(result, list):
            raise Exception('Expected result to be of type Sequence')

        self.result = [CloudImageMetadata.from_json(o) for o in result or []]
        self.unknown_fields = unknown_fields



class ListCloudInfo(Type):
    _toSchema = {'clouddetails': 'CloudDetails', 'user_access': 'user-access'}
    _toPy = {'CloudDetails': 'clouddetails', 'user-access': 'user_access'}
    def __init__(self, clouddetails=None, user_access=None, **unknown_fields):
        '''
        clouddetails : CloudDetails
        user_access : str
        '''
        if clouddetails is not None and not isinstance(clouddetails, CloudDetails):
            raise Exception('Expected clouddetails to be of type CloudDetails')

        if user_access is not None and not isinstance(user_access, (bytes, str)):
            raise Exception('Expected user_access to be of type str')

        self.clouddetails = CloudDetails.from_json(clouddetails) if clouddetails else None
        self.user_access = user_access
        self.unknown_fields = unknown_fields



class ListCloudInfoResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : ListCloudInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, ListCloudInfo):
            raise Exception('Expected result to be of type ListCloudInfo')

        self.error = Error.from_json(error) if error else None
        self.result = ListCloudInfo.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class ListCloudInfoResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ListCloudInfoResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ListCloudInfoResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ListCloudsRequest(Type):
    _toSchema = {'all_': 'all', 'user_tag': 'user-tag'}
    _toPy = {'all': 'all_', 'user-tag': 'user_tag'}
    def __init__(self, all_=None, user_tag=None, **unknown_fields):
        '''
        all_ : bool
        user_tag : str
        '''
        if all_ is not None and not isinstance(all_, bool):
            raise Exception('Expected all_ to be of type bool')

        if user_tag is not None and not isinstance(user_tag, (bytes, str)):
            raise Exception('Expected user_tag to be of type str')

        self.all_ = all_
        self.user_tag = user_tag
        self.unknown_fields = unknown_fields



class ListFirewallRulesResults(Type):
    _toSchema = {'rules': 'Rules'}
    _toPy = {'Rules': 'rules'}
    def __init__(self, rules=None, **unknown_fields):
        '''
        rules : typing.Sequence[~FirewallRule]
        '''
        if rules is not None and not isinstance(rules, list):
            raise Exception('Expected rules to be of type Sequence')

        self.rules = [FirewallRule.from_json(o) for o in rules or []]
        self.unknown_fields = unknown_fields



class ListImageResult(Type):
    _toSchema = {'result': 'result'}
    _toPy = {'result': 'result'}
    def __init__(self, result=None, **unknown_fields):
        '''
        result : typing.Sequence[~ImageMetadata]
        '''
        if result is not None and not isinstance(result, list):
            raise Exception('Expected result to be of type Sequence')

        self.result = [ImageMetadata.from_json(o) for o in result or []]
        self.unknown_fields = unknown_fields



class ListResourcesArgs(Type):
    _toSchema = {'entities': 'entities'}
    _toPy = {'entities': 'entities'}
    def __init__(self, entities=None, **unknown_fields):
        '''
        entities : typing.Sequence[~Entity]
        '''
        if entities is not None and not isinstance(entities, list):
            raise Exception('Expected entities to be of type Sequence')

        self.entities = [Entity.from_json(o) for o in entities or []]
        self.unknown_fields = unknown_fields



class ListSSHKeys(Type):
    _toSchema = {'entities': 'entities', 'mode': 'mode'}
    _toPy = {'entities': 'entities', 'mode': 'mode'}
    def __init__(self, entities=None, mode=None, **unknown_fields):
        '''
        entities : Entities
        mode : bool
        '''
        if entities is not None and not isinstance(entities, Entities):
            raise Exception('Expected entities to be of type Entities')

        if mode is not None and not isinstance(mode, bool):
            raise Exception('Expected mode to be of type bool')

        self.entities = Entities.from_json(entities) if entities else None
        self.mode = mode
        self.unknown_fields = unknown_fields



class ListSpacesResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~Space]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [Space.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ListSubnetsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~Subnet]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [Subnet.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ListUnitResourcesArgs(Type):
    _toSchema = {'resource_names': 'resource-names'}
    _toPy = {'resource-names': 'resource_names'}
    def __init__(self, resource_names=None, **unknown_fields):
        '''
        resource_names : typing.Sequence[str]
        '''
        if resource_names is not None and not isinstance(resource_names, list):
            raise Exception('Expected resource_names to be of type Sequence')

        self.resource_names = resource_names
        self.unknown_fields = unknown_fields



class LogForwardingGetLastSentParams(Type):
    _toSchema = {'ids': 'ids'}
    _toPy = {'ids': 'ids'}
    def __init__(self, ids=None, **unknown_fields):
        '''
        ids : typing.Sequence[~LogForwardingID]
        '''
        if ids is not None and not isinstance(ids, list):
            raise Exception('Expected ids to be of type Sequence')

        self.ids = [LogForwardingID.from_json(o) for o in ids or []]
        self.unknown_fields = unknown_fields



class LogForwardingGetLastSentResult(Type):
    _toSchema = {'err': 'err', 'record_id': 'record-id', 'record_timestamp': 'record-timestamp'}
    _toPy = {'err': 'err', 'record-id': 'record_id', 'record-timestamp': 'record_timestamp'}
    def __init__(self, err=None, record_id=None, record_timestamp=None, **unknown_fields):
        '''
        err : Error
        record_id : int
        record_timestamp : int
        '''
        if err is not None and not isinstance(err, Error):
            raise Exception('Expected err to be of type Error')

        if record_id is not None and not isinstance(record_id, int):
            raise Exception('Expected record_id to be of type int')

        if record_timestamp is not None and not isinstance(record_timestamp, int):
            raise Exception('Expected record_timestamp to be of type int')

        self.err = Error.from_json(err) if err else None
        self.record_id = record_id
        self.record_timestamp = record_timestamp
        self.unknown_fields = unknown_fields



class LogForwardingGetLastSentResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~LogForwardingGetLastSentResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [LogForwardingGetLastSentResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class LogForwardingID(Type):
    _toSchema = {'model': 'model', 'sink': 'sink'}
    _toPy = {'model': 'model', 'sink': 'sink'}
    def __init__(self, model=None, sink=None, **unknown_fields):
        '''
        model : str
        sink : str
        '''
        if model is not None and not isinstance(model, (bytes, str)):
            raise Exception('Expected model to be of type str')

        if sink is not None and not isinstance(sink, (bytes, str)):
            raise Exception('Expected sink to be of type str')

        self.model = model
        self.sink = sink
        self.unknown_fields = unknown_fields



class LogForwardingSetLastSentParam(Type):
    _toSchema = {'logforwardingid': 'LogForwardingID', 'model': 'model', 'record_id': 'record-id', 'record_timestamp': 'record-timestamp', 'sink': 'sink'}
    _toPy = {'LogForwardingID': 'logforwardingid', 'model': 'model', 'record-id': 'record_id', 'record-timestamp': 'record_timestamp', 'sink': 'sink'}
    def __init__(self, logforwardingid=None, model=None, record_id=None, record_timestamp=None, sink=None, **unknown_fields):
        '''
        logforwardingid : LogForwardingID
        model : str
        record_id : int
        record_timestamp : int
        sink : str
        '''
        if logforwardingid is not None and not isinstance(logforwardingid, LogForwardingID):
            raise Exception('Expected logforwardingid to be of type LogForwardingID')

        if model is not None and not isinstance(model, (bytes, str)):
            raise Exception('Expected model to be of type str')

        if record_id is not None and not isinstance(record_id, int):
            raise Exception('Expected record_id to be of type int')

        if record_timestamp is not None and not isinstance(record_timestamp, int):
            raise Exception('Expected record_timestamp to be of type int')

        if sink is not None and not isinstance(sink, (bytes, str)):
            raise Exception('Expected sink to be of type str')

        self.logforwardingid = LogForwardingID.from_json(logforwardingid) if logforwardingid else None
        self.model = model
        self.record_id = record_id
        self.record_timestamp = record_timestamp
        self.sink = sink
        self.unknown_fields = unknown_fields



class LogForwardingSetLastSentParams(Type):
    _toSchema = {'params': 'params'}
    _toPy = {'params': 'params'}
    def __init__(self, params=None, **unknown_fields):
        '''
        params : typing.Sequence[~LogForwardingSetLastSentParam]
        '''
        if params is not None and not isinstance(params, list):
            raise Exception('Expected params to be of type Sequence')

        self.params = [LogForwardingSetLastSentParam.from_json(o) for o in params or []]
        self.unknown_fields = unknown_fields



class LookUpArg(Type):
    _toSchema = {'id_': 'id', 'name': 'name'}
    _toPy = {'id': 'id_', 'name': 'name'}
    def __init__(self, id_=None, name=None, **unknown_fields):
        '''
        id_ : str
        name : str
        '''
        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        self.id_ = id_
        self.name = name
        self.unknown_fields = unknown_fields



class LookUpArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~LookUpArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [LookUpArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class LookUpPayloadArg(Type):
    _toSchema = {'id_': 'id', 'name': 'name'}
    _toPy = {'id': 'id_', 'name': 'name'}
    def __init__(self, id_=None, name=None, **unknown_fields):
        '''
        id_ : str
        name : str
        '''
        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        self.id_ = id_
        self.name = name
        self.unknown_fields = unknown_fields



class LookUpPayloadArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~LookUpPayloadArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [LookUpPayloadArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class Macaroon(Type):
    _toSchema = {}
    _toPy = {}
    def __init__(self, **unknown_fields):
        '''

        '''
        self.unknown_fields = unknown_fields



class MacaroonResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : Macaroon
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, Macaroon):
            raise Exception('Expected result to be of type Macaroon')

        self.error = Error.from_json(error) if error else None
        self.result = Macaroon.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class MacaroonResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~MacaroonResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [MacaroonResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class MachineAddresses(Type):
    _toSchema = {'addresses': 'addresses', 'tag': 'tag'}
    _toPy = {'addresses': 'addresses', 'tag': 'tag'}
    def __init__(self, addresses=None, tag=None, **unknown_fields):
        '''
        addresses : typing.Sequence[~Address]
        tag : str
        '''
        if addresses is not None and not isinstance(addresses, list):
            raise Exception('Expected addresses to be of type Sequence')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.addresses = [Address.from_json(o) for o in addresses or []]
        self.tag = tag
        self.unknown_fields = unknown_fields



class MachineAddressesResult(Type):
    _toSchema = {'addresses': 'addresses', 'error': 'error'}
    _toPy = {'addresses': 'addresses', 'error': 'error'}
    def __init__(self, addresses=None, error=None, **unknown_fields):
        '''
        addresses : typing.Sequence[~Address]
        error : Error
        '''
        if addresses is not None and not isinstance(addresses, list):
            raise Exception('Expected addresses to be of type Sequence')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.addresses = [Address.from_json(o) for o in addresses or []]
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class MachineAddressesResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~MachineAddressesResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [MachineAddressesResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class MachineBlockDevices(Type):
    _toSchema = {'block_devices': 'block-devices', 'machine': 'machine'}
    _toPy = {'block-devices': 'block_devices', 'machine': 'machine'}
    def __init__(self, block_devices=None, machine=None, **unknown_fields):
        '''
        block_devices : typing.Sequence[~BlockDevice]
        machine : str
        '''
        if block_devices is not None and not isinstance(block_devices, list):
            raise Exception('Expected block_devices to be of type Sequence')

        if machine is not None and not isinstance(machine, (bytes, str)):
            raise Exception('Expected machine to be of type str')

        self.block_devices = [BlockDevice.from_json(o) for o in block_devices or []]
        self.machine = machine
        self.unknown_fields = unknown_fields



class MachineContainerResult(Type):
    _toSchema = {'container_types': 'container-types', 'determined': 'determined', 'error': 'error'}
    _toPy = {'container-types': 'container_types', 'determined': 'determined', 'error': 'error'}
    def __init__(self, container_types=None, determined=None, error=None, **unknown_fields):
        '''
        container_types : typing.Sequence[str]
        determined : bool
        error : Error
        '''
        if container_types is not None and not isinstance(container_types, list):
            raise Exception('Expected container_types to be of type Sequence')

        if determined is not None and not isinstance(determined, bool):
            raise Exception('Expected determined to be of type bool')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.container_types = container_types
        self.determined = determined
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class MachineContainerResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~MachineContainerResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [MachineContainerResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class MachineContainers(Type):
    _toSchema = {'container_types': 'container-types', 'machine_tag': 'machine-tag'}
    _toPy = {'container-types': 'container_types', 'machine-tag': 'machine_tag'}
    def __init__(self, container_types=None, machine_tag=None, **unknown_fields):
        '''
        container_types : typing.Sequence[str]
        machine_tag : str
        '''
        if container_types is not None and not isinstance(container_types, list):
            raise Exception('Expected container_types to be of type Sequence')

        if machine_tag is not None and not isinstance(machine_tag, (bytes, str)):
            raise Exception('Expected machine_tag to be of type str')

        self.container_types = container_types
        self.machine_tag = machine_tag
        self.unknown_fields = unknown_fields



class MachineContainersParams(Type):
    _toSchema = {'params': 'params'}
    _toPy = {'params': 'params'}
    def __init__(self, params=None, **unknown_fields):
        '''
        params : typing.Sequence[~MachineContainers]
        '''
        if params is not None and not isinstance(params, list):
            raise Exception('Expected params to be of type Sequence')

        self.params = [MachineContainers.from_json(o) for o in params or []]
        self.unknown_fields = unknown_fields



class MachineHardware(Type):
    _toSchema = {'arch': 'arch', 'availability_zone': 'availability-zone', 'cores': 'cores', 'cpu_power': 'cpu-power', 'mem': 'mem', 'root_disk': 'root-disk', 'tags': 'tags'}
    _toPy = {'arch': 'arch', 'availability-zone': 'availability_zone', 'cores': 'cores', 'cpu-power': 'cpu_power', 'mem': 'mem', 'root-disk': 'root_disk', 'tags': 'tags'}
    def __init__(self, arch=None, availability_zone=None, cores=None, cpu_power=None, mem=None, root_disk=None, tags=None, **unknown_fields):
        '''
        arch : str
        availability_zone : str
        cores : int
        cpu_power : int
        mem : int
        root_disk : int
        tags : typing.Sequence[str]
        '''
        if arch is not None and not isinstance(arch, (bytes, str)):
            raise Exception('Expected arch to be of type str')

        if availability_zone is not None and not isinstance(availability_zone, (bytes, str)):
            raise Exception('Expected availability_zone to be of type str')

        if cores is not None and not isinstance(cores, int):
            raise Exception('Expected cores to be of type int')

        if cpu_power is not None and not isinstance(cpu_power, int):
            raise Exception('Expected cpu_power to be of type int')

        if mem is not None and not isinstance(mem, int):
            raise Exception('Expected mem to be of type int')

        if root_disk is not None and not isinstance(root_disk, int):
            raise Exception('Expected root_disk to be of type int')

        if tags is not None and not isinstance(tags, list):
            raise Exception('Expected tags to be of type Sequence')

        self.arch = arch
        self.availability_zone = availability_zone
        self.cores = cores
        self.cpu_power = cpu_power
        self.mem = mem
        self.root_disk = root_disk
        self.tags = tags
        self.unknown_fields = unknown_fields



class MachineNetworkConfigResult(Type):
    _toSchema = {'error': 'error', 'info': 'info'}
    _toPy = {'error': 'error', 'info': 'info'}
    def __init__(self, error=None, info=None, **unknown_fields):
        '''
        error : Error
        info : typing.Sequence[~NetworkConfig]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if info is not None and not isinstance(info, list):
            raise Exception('Expected info to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.info = [NetworkConfig.from_json(o) for o in info or []]
        self.unknown_fields = unknown_fields



class MachineNetworkConfigResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~MachineNetworkConfigResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [MachineNetworkConfigResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class MachinePortRange(Type):
    _toSchema = {'port_range': 'port-range', 'relation_tag': 'relation-tag', 'unit_tag': 'unit-tag'}
    _toPy = {'port-range': 'port_range', 'relation-tag': 'relation_tag', 'unit-tag': 'unit_tag'}
    def __init__(self, port_range=None, relation_tag=None, unit_tag=None, **unknown_fields):
        '''
        port_range : PortRange
        relation_tag : str
        unit_tag : str
        '''
        if port_range is not None and not isinstance(port_range, PortRange):
            raise Exception('Expected port_range to be of type PortRange')

        if relation_tag is not None and not isinstance(relation_tag, (bytes, str)):
            raise Exception('Expected relation_tag to be of type str')

        if unit_tag is not None and not isinstance(unit_tag, (bytes, str)):
            raise Exception('Expected unit_tag to be of type str')

        self.port_range = PortRange.from_json(port_range) if port_range else None
        self.relation_tag = relation_tag
        self.unit_tag = unit_tag
        self.unknown_fields = unknown_fields



class MachinePorts(Type):
    _toSchema = {'machine_tag': 'machine-tag', 'subnet_tag': 'subnet-tag'}
    _toPy = {'machine-tag': 'machine_tag', 'subnet-tag': 'subnet_tag'}
    def __init__(self, machine_tag=None, subnet_tag=None, **unknown_fields):
        '''
        machine_tag : str
        subnet_tag : str
        '''
        if machine_tag is not None and not isinstance(machine_tag, (bytes, str)):
            raise Exception('Expected machine_tag to be of type str')

        if subnet_tag is not None and not isinstance(subnet_tag, (bytes, str)):
            raise Exception('Expected subnet_tag to be of type str')

        self.machine_tag = machine_tag
        self.subnet_tag = subnet_tag
        self.unknown_fields = unknown_fields



class MachinePortsParams(Type):
    _toSchema = {'params': 'params'}
    _toPy = {'params': 'params'}
    def __init__(self, params=None, **unknown_fields):
        '''
        params : typing.Sequence[~MachinePorts]
        '''
        if params is not None and not isinstance(params, list):
            raise Exception('Expected params to be of type Sequence')

        self.params = [MachinePorts.from_json(o) for o in params or []]
        self.unknown_fields = unknown_fields



class MachinePortsResult(Type):
    _toSchema = {'error': 'error', 'ports': 'ports'}
    _toPy = {'error': 'error', 'ports': 'ports'}
    def __init__(self, error=None, ports=None, **unknown_fields):
        '''
        error : Error
        ports : typing.Sequence[~MachinePortRange]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if ports is not None and not isinstance(ports, list):
            raise Exception('Expected ports to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.ports = [MachinePortRange.from_json(o) for o in ports or []]
        self.unknown_fields = unknown_fields



class MachinePortsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~MachinePortsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [MachinePortsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class MachineStatus(Type):
    _toSchema = {'agent_status': 'agent-status', 'constraints': 'constraints', 'containers': 'containers', 'display_name': 'display-name', 'dns_name': 'dns-name', 'hardware': 'hardware', 'has_vote': 'has-vote', 'id_': 'id', 'instance_id': 'instance-id', 'instance_status': 'instance-status', 'ip_addresses': 'ip-addresses', 'jobs': 'jobs', 'lxd_profiles': 'lxd-profiles', 'modification_status': 'modification-status', 'network_interfaces': 'network-interfaces', 'series': 'series', 'wants_vote': 'wants-vote'}
    _toPy = {'agent-status': 'agent_status', 'constraints': 'constraints', 'containers': 'containers', 'display-name': 'display_name', 'dns-name': 'dns_name', 'hardware': 'hardware', 'has-vote': 'has_vote', 'id': 'id_', 'instance-id': 'instance_id', 'instance-status': 'instance_status', 'ip-addresses': 'ip_addresses', 'jobs': 'jobs', 'lxd-profiles': 'lxd_profiles', 'modification-status': 'modification_status', 'network-interfaces': 'network_interfaces', 'series': 'series', 'wants-vote': 'wants_vote'}
    def __init__(self, agent_status=None, constraints=None, containers=None, display_name=None, dns_name=None, hardware=None, has_vote=None, id_=None, instance_id=None, instance_status=None, ip_addresses=None, jobs=None, lxd_profiles=None, modification_status=None, network_interfaces=None, series=None, wants_vote=None, **unknown_fields):
        '''
        agent_status : DetailedStatus
        constraints : str
        containers : typing.Mapping[str, ~MachineStatus]
        display_name : str
        dns_name : str
        hardware : str
        has_vote : bool
        id_ : str
        instance_id : str
        instance_status : DetailedStatus
        ip_addresses : typing.Sequence[str]
        jobs : typing.Sequence[str]
        lxd_profiles : typing.Mapping[str, ~LXDProfile]
        modification_status : DetailedStatus
        network_interfaces : typing.Mapping[str, ~NetworkInterface]
        series : str
        wants_vote : bool
        '''
        if agent_status is not None and not isinstance(agent_status, DetailedStatus):
            raise Exception('Expected agent_status to be of type DetailedStatus')

        if constraints is not None and not isinstance(constraints, (bytes, str)):
            raise Exception('Expected constraints to be of type str')

        if containers is not None and not isinstance(containers, dict):
            raise Exception('Expected containers to be of type Mapping')

        if display_name is not None and not isinstance(display_name, (bytes, str)):
            raise Exception('Expected display_name to be of type str')

        if dns_name is not None and not isinstance(dns_name, (bytes, str)):
            raise Exception('Expected dns_name to be of type str')

        if hardware is not None and not isinstance(hardware, (bytes, str)):
            raise Exception('Expected hardware to be of type str')

        if has_vote is not None and not isinstance(has_vote, bool):
            raise Exception('Expected has_vote to be of type bool')

        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        if instance_id is not None and not isinstance(instance_id, (bytes, str)):
            raise Exception('Expected instance_id to be of type str')

        if instance_status is not None and not isinstance(instance_status, DetailedStatus):
            raise Exception('Expected instance_status to be of type DetailedStatus')

        if ip_addresses is not None and not isinstance(ip_addresses, list):
            raise Exception('Expected ip_addresses to be of type Sequence')

        if jobs is not None and not isinstance(jobs, list):
            raise Exception('Expected jobs to be of type Sequence')

        if lxd_profiles is not None and not isinstance(lxd_profiles, dict):
            raise Exception('Expected lxd_profiles to be of type Mapping')

        if modification_status is not None and not isinstance(modification_status, DetailedStatus):
            raise Exception('Expected modification_status to be of type DetailedStatus')

        if network_interfaces is not None and not isinstance(network_interfaces, dict):
            raise Exception('Expected network_interfaces to be of type Mapping')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        if wants_vote is not None and not isinstance(wants_vote, bool):
            raise Exception('Expected wants_vote to be of type bool')

        self.agent_status = DetailedStatus.from_json(agent_status) if agent_status else None
        self.constraints = constraints
        self.containers = containers
        self.display_name = display_name
        self.dns_name = dns_name
        self.hardware = hardware
        self.has_vote = has_vote
        self.id_ = id_
        self.instance_id = instance_id
        self.instance_status = DetailedStatus.from_json(instance_status) if instance_status else None
        self.ip_addresses = ip_addresses
        self.jobs = jobs
        self.lxd_profiles = lxd_profiles
        self.modification_status = DetailedStatus.from_json(modification_status) if modification_status else None
        self.network_interfaces = network_interfaces
        self.series = series
        self.wants_vote = wants_vote
        self.unknown_fields = unknown_fields



class MachineStorageId(Type):
    _toSchema = {'attachment_tag': 'attachment-tag', 'machine_tag': 'machine-tag'}
    _toPy = {'attachment-tag': 'attachment_tag', 'machine-tag': 'machine_tag'}
    def __init__(self, attachment_tag=None, machine_tag=None, **unknown_fields):
        '''
        attachment_tag : str
        machine_tag : str
        '''
        if attachment_tag is not None and not isinstance(attachment_tag, (bytes, str)):
            raise Exception('Expected attachment_tag to be of type str')

        if machine_tag is not None and not isinstance(machine_tag, (bytes, str)):
            raise Exception('Expected machine_tag to be of type str')

        self.attachment_tag = attachment_tag
        self.machine_tag = machine_tag
        self.unknown_fields = unknown_fields



class MachineStorageIds(Type):
    _toSchema = {'ids': 'ids'}
    _toPy = {'ids': 'ids'}
    def __init__(self, ids=None, **unknown_fields):
        '''
        ids : typing.Sequence[~MachineStorageId]
        '''
        if ids is not None and not isinstance(ids, list):
            raise Exception('Expected ids to be of type Sequence')

        self.ids = [MachineStorageId.from_json(o) for o in ids or []]
        self.unknown_fields = unknown_fields



class MachineStorageIdsWatchResult(Type):
    _toSchema = {'changes': 'changes', 'error': 'error', 'watcher_id': 'watcher-id'}
    _toPy = {'changes': 'changes', 'error': 'error', 'watcher-id': 'watcher_id'}
    def __init__(self, changes=None, error=None, watcher_id=None, **unknown_fields):
        '''
        changes : typing.Sequence[~MachineStorageId]
        error : Error
        watcher_id : str
        '''
        if changes is not None and not isinstance(changes, list):
            raise Exception('Expected changes to be of type Sequence')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if watcher_id is not None and not isinstance(watcher_id, (bytes, str)):
            raise Exception('Expected watcher_id to be of type str')

        self.changes = [MachineStorageId.from_json(o) for o in changes or []]
        self.error = Error.from_json(error) if error else None
        self.watcher_id = watcher_id
        self.unknown_fields = unknown_fields



class MachineStorageIdsWatchResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~MachineStorageIdsWatchResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [MachineStorageIdsWatchResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class MapResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : typing.Mapping[str, typing.Any]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, dict):
            raise Exception('Expected result to be of type Mapping')

        self.error = Error.from_json(error) if error else None
        self.result = result
        self.unknown_fields = unknown_fields



class MapResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~MapResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [MapResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class MasterMigrationStatus(Type):
    _toSchema = {'migration_id': 'migration-id', 'phase': 'phase', 'phase_changed_time': 'phase-changed-time', 'spec': 'spec'}
    _toPy = {'migration-id': 'migration_id', 'phase': 'phase', 'phase-changed-time': 'phase_changed_time', 'spec': 'spec'}
    def __init__(self, migration_id=None, phase=None, phase_changed_time=None, spec=None, **unknown_fields):
        '''
        migration_id : str
        phase : str
        phase_changed_time : str
        spec : MigrationSpec
        '''
        if migration_id is not None and not isinstance(migration_id, (bytes, str)):
            raise Exception('Expected migration_id to be of type str')

        if phase is not None and not isinstance(phase, (bytes, str)):
            raise Exception('Expected phase to be of type str')

        if phase_changed_time is not None and not isinstance(phase_changed_time, (bytes, str)):
            raise Exception('Expected phase_changed_time to be of type str')

        if spec is not None and not isinstance(spec, MigrationSpec):
            raise Exception('Expected spec to be of type MigrationSpec')

        self.migration_id = migration_id
        self.phase = phase
        self.phase_changed_time = phase_changed_time
        self.spec = MigrationSpec.from_json(spec) if spec else None
        self.unknown_fields = unknown_fields



class Member(Type):
    _toSchema = {'address': 'Address', 'arbiter': 'Arbiter', 'buildindexes': 'BuildIndexes', 'hidden': 'Hidden', 'id_': 'Id', 'priority': 'Priority', 'slavedelay': 'SlaveDelay', 'tags': 'Tags', 'votes': 'Votes'}
    _toPy = {'Address': 'address', 'Arbiter': 'arbiter', 'BuildIndexes': 'buildindexes', 'Hidden': 'hidden', 'Id': 'id_', 'Priority': 'priority', 'SlaveDelay': 'slavedelay', 'Tags': 'tags', 'Votes': 'votes'}
    def __init__(self, address=None, arbiter=None, buildindexes=None, hidden=None, id_=None, priority=None, slavedelay=None, tags=None, votes=None, **unknown_fields):
        '''
        address : str
        arbiter : bool
        buildindexes : bool
        hidden : bool
        id_ : int
        priority : float
        slavedelay : int
        tags : typing.Mapping[str, str]
        votes : int
        '''
        if address is not None and not isinstance(address, (bytes, str)):
            raise Exception('Expected address to be of type str')

        if arbiter is not None and not isinstance(arbiter, bool):
            raise Exception('Expected arbiter to be of type bool')

        if buildindexes is not None and not isinstance(buildindexes, bool):
            raise Exception('Expected buildindexes to be of type bool')

        if hidden is not None and not isinstance(hidden, bool):
            raise Exception('Expected hidden to be of type bool')

        if id_ is not None and not isinstance(id_, int):
            raise Exception('Expected id_ to be of type int')

        if priority is not None and not isinstance(priority, float):
            raise Exception('Expected priority to be of type float')

        if slavedelay is not None and not isinstance(slavedelay, int):
            raise Exception('Expected slavedelay to be of type int')

        if tags is not None and not isinstance(tags, dict):
            raise Exception('Expected tags to be of type Mapping')

        if votes is not None and not isinstance(votes, int):
            raise Exception('Expected votes to be of type int')

        self.address = address
        self.arbiter = arbiter
        self.buildindexes = buildindexes
        self.hidden = hidden
        self.id_ = id_
        self.priority = priority
        self.slavedelay = slavedelay
        self.tags = tags
        self.votes = votes
        self.unknown_fields = unknown_fields



class MergeLeadershipSettingsBulkParams(Type):
    _toSchema = {'params': 'params'}
    _toPy = {'params': 'params'}
    def __init__(self, params=None, **unknown_fields):
        '''
        params : typing.Sequence[~MergeLeadershipSettingsParam]
        '''
        if params is not None and not isinstance(params, list):
            raise Exception('Expected params to be of type Sequence')

        self.params = [MergeLeadershipSettingsParam.from_json(o) for o in params or []]
        self.unknown_fields = unknown_fields



class MergeLeadershipSettingsParam(Type):
    _toSchema = {'application_tag': 'application-tag', 'settings': 'settings', 'unit_tag': 'unit-tag'}
    _toPy = {'application-tag': 'application_tag', 'settings': 'settings', 'unit-tag': 'unit_tag'}
    def __init__(self, application_tag=None, settings=None, unit_tag=None, **unknown_fields):
        '''
        application_tag : str
        settings : typing.Mapping[str, str]
        unit_tag : str
        '''
        if application_tag is not None and not isinstance(application_tag, (bytes, str)):
            raise Exception('Expected application_tag to be of type str')

        if settings is not None and not isinstance(settings, dict):
            raise Exception('Expected settings to be of type Mapping')

        if unit_tag is not None and not isinstance(unit_tag, (bytes, str)):
            raise Exception('Expected unit_tag to be of type str')

        self.application_tag = application_tag
        self.settings = settings
        self.unit_tag = unit_tag
        self.unknown_fields = unknown_fields



class MetadataImageIds(Type):
    _toSchema = {'image_ids': 'image-ids'}
    _toPy = {'image-ids': 'image_ids'}
    def __init__(self, image_ids=None, **unknown_fields):
        '''
        image_ids : typing.Sequence[str]
        '''
        if image_ids is not None and not isinstance(image_ids, list):
            raise Exception('Expected image_ids to be of type Sequence')

        self.image_ids = image_ids
        self.unknown_fields = unknown_fields



class MetadataSaveParams(Type):
    _toSchema = {'metadata': 'metadata'}
    _toPy = {'metadata': 'metadata'}
    def __init__(self, metadata=None, **unknown_fields):
        '''
        metadata : typing.Sequence[~CloudImageMetadataList]
        '''
        if metadata is not None and not isinstance(metadata, list):
            raise Exception('Expected metadata to be of type Sequence')

        self.metadata = [CloudImageMetadataList.from_json(o) for o in metadata or []]
        self.unknown_fields = unknown_fields



class MeterStatus(Type):
    _toSchema = {'color': 'color', 'message': 'message'}
    _toPy = {'color': 'color', 'message': 'message'}
    def __init__(self, color=None, message=None, **unknown_fields):
        '''
        color : str
        message : str
        '''
        if color is not None and not isinstance(color, (bytes, str)):
            raise Exception('Expected color to be of type str')

        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        self.color = color
        self.message = message
        self.unknown_fields = unknown_fields



class MeterStatusParam(Type):
    _toSchema = {'code': 'code', 'info': 'info', 'tag': 'tag'}
    _toPy = {'code': 'code', 'info': 'info', 'tag': 'tag'}
    def __init__(self, code=None, info=None, tag=None, **unknown_fields):
        '''
        code : str
        info : str
        tag : str
        '''
        if code is not None and not isinstance(code, (bytes, str)):
            raise Exception('Expected code to be of type str')

        if info is not None and not isinstance(info, (bytes, str)):
            raise Exception('Expected info to be of type str')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.code = code
        self.info = info
        self.tag = tag
        self.unknown_fields = unknown_fields



class MeterStatusParams(Type):
    _toSchema = {'statues': 'statues'}
    _toPy = {'statues': 'statues'}
    def __init__(self, statues=None, **unknown_fields):
        '''
        statues : typing.Sequence[~MeterStatusParam]
        '''
        if statues is not None and not isinstance(statues, list):
            raise Exception('Expected statues to be of type Sequence')

        self.statues = [MeterStatusParam.from_json(o) for o in statues or []]
        self.unknown_fields = unknown_fields



class MeterStatusResult(Type):
    _toSchema = {'code': 'code', 'error': 'error', 'info': 'info'}
    _toPy = {'code': 'code', 'error': 'error', 'info': 'info'}
    def __init__(self, code=None, error=None, info=None, **unknown_fields):
        '''
        code : str
        error : Error
        info : str
        '''
        if code is not None and not isinstance(code, (bytes, str)):
            raise Exception('Expected code to be of type str')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if info is not None and not isinstance(info, (bytes, str)):
            raise Exception('Expected info to be of type str')

        self.code = code
        self.error = Error.from_json(error) if error else None
        self.info = info
        self.unknown_fields = unknown_fields



class MeterStatusResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~MeterStatusResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [MeterStatusResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class Metric(Type):
    _toSchema = {'key': 'key', 'labels': 'labels', 'time': 'time', 'value': 'value'}
    _toPy = {'key': 'key', 'labels': 'labels', 'time': 'time', 'value': 'value'}
    def __init__(self, key=None, labels=None, time=None, value=None, **unknown_fields):
        '''
        key : str
        labels : typing.Mapping[str, str]
        time : str
        value : str
        '''
        if key is not None and not isinstance(key, (bytes, str)):
            raise Exception('Expected key to be of type str')

        if labels is not None and not isinstance(labels, dict):
            raise Exception('Expected labels to be of type Mapping')

        if time is not None and not isinstance(time, (bytes, str)):
            raise Exception('Expected time to be of type str')

        if value is not None and not isinstance(value, (bytes, str)):
            raise Exception('Expected value to be of type str')

        self.key = key
        self.labels = labels
        self.time = time
        self.value = value
        self.unknown_fields = unknown_fields



class MetricBatch(Type):
    _toSchema = {'charm_url': 'charm-url', 'created': 'created', 'metrics': 'metrics', 'uuid': 'uuid'}
    _toPy = {'charm-url': 'charm_url', 'created': 'created', 'metrics': 'metrics', 'uuid': 'uuid'}
    def __init__(self, charm_url=None, created=None, metrics=None, uuid=None, **unknown_fields):
        '''
        charm_url : str
        created : str
        metrics : typing.Sequence[~Metric]
        uuid : str
        '''
        if charm_url is not None and not isinstance(charm_url, (bytes, str)):
            raise Exception('Expected charm_url to be of type str')

        if created is not None and not isinstance(created, (bytes, str)):
            raise Exception('Expected created to be of type str')

        if metrics is not None and not isinstance(metrics, list):
            raise Exception('Expected metrics to be of type Sequence')

        if uuid is not None and not isinstance(uuid, (bytes, str)):
            raise Exception('Expected uuid to be of type str')

        self.charm_url = charm_url
        self.created = created
        self.metrics = [Metric.from_json(o) for o in metrics or []]
        self.uuid = uuid
        self.unknown_fields = unknown_fields



class MetricBatchParam(Type):
    _toSchema = {'batch': 'batch', 'tag': 'tag'}
    _toPy = {'batch': 'batch', 'tag': 'tag'}
    def __init__(self, batch=None, tag=None, **unknown_fields):
        '''
        batch : MetricBatch
        tag : str
        '''
        if batch is not None and not isinstance(batch, MetricBatch):
            raise Exception('Expected batch to be of type MetricBatch')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.batch = MetricBatch.from_json(batch) if batch else None
        self.tag = tag
        self.unknown_fields = unknown_fields



class MetricBatchParams(Type):
    _toSchema = {'batches': 'batches'}
    _toPy = {'batches': 'batches'}
    def __init__(self, batches=None, **unknown_fields):
        '''
        batches : typing.Sequence[~MetricBatchParam]
        '''
        if batches is not None and not isinstance(batches, list):
            raise Exception('Expected batches to be of type Sequence')

        self.batches = [MetricBatchParam.from_json(o) for o in batches or []]
        self.unknown_fields = unknown_fields



class MetricResult(Type):
    _toSchema = {'key': 'key', 'labels': 'labels', 'time': 'time', 'unit': 'unit', 'value': 'value'}
    _toPy = {'key': 'key', 'labels': 'labels', 'time': 'time', 'unit': 'unit', 'value': 'value'}
    def __init__(self, key=None, labels=None, time=None, unit=None, value=None, **unknown_fields):
        '''
        key : str
        labels : typing.Mapping[str, str]
        time : str
        unit : str
        value : str
        '''
        if key is not None and not isinstance(key, (bytes, str)):
            raise Exception('Expected key to be of type str')

        if labels is not None and not isinstance(labels, dict):
            raise Exception('Expected labels to be of type Mapping')

        if time is not None and not isinstance(time, (bytes, str)):
            raise Exception('Expected time to be of type str')

        if unit is not None and not isinstance(unit, (bytes, str)):
            raise Exception('Expected unit to be of type str')

        if value is not None and not isinstance(value, (bytes, str)):
            raise Exception('Expected value to be of type str')

        self.key = key
        self.labels = labels
        self.time = time
        self.unit = unit
        self.value = value
        self.unknown_fields = unknown_fields



class MetricResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~EntityMetrics]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [EntityMetrics.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class MigrationModelInfo(Type):
    _toSchema = {'agent_version': 'agent-version', 'controller_agent_version': 'controller-agent-version', 'name': 'name', 'owner_tag': 'owner-tag', 'uuid': 'uuid'}
    _toPy = {'agent-version': 'agent_version', 'controller-agent-version': 'controller_agent_version', 'name': 'name', 'owner-tag': 'owner_tag', 'uuid': 'uuid'}
    def __init__(self, agent_version=None, controller_agent_version=None, name=None, owner_tag=None, uuid=None, **unknown_fields):
        '''
        agent_version : Number
        controller_agent_version : Number
        name : str
        owner_tag : str
        uuid : str
        '''
        if agent_version is not None and not isinstance(agent_version, Number):
            raise Exception('Expected agent_version to be of type Number')

        if controller_agent_version is not None and not isinstance(controller_agent_version, Number):
            raise Exception('Expected controller_agent_version to be of type Number')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if owner_tag is not None and not isinstance(owner_tag, (bytes, str)):
            raise Exception('Expected owner_tag to be of type str')

        if uuid is not None and not isinstance(uuid, (bytes, str)):
            raise Exception('Expected uuid to be of type str')

        self.agent_version = Number.from_json(agent_version) if agent_version else None
        self.controller_agent_version = Number.from_json(controller_agent_version) if controller_agent_version else None
        self.name = name
        self.owner_tag = owner_tag
        self.uuid = uuid
        self.unknown_fields = unknown_fields



class MigrationSpec(Type):
    _toSchema = {'model_tag': 'model-tag', 'target_info': 'target-info'}
    _toPy = {'model-tag': 'model_tag', 'target-info': 'target_info'}
    def __init__(self, model_tag=None, target_info=None, **unknown_fields):
        '''
        model_tag : str
        target_info : MigrationTargetInfo
        '''
        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception('Expected model_tag to be of type str')

        if target_info is not None and not isinstance(target_info, MigrationTargetInfo):
            raise Exception('Expected target_info to be of type MigrationTargetInfo')

        self.model_tag = model_tag
        self.target_info = MigrationTargetInfo.from_json(target_info) if target_info else None
        self.unknown_fields = unknown_fields



class MigrationStatus(Type):
    _toSchema = {'attempt': 'attempt', 'migration_id': 'migration-id', 'phase': 'phase', 'source_api_addrs': 'source-api-addrs', 'source_ca_cert': 'source-ca-cert', 'target_api_addrs': 'target-api-addrs', 'target_ca_cert': 'target-ca-cert'}
    _toPy = {'attempt': 'attempt', 'migration-id': 'migration_id', 'phase': 'phase', 'source-api-addrs': 'source_api_addrs', 'source-ca-cert': 'source_ca_cert', 'target-api-addrs': 'target_api_addrs', 'target-ca-cert': 'target_ca_cert'}
    def __init__(self, attempt=None, migration_id=None, phase=None, source_api_addrs=None, source_ca_cert=None, target_api_addrs=None, target_ca_cert=None, **unknown_fields):
        '''
        attempt : int
        migration_id : str
        phase : str
        source_api_addrs : typing.Sequence[str]
        source_ca_cert : str
        target_api_addrs : typing.Sequence[str]
        target_ca_cert : str
        '''
        if attempt is not None and not isinstance(attempt, int):
            raise Exception('Expected attempt to be of type int')

        if migration_id is not None and not isinstance(migration_id, (bytes, str)):
            raise Exception('Expected migration_id to be of type str')

        if phase is not None and not isinstance(phase, (bytes, str)):
            raise Exception('Expected phase to be of type str')

        if source_api_addrs is not None and not isinstance(source_api_addrs, list):
            raise Exception('Expected source_api_addrs to be of type Sequence')

        if source_ca_cert is not None and not isinstance(source_ca_cert, (bytes, str)):
            raise Exception('Expected source_ca_cert to be of type str')

        if target_api_addrs is not None and not isinstance(target_api_addrs, list):
            raise Exception('Expected target_api_addrs to be of type Sequence')

        if target_ca_cert is not None and not isinstance(target_ca_cert, (bytes, str)):
            raise Exception('Expected target_ca_cert to be of type str')

        self.attempt = attempt
        self.migration_id = migration_id
        self.phase = phase
        self.source_api_addrs = source_api_addrs
        self.source_ca_cert = source_ca_cert
        self.target_api_addrs = target_api_addrs
        self.target_ca_cert = target_ca_cert
        self.unknown_fields = unknown_fields



class MigrationTargetInfo(Type):
    _toSchema = {'addrs': 'addrs', 'auth_tag': 'auth-tag', 'ca_cert': 'ca-cert', 'controller_alias': 'controller-alias', 'controller_tag': 'controller-tag', 'macaroons': 'macaroons', 'password': 'password'}
    _toPy = {'addrs': 'addrs', 'auth-tag': 'auth_tag', 'ca-cert': 'ca_cert', 'controller-alias': 'controller_alias', 'controller-tag': 'controller_tag', 'macaroons': 'macaroons', 'password': 'password'}
    def __init__(self, addrs=None, auth_tag=None, ca_cert=None, controller_alias=None, controller_tag=None, macaroons=None, password=None, **unknown_fields):
        '''
        addrs : typing.Sequence[str]
        auth_tag : str
        ca_cert : str
        controller_alias : str
        controller_tag : str
        macaroons : str
        password : str
        '''
        if addrs is not None and not isinstance(addrs, list):
            raise Exception('Expected addrs to be of type Sequence')

        if auth_tag is not None and not isinstance(auth_tag, (bytes, str)):
            raise Exception('Expected auth_tag to be of type str')

        if ca_cert is not None and not isinstance(ca_cert, (bytes, str)):
            raise Exception('Expected ca_cert to be of type str')

        if controller_alias is not None and not isinstance(controller_alias, (bytes, str)):
            raise Exception('Expected controller_alias to be of type str')

        if controller_tag is not None and not isinstance(controller_tag, (bytes, str)):
            raise Exception('Expected controller_tag to be of type str')

        if macaroons is not None and not isinstance(macaroons, (bytes, str)):
            raise Exception('Expected macaroons to be of type str')

        if password is not None and not isinstance(password, (bytes, str)):
            raise Exception('Expected password to be of type str')

        self.addrs = addrs
        self.auth_tag = auth_tag
        self.ca_cert = ca_cert
        self.controller_alias = controller_alias
        self.controller_tag = controller_tag
        self.macaroons = macaroons
        self.password = password
        self.unknown_fields = unknown_fields



class MinionReport(Type):
    _toSchema = {'migration_id': 'migration-id', 'phase': 'phase', 'success': 'success'}
    _toPy = {'migration-id': 'migration_id', 'phase': 'phase', 'success': 'success'}
    def __init__(self, migration_id=None, phase=None, success=None, **unknown_fields):
        '''
        migration_id : str
        phase : str
        success : bool
        '''
        if migration_id is not None and not isinstance(migration_id, (bytes, str)):
            raise Exception('Expected migration_id to be of type str')

        if phase is not None and not isinstance(phase, (bytes, str)):
            raise Exception('Expected phase to be of type str')

        if success is not None and not isinstance(success, bool):
            raise Exception('Expected success to be of type bool')

        self.migration_id = migration_id
        self.phase = phase
        self.success = success
        self.unknown_fields = unknown_fields



class MinionReports(Type):
    _toSchema = {'failed': 'failed', 'migration_id': 'migration-id', 'phase': 'phase', 'success_count': 'success-count', 'unknown_count': 'unknown-count', 'unknown_sample': 'unknown-sample'}
    _toPy = {'failed': 'failed', 'migration-id': 'migration_id', 'phase': 'phase', 'success-count': 'success_count', 'unknown-count': 'unknown_count', 'unknown-sample': 'unknown_sample'}
    def __init__(self, failed=None, migration_id=None, phase=None, success_count=None, unknown_count=None, unknown_sample=None, **unknown_fields):
        '''
        failed : typing.Sequence[str]
        migration_id : str
        phase : str
        success_count : int
        unknown_count : int
        unknown_sample : typing.Sequence[str]
        '''
        if failed is not None and not isinstance(failed, list):
            raise Exception('Expected failed to be of type Sequence')

        if migration_id is not None and not isinstance(migration_id, (bytes, str)):
            raise Exception('Expected migration_id to be of type str')

        if phase is not None and not isinstance(phase, (bytes, str)):
            raise Exception('Expected phase to be of type str')

        if success_count is not None and not isinstance(success_count, int):
            raise Exception('Expected success_count to be of type int')

        if unknown_count is not None and not isinstance(unknown_count, int):
            raise Exception('Expected unknown_count to be of type int')

        if unknown_sample is not None and not isinstance(unknown_sample, list):
            raise Exception('Expected unknown_sample to be of type Sequence')

        self.failed = failed
        self.migration_id = migration_id
        self.phase = phase
        self.success_count = success_count
        self.unknown_count = unknown_count
        self.unknown_sample = unknown_sample
        self.unknown_fields = unknown_fields



class Model(Type):
    _toSchema = {'name': 'name', 'owner_tag': 'owner-tag', 'type_': 'type', 'uuid': 'uuid'}
    _toPy = {'name': 'name', 'owner-tag': 'owner_tag', 'type': 'type_', 'uuid': 'uuid'}
    def __init__(self, name=None, owner_tag=None, type_=None, uuid=None, **unknown_fields):
        '''
        name : str
        owner_tag : str
        type_ : str
        uuid : str
        '''
        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if owner_tag is not None and not isinstance(owner_tag, (bytes, str)):
            raise Exception('Expected owner_tag to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        if uuid is not None and not isinstance(uuid, (bytes, str)):
            raise Exception('Expected uuid to be of type str')

        self.name = name
        self.owner_tag = owner_tag
        self.type_ = type_
        self.uuid = uuid
        self.unknown_fields = unknown_fields



class ModelAccess(Type):
    _toSchema = {'access': 'access', 'model': 'model'}
    _toPy = {'access': 'access', 'model': 'model'}
    def __init__(self, access=None, model=None, **unknown_fields):
        '''
        access : str
        model : str
        '''
        if access is not None and not isinstance(access, (bytes, str)):
            raise Exception('Expected access to be of type str')

        if model is not None and not isinstance(model, (bytes, str)):
            raise Exception('Expected model to be of type str')

        self.access = access
        self.model = model
        self.unknown_fields = unknown_fields



class ModelArgs(Type):
    _toSchema = {'model_tag': 'model-tag'}
    _toPy = {'model-tag': 'model_tag'}
    def __init__(self, model_tag=None, **unknown_fields):
        '''
        model_tag : str
        '''
        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception('Expected model_tag to be of type str')

        self.model_tag = model_tag
        self.unknown_fields = unknown_fields



class ModelBlockInfo(Type):
    _toSchema = {'blocks': 'blocks', 'model_uuid': 'model-uuid', 'name': 'name', 'owner_tag': 'owner-tag'}
    _toPy = {'blocks': 'blocks', 'model-uuid': 'model_uuid', 'name': 'name', 'owner-tag': 'owner_tag'}
    def __init__(self, blocks=None, model_uuid=None, name=None, owner_tag=None, **unknown_fields):
        '''
        blocks : typing.Sequence[str]
        model_uuid : str
        name : str
        owner_tag : str
        '''
        if blocks is not None and not isinstance(blocks, list):
            raise Exception('Expected blocks to be of type Sequence')

        if model_uuid is not None and not isinstance(model_uuid, (bytes, str)):
            raise Exception('Expected model_uuid to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if owner_tag is not None and not isinstance(owner_tag, (bytes, str)):
            raise Exception('Expected owner_tag to be of type str')

        self.blocks = blocks
        self.model_uuid = model_uuid
        self.name = name
        self.owner_tag = owner_tag
        self.unknown_fields = unknown_fields



class ModelBlockInfoList(Type):
    _toSchema = {'models': 'models'}
    _toPy = {'models': 'models'}
    def __init__(self, models=None, **unknown_fields):
        '''
        models : typing.Sequence[~ModelBlockInfo]
        '''
        if models is not None and not isinstance(models, list):
            raise Exception('Expected models to be of type Sequence')

        self.models = [ModelBlockInfo.from_json(o) for o in models or []]
        self.unknown_fields = unknown_fields



class ModelConfigResult(Type):
    _toSchema = {'config': 'config'}
    _toPy = {'config': 'config'}
    def __init__(self, config=None, **unknown_fields):
        '''
        config : typing.Mapping[str, typing.Any]
        '''
        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        self.config = config
        self.unknown_fields = unknown_fields



class ModelConfigResults(Type):
    _toSchema = {'config': 'config'}
    _toPy = {'config': 'config'}
    def __init__(self, config=None, **unknown_fields):
        '''
        config : typing.Mapping[str, ~ConfigValue]
        '''
        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        self.config = config
        self.unknown_fields = unknown_fields



class ModelCreateArgs(Type):
    _toSchema = {'cloud_tag': 'cloud-tag', 'config': 'config', 'credential': 'credential', 'name': 'name', 'owner_tag': 'owner-tag', 'region': 'region'}
    _toPy = {'cloud-tag': 'cloud_tag', 'config': 'config', 'credential': 'credential', 'name': 'name', 'owner-tag': 'owner_tag', 'region': 'region'}
    def __init__(self, cloud_tag=None, config=None, credential=None, name=None, owner_tag=None, region=None, **unknown_fields):
        '''
        cloud_tag : str
        config : typing.Mapping[str, typing.Any]
        credential : str
        name : str
        owner_tag : str
        region : str
        '''
        if cloud_tag is not None and not isinstance(cloud_tag, (bytes, str)):
            raise Exception('Expected cloud_tag to be of type str')

        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        if credential is not None and not isinstance(credential, (bytes, str)):
            raise Exception('Expected credential to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if owner_tag is not None and not isinstance(owner_tag, (bytes, str)):
            raise Exception('Expected owner_tag to be of type str')

        if region is not None and not isinstance(region, (bytes, str)):
            raise Exception('Expected region to be of type str')

        self.cloud_tag = cloud_tag
        self.config = config
        self.credential = credential
        self.name = name
        self.owner_tag = owner_tag
        self.region = region
        self.unknown_fields = unknown_fields



class ModelCredential(Type):
    _toSchema = {'credential_tag': 'credential-tag', 'exists': 'exists', 'model_tag': 'model-tag', 'valid': 'valid'}
    _toPy = {'credential-tag': 'credential_tag', 'exists': 'exists', 'model-tag': 'model_tag', 'valid': 'valid'}
    def __init__(self, credential_tag=None, exists=None, model_tag=None, valid=None, **unknown_fields):
        '''
        credential_tag : str
        exists : bool
        model_tag : str
        valid : bool
        '''
        if credential_tag is not None and not isinstance(credential_tag, (bytes, str)):
            raise Exception('Expected credential_tag to be of type str')

        if exists is not None and not isinstance(exists, bool):
            raise Exception('Expected exists to be of type bool')

        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception('Expected model_tag to be of type str')

        if valid is not None and not isinstance(valid, bool):
            raise Exception('Expected valid to be of type bool')

        self.credential_tag = credential_tag
        self.exists = exists
        self.model_tag = model_tag
        self.valid = valid
        self.unknown_fields = unknown_fields



class ModelDefaultValues(Type):
    _toSchema = {'cloud_region': 'cloud-region', 'cloud_tag': 'cloud-tag', 'config': 'config'}
    _toPy = {'cloud-region': 'cloud_region', 'cloud-tag': 'cloud_tag', 'config': 'config'}
    def __init__(self, cloud_region=None, cloud_tag=None, config=None, **unknown_fields):
        '''
        cloud_region : str
        cloud_tag : str
        config : typing.Mapping[str, typing.Any]
        '''
        if cloud_region is not None and not isinstance(cloud_region, (bytes, str)):
            raise Exception('Expected cloud_region to be of type str')

        if cloud_tag is not None and not isinstance(cloud_tag, (bytes, str)):
            raise Exception('Expected cloud_tag to be of type str')

        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        self.cloud_region = cloud_region
        self.cloud_tag = cloud_tag
        self.config = config
        self.unknown_fields = unknown_fields



class ModelDefaults(Type):
    _toSchema = {'controller': 'controller', 'default': 'default', 'regions': 'regions'}
    _toPy = {'controller': 'controller', 'default': 'default', 'regions': 'regions'}
    def __init__(self, controller=None, default=None, regions=None, **unknown_fields):
        '''
        controller : typing.Mapping[str, typing.Any]
        default : typing.Mapping[str, typing.Any]
        regions : typing.Sequence[~RegionDefaults]
        '''
        if controller is not None and not isinstance(controller, dict):
            raise Exception('Expected controller to be of type Mapping')

        if default is not None and not isinstance(default, dict):
            raise Exception('Expected default to be of type Mapping')

        if regions is not None and not isinstance(regions, list):
            raise Exception('Expected regions to be of type Sequence')

        self.controller = controller
        self.default = default
        self.regions = [RegionDefaults.from_json(o) for o in regions or []]
        self.unknown_fields = unknown_fields



class ModelDefaultsResult(Type):
    _toSchema = {'config': 'config', 'error': 'error'}
    _toPy = {'config': 'config', 'error': 'error'}
    def __init__(self, config=None, error=None, **unknown_fields):
        '''
        config : typing.Mapping[str, ~ModelDefaults]
        error : Error
        '''
        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.config = config
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class ModelDefaultsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ModelDefaultsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ModelDefaultsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ModelEntityCount(Type):
    _toSchema = {'count': 'count', 'entity': 'entity'}
    _toPy = {'count': 'count', 'entity': 'entity'}
    def __init__(self, count=None, entity=None, **unknown_fields):
        '''
        count : int
        entity : str
        '''
        if count is not None and not isinstance(count, int):
            raise Exception('Expected count to be of type int')

        if entity is not None and not isinstance(entity, (bytes, str)):
            raise Exception('Expected entity to be of type str')

        self.count = count
        self.entity = entity
        self.unknown_fields = unknown_fields



class ModelFilesystemInfo(Type):
    _toSchema = {'detachable': 'detachable', 'id_': 'id', 'message': 'message', 'provider_id': 'provider-id', 'status': 'status'}
    _toPy = {'detachable': 'detachable', 'id': 'id_', 'message': 'message', 'provider-id': 'provider_id', 'status': 'status'}
    def __init__(self, detachable=None, id_=None, message=None, provider_id=None, status=None, **unknown_fields):
        '''
        detachable : bool
        id_ : str
        message : str
        provider_id : str
        status : str
        '''
        if detachable is not None and not isinstance(detachable, bool):
            raise Exception('Expected detachable to be of type bool')

        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        if provider_id is not None and not isinstance(provider_id, (bytes, str)):
            raise Exception('Expected provider_id to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        self.detachable = detachable
        self.id_ = id_
        self.message = message
        self.provider_id = provider_id
        self.status = status
        self.unknown_fields = unknown_fields



class ModelInfo(Type):
    _toSchema = {'agent_version': 'agent-version', 'cloud_credential_tag': 'cloud-credential-tag', 'cloud_region': 'cloud-region', 'cloud_tag': 'cloud-tag', 'controller_uuid': 'controller-uuid', 'default_series': 'default-series', 'is_controller': 'is-controller', 'life': 'life', 'machines': 'machines', 'migration': 'migration', 'name': 'name', 'owner_tag': 'owner-tag', 'provider_type': 'provider-type', 'sla': 'sla', 'status': 'status', 'type_': 'type', 'users': 'users', 'uuid': 'uuid'}
    _toPy = {'agent-version': 'agent_version', 'cloud-credential-tag': 'cloud_credential_tag', 'cloud-region': 'cloud_region', 'cloud-tag': 'cloud_tag', 'controller-uuid': 'controller_uuid', 'default-series': 'default_series', 'is-controller': 'is_controller', 'life': 'life', 'machines': 'machines', 'migration': 'migration', 'name': 'name', 'owner-tag': 'owner_tag', 'provider-type': 'provider_type', 'sla': 'sla', 'status': 'status', 'type': 'type_', 'users': 'users', 'uuid': 'uuid'}
    def __init__(self, agent_version=None, cloud_credential_tag=None, cloud_region=None, cloud_tag=None, controller_uuid=None, default_series=None, is_controller=None, life=None, machines=None, migration=None, name=None, owner_tag=None, provider_type=None, sla=None, status=None, type_=None, users=None, uuid=None, **unknown_fields):
        '''
        agent_version : Number
        cloud_credential_tag : str
        cloud_region : str
        cloud_tag : str
        controller_uuid : str
        default_series : str
        is_controller : bool
        life : str
        machines : typing.Sequence[~ModelMachineInfo]
        migration : ModelMigrationStatus
        name : str
        owner_tag : str
        provider_type : str
        sla : ModelSLAInfo
        status : EntityStatus
        type_ : str
        users : typing.Sequence[~ModelUserInfo]
        uuid : str
        '''
        if agent_version is not None and not isinstance(agent_version, Number):
            raise Exception('Expected agent_version to be of type Number')

        if cloud_credential_tag is not None and not isinstance(cloud_credential_tag, (bytes, str)):
            raise Exception('Expected cloud_credential_tag to be of type str')

        if cloud_region is not None and not isinstance(cloud_region, (bytes, str)):
            raise Exception('Expected cloud_region to be of type str')

        if cloud_tag is not None and not isinstance(cloud_tag, (bytes, str)):
            raise Exception('Expected cloud_tag to be of type str')

        if controller_uuid is not None and not isinstance(controller_uuid, (bytes, str)):
            raise Exception('Expected controller_uuid to be of type str')

        if default_series is not None and not isinstance(default_series, (bytes, str)):
            raise Exception('Expected default_series to be of type str')

        if is_controller is not None and not isinstance(is_controller, bool):
            raise Exception('Expected is_controller to be of type bool')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if machines is not None and not isinstance(machines, list):
            raise Exception('Expected machines to be of type Sequence')

        if migration is not None and not isinstance(migration, ModelMigrationStatus):
            raise Exception('Expected migration to be of type ModelMigrationStatus')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if owner_tag is not None and not isinstance(owner_tag, (bytes, str)):
            raise Exception('Expected owner_tag to be of type str')

        if provider_type is not None and not isinstance(provider_type, (bytes, str)):
            raise Exception('Expected provider_type to be of type str')

        if sla is not None and not isinstance(sla, ModelSLAInfo):
            raise Exception('Expected sla to be of type ModelSLAInfo')

        if status is not None and not isinstance(status, EntityStatus):
            raise Exception('Expected status to be of type EntityStatus')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        if users is not None and not isinstance(users, list):
            raise Exception('Expected users to be of type Sequence')

        if uuid is not None and not isinstance(uuid, (bytes, str)):
            raise Exception('Expected uuid to be of type str')

        self.agent_version = Number.from_json(agent_version) if agent_version else None
        self.cloud_credential_tag = cloud_credential_tag
        self.cloud_region = cloud_region
        self.cloud_tag = cloud_tag
        self.controller_uuid = controller_uuid
        self.default_series = default_series
        self.is_controller = is_controller
        self.life = life
        self.machines = [ModelMachineInfo.from_json(o) for o in machines or []]
        self.migration = ModelMigrationStatus.from_json(migration) if migration else None
        self.name = name
        self.owner_tag = owner_tag
        self.provider_type = provider_type
        self.sla = ModelSLAInfo.from_json(sla) if sla else None
        self.status = EntityStatus.from_json(status) if status else None
        self.type_ = type_
        self.users = [ModelUserInfo.from_json(o) for o in users or []]
        self.uuid = uuid
        self.unknown_fields = unknown_fields



class ModelInfoResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : ModelInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, ModelInfo):
            raise Exception('Expected result to be of type ModelInfo')

        self.error = Error.from_json(error) if error else None
        self.result = ModelInfo.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class ModelInfoResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ModelInfoResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ModelInfoResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ModelInstanceTypesConstraint(Type):
    _toSchema = {'value': 'value'}
    _toPy = {'value': 'value'}
    def __init__(self, value=None, **unknown_fields):
        '''
        value : Value
        '''
        if value is not None and not isinstance(value, Value):
            raise Exception('Expected value to be of type Value')

        self.value = Value.from_json(value) if value else None
        self.unknown_fields = unknown_fields



class ModelInstanceTypesConstraints(Type):
    _toSchema = {'constraints': 'constraints'}
    _toPy = {'constraints': 'constraints'}
    def __init__(self, constraints=None, **unknown_fields):
        '''
        constraints : typing.Sequence[~ModelInstanceTypesConstraint]
        '''
        if constraints is not None and not isinstance(constraints, list):
            raise Exception('Expected constraints to be of type Sequence')

        self.constraints = [ModelInstanceTypesConstraint.from_json(o) for o in constraints or []]
        self.unknown_fields = unknown_fields



class ModelMachineInfo(Type):
    _toSchema = {'display_name': 'display-name', 'hardware': 'hardware', 'has_vote': 'has-vote', 'id_': 'id', 'instance_id': 'instance-id', 'message': 'message', 'status': 'status', 'wants_vote': 'wants-vote'}
    _toPy = {'display-name': 'display_name', 'hardware': 'hardware', 'has-vote': 'has_vote', 'id': 'id_', 'instance-id': 'instance_id', 'message': 'message', 'status': 'status', 'wants-vote': 'wants_vote'}
    def __init__(self, display_name=None, hardware=None, has_vote=None, id_=None, instance_id=None, message=None, status=None, wants_vote=None, **unknown_fields):
        '''
        display_name : str
        hardware : MachineHardware
        has_vote : bool
        id_ : str
        instance_id : str
        message : str
        status : str
        wants_vote : bool
        '''
        if display_name is not None and not isinstance(display_name, (bytes, str)):
            raise Exception('Expected display_name to be of type str')

        if hardware is not None and not isinstance(hardware, MachineHardware):
            raise Exception('Expected hardware to be of type MachineHardware')

        if has_vote is not None and not isinstance(has_vote, bool):
            raise Exception('Expected has_vote to be of type bool')

        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        if instance_id is not None and not isinstance(instance_id, (bytes, str)):
            raise Exception('Expected instance_id to be of type str')

        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        if wants_vote is not None and not isinstance(wants_vote, bool):
            raise Exception('Expected wants_vote to be of type bool')

        self.display_name = display_name
        self.hardware = MachineHardware.from_json(hardware) if hardware else None
        self.has_vote = has_vote
        self.id_ = id_
        self.instance_id = instance_id
        self.message = message
        self.status = status
        self.wants_vote = wants_vote
        self.unknown_fields = unknown_fields



class ModelMigrationStatus(Type):
    _toSchema = {'end': 'end', 'start': 'start', 'status': 'status'}
    _toPy = {'end': 'end', 'start': 'start', 'status': 'status'}
    def __init__(self, end=None, start=None, status=None, **unknown_fields):
        '''
        end : str
        start : str
        status : str
        '''
        if end is not None and not isinstance(end, (bytes, str)):
            raise Exception('Expected end to be of type str')

        if start is not None and not isinstance(start, (bytes, str)):
            raise Exception('Expected start to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        self.end = end
        self.start = start
        self.status = status
        self.unknown_fields = unknown_fields



class ModelResult(Type):
    _toSchema = {'error': 'error', 'name': 'name', 'type_': 'type', 'uuid': 'uuid'}
    _toPy = {'error': 'error', 'name': 'name', 'type': 'type_', 'uuid': 'uuid'}
    def __init__(self, error=None, name=None, type_=None, uuid=None, **unknown_fields):
        '''
        error : Error
        name : str
        type_ : str
        uuid : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        if uuid is not None and not isinstance(uuid, (bytes, str)):
            raise Exception('Expected uuid to be of type str')

        self.error = Error.from_json(error) if error else None
        self.name = name
        self.type_ = type_
        self.uuid = uuid
        self.unknown_fields = unknown_fields



class ModelSLA(Type):
    _toSchema = {'creds': 'creds', 'level': 'level', 'modelslainfo': 'ModelSLAInfo', 'owner': 'owner'}
    _toPy = {'ModelSLAInfo': 'modelslainfo', 'creds': 'creds', 'level': 'level', 'owner': 'owner'}
    def __init__(self, modelslainfo=None, creds=None, level=None, owner=None, **unknown_fields):
        '''
        modelslainfo : ModelSLAInfo
        creds : typing.Sequence[int]
        level : str
        owner : str
        '''
        if modelslainfo is not None and not isinstance(modelslainfo, ModelSLAInfo):
            raise Exception('Expected modelslainfo to be of type ModelSLAInfo')

        if creds is not None and not isinstance(creds, list):
            raise Exception('Expected creds to be of type Sequence')

        if level is not None and not isinstance(level, (bytes, str)):
            raise Exception('Expected level to be of type str')

        if owner is not None and not isinstance(owner, (bytes, str)):
            raise Exception('Expected owner to be of type str')

        self.modelslainfo = ModelSLAInfo.from_json(modelslainfo) if modelslainfo else None
        self.creds = creds
        self.level = level
        self.owner = owner
        self.unknown_fields = unknown_fields



class ModelSLAInfo(Type):
    _toSchema = {'level': 'level', 'owner': 'owner'}
    _toPy = {'level': 'level', 'owner': 'owner'}
    def __init__(self, level=None, owner=None, **unknown_fields):
        '''
        level : str
        owner : str
        '''
        if level is not None and not isinstance(level, (bytes, str)):
            raise Exception('Expected level to be of type str')

        if owner is not None and not isinstance(owner, (bytes, str)):
            raise Exception('Expected owner to be of type str')

        self.level = level
        self.owner = owner
        self.unknown_fields = unknown_fields



class ModelSequencesResult(Type):
    _toSchema = {'sequences': 'sequences'}
    _toPy = {'sequences': 'sequences'}
    def __init__(self, sequences=None, **unknown_fields):
        '''
        sequences : typing.Mapping[str, int]
        '''
        if sequences is not None and not isinstance(sequences, dict):
            raise Exception('Expected sequences to be of type Mapping')

        self.sequences = sequences
        self.unknown_fields = unknown_fields



class ModelSet(Type):
    _toSchema = {'config': 'config'}
    _toPy = {'config': 'config'}
    def __init__(self, config=None, **unknown_fields):
        '''
        config : typing.Mapping[str, typing.Any]
        '''
        if config is not None and not isinstance(config, dict):
            raise Exception('Expected config to be of type Mapping')

        self.config = config
        self.unknown_fields = unknown_fields



class ModelStatus(Type):
    _toSchema = {'application_count': 'application-count', 'error': 'error', 'filesystems': 'filesystems', 'hosted_machine_count': 'hosted-machine-count', 'life': 'life', 'machines': 'machines', 'model_tag': 'model-tag', 'owner_tag': 'owner-tag', 'type_': 'type', 'unit_count': 'unit-count', 'volumes': 'volumes'}
    _toPy = {'application-count': 'application_count', 'error': 'error', 'filesystems': 'filesystems', 'hosted-machine-count': 'hosted_machine_count', 'life': 'life', 'machines': 'machines', 'model-tag': 'model_tag', 'owner-tag': 'owner_tag', 'type': 'type_', 'unit-count': 'unit_count', 'volumes': 'volumes'}
    def __init__(self, application_count=None, error=None, filesystems=None, hosted_machine_count=None, life=None, machines=None, model_tag=None, owner_tag=None, type_=None, unit_count=None, volumes=None, **unknown_fields):
        '''
        application_count : int
        error : Error
        filesystems : typing.Sequence[~ModelFilesystemInfo]
        hosted_machine_count : int
        life : str
        machines : typing.Sequence[~ModelMachineInfo]
        model_tag : str
        owner_tag : str
        type_ : str
        unit_count : int
        volumes : typing.Sequence[~ModelVolumeInfo]
        '''
        if application_count is not None and not isinstance(application_count, int):
            raise Exception('Expected application_count to be of type int')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if filesystems is not None and not isinstance(filesystems, list):
            raise Exception('Expected filesystems to be of type Sequence')

        if hosted_machine_count is not None and not isinstance(hosted_machine_count, int):
            raise Exception('Expected hosted_machine_count to be of type int')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if machines is not None and not isinstance(machines, list):
            raise Exception('Expected machines to be of type Sequence')

        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception('Expected model_tag to be of type str')

        if owner_tag is not None and not isinstance(owner_tag, (bytes, str)):
            raise Exception('Expected owner_tag to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        if unit_count is not None and not isinstance(unit_count, int):
            raise Exception('Expected unit_count to be of type int')

        if volumes is not None and not isinstance(volumes, list):
            raise Exception('Expected volumes to be of type Sequence')

        self.application_count = application_count
        self.error = Error.from_json(error) if error else None
        self.filesystems = [ModelFilesystemInfo.from_json(o) for o in filesystems or []]
        self.hosted_machine_count = hosted_machine_count
        self.life = life
        self.machines = [ModelMachineInfo.from_json(o) for o in machines or []]
        self.model_tag = model_tag
        self.owner_tag = owner_tag
        self.type_ = type_
        self.unit_count = unit_count
        self.volumes = [ModelVolumeInfo.from_json(o) for o in volumes or []]
        self.unknown_fields = unknown_fields



class ModelStatusInfo(Type):
    _toSchema = {'available_version': 'available-version', 'cloud_tag': 'cloud-tag', 'migration': 'migration', 'name': 'name', 'region': 'region', 'version': 'version'}
    _toPy = {'available-version': 'available_version', 'cloud-tag': 'cloud_tag', 'migration': 'migration', 'name': 'name', 'region': 'region', 'version': 'version'}
    def __init__(self, available_version=None, cloud_tag=None, migration=None, name=None, region=None, version=None, **unknown_fields):
        '''
        available_version : str
        cloud_tag : str
        migration : str
        name : str
        region : str
        version : str
        '''
        if available_version is not None and not isinstance(available_version, (bytes, str)):
            raise Exception('Expected available_version to be of type str')

        if cloud_tag is not None and not isinstance(cloud_tag, (bytes, str)):
            raise Exception('Expected cloud_tag to be of type str')

        if migration is not None and not isinstance(migration, (bytes, str)):
            raise Exception('Expected migration to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if region is not None and not isinstance(region, (bytes, str)):
            raise Exception('Expected region to be of type str')

        if version is not None and not isinstance(version, (bytes, str)):
            raise Exception('Expected version to be of type str')

        self.available_version = available_version
        self.cloud_tag = cloud_tag
        self.migration = migration
        self.name = name
        self.region = region
        self.version = version
        self.unknown_fields = unknown_fields



class ModelStatusResults(Type):
    _toSchema = {'models': 'models'}
    _toPy = {'models': 'models'}
    def __init__(self, models=None, **unknown_fields):
        '''
        models : typing.Sequence[~ModelStatus]
        '''
        if models is not None and not isinstance(models, list):
            raise Exception('Expected models to be of type Sequence')

        self.models = [ModelStatus.from_json(o) for o in models or []]
        self.unknown_fields = unknown_fields



class ModelSummariesRequest(Type):
    _toSchema = {'all_': 'all', 'user_tag': 'user-tag'}
    _toPy = {'all': 'all_', 'user-tag': 'user_tag'}
    def __init__(self, all_=None, user_tag=None, **unknown_fields):
        '''
        all_ : bool
        user_tag : str
        '''
        if all_ is not None and not isinstance(all_, bool):
            raise Exception('Expected all_ to be of type bool')

        if user_tag is not None and not isinstance(user_tag, (bytes, str)):
            raise Exception('Expected user_tag to be of type str')

        self.all_ = all_
        self.user_tag = user_tag
        self.unknown_fields = unknown_fields



class ModelSummary(Type):
    _toSchema = {'agent_version': 'agent-version', 'cloud_credential_tag': 'cloud-credential-tag', 'cloud_region': 'cloud-region', 'cloud_tag': 'cloud-tag', 'controller_uuid': 'controller-uuid', 'counts': 'counts', 'default_series': 'default-series', 'is_controller': 'is-controller', 'last_connection': 'last-connection', 'life': 'life', 'migration': 'migration', 'name': 'name', 'owner_tag': 'owner-tag', 'provider_type': 'provider-type', 'sla': 'sla', 'status': 'status', 'type_': 'type', 'user_access': 'user-access', 'uuid': 'uuid'}
    _toPy = {'agent-version': 'agent_version', 'cloud-credential-tag': 'cloud_credential_tag', 'cloud-region': 'cloud_region', 'cloud-tag': 'cloud_tag', 'controller-uuid': 'controller_uuid', 'counts': 'counts', 'default-series': 'default_series', 'is-controller': 'is_controller', 'last-connection': 'last_connection', 'life': 'life', 'migration': 'migration', 'name': 'name', 'owner-tag': 'owner_tag', 'provider-type': 'provider_type', 'sla': 'sla', 'status': 'status', 'type': 'type_', 'user-access': 'user_access', 'uuid': 'uuid'}
    def __init__(self, agent_version=None, cloud_credential_tag=None, cloud_region=None, cloud_tag=None, controller_uuid=None, counts=None, default_series=None, is_controller=None, last_connection=None, life=None, migration=None, name=None, owner_tag=None, provider_type=None, sla=None, status=None, type_=None, user_access=None, uuid=None, **unknown_fields):
        '''
        agent_version : Number
        cloud_credential_tag : str
        cloud_region : str
        cloud_tag : str
        controller_uuid : str
        counts : typing.Sequence[~ModelEntityCount]
        default_series : str
        is_controller : bool
        last_connection : str
        life : str
        migration : ModelMigrationStatus
        name : str
        owner_tag : str
        provider_type : str
        sla : ModelSLAInfo
        status : EntityStatus
        type_ : str
        user_access : str
        uuid : str
        '''
        if agent_version is not None and not isinstance(agent_version, Number):
            raise Exception('Expected agent_version to be of type Number')

        if cloud_credential_tag is not None and not isinstance(cloud_credential_tag, (bytes, str)):
            raise Exception('Expected cloud_credential_tag to be of type str')

        if cloud_region is not None and not isinstance(cloud_region, (bytes, str)):
            raise Exception('Expected cloud_region to be of type str')

        if cloud_tag is not None and not isinstance(cloud_tag, (bytes, str)):
            raise Exception('Expected cloud_tag to be of type str')

        if controller_uuid is not None and not isinstance(controller_uuid, (bytes, str)):
            raise Exception('Expected controller_uuid to be of type str')

        if counts is not None and not isinstance(counts, list):
            raise Exception('Expected counts to be of type Sequence')

        if default_series is not None and not isinstance(default_series, (bytes, str)):
            raise Exception('Expected default_series to be of type str')

        if is_controller is not None and not isinstance(is_controller, bool):
            raise Exception('Expected is_controller to be of type bool')

        if last_connection is not None and not isinstance(last_connection, (bytes, str)):
            raise Exception('Expected last_connection to be of type str')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if migration is not None and not isinstance(migration, ModelMigrationStatus):
            raise Exception('Expected migration to be of type ModelMigrationStatus')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if owner_tag is not None and not isinstance(owner_tag, (bytes, str)):
            raise Exception('Expected owner_tag to be of type str')

        if provider_type is not None and not isinstance(provider_type, (bytes, str)):
            raise Exception('Expected provider_type to be of type str')

        if sla is not None and not isinstance(sla, ModelSLAInfo):
            raise Exception('Expected sla to be of type ModelSLAInfo')

        if status is not None and not isinstance(status, EntityStatus):
            raise Exception('Expected status to be of type EntityStatus')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        if user_access is not None and not isinstance(user_access, (bytes, str)):
            raise Exception('Expected user_access to be of type str')

        if uuid is not None and not isinstance(uuid, (bytes, str)):
            raise Exception('Expected uuid to be of type str')

        self.agent_version = Number.from_json(agent_version) if agent_version else None
        self.cloud_credential_tag = cloud_credential_tag
        self.cloud_region = cloud_region
        self.cloud_tag = cloud_tag
        self.controller_uuid = controller_uuid
        self.counts = [ModelEntityCount.from_json(o) for o in counts or []]
        self.default_series = default_series
        self.is_controller = is_controller
        self.last_connection = last_connection
        self.life = life
        self.migration = ModelMigrationStatus.from_json(migration) if migration else None
        self.name = name
        self.owner_tag = owner_tag
        self.provider_type = provider_type
        self.sla = ModelSLAInfo.from_json(sla) if sla else None
        self.status = EntityStatus.from_json(status) if status else None
        self.type_ = type_
        self.user_access = user_access
        self.uuid = uuid
        self.unknown_fields = unknown_fields



class ModelSummaryResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : ModelSummary
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, ModelSummary):
            raise Exception('Expected result to be of type ModelSummary')

        self.error = Error.from_json(error) if error else None
        self.result = ModelSummary.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class ModelSummaryResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ModelSummaryResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ModelSummaryResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ModelTag(Type):
    _toSchema = {}
    _toPy = {}
    def __init__(self, **unknown_fields):
        '''

        '''
        self.unknown_fields = unknown_fields



class ModelUnset(Type):
    _toSchema = {'keys': 'keys'}
    _toPy = {'keys': 'keys'}
    def __init__(self, keys=None, **unknown_fields):
        '''
        keys : typing.Sequence[str]
        '''
        if keys is not None and not isinstance(keys, list):
            raise Exception('Expected keys to be of type Sequence')

        self.keys = keys
        self.unknown_fields = unknown_fields



class ModelUnsetKeys(Type):
    _toSchema = {'cloud_region': 'cloud-region', 'cloud_tag': 'cloud-tag', 'keys': 'keys'}
    _toPy = {'cloud-region': 'cloud_region', 'cloud-tag': 'cloud_tag', 'keys': 'keys'}
    def __init__(self, cloud_region=None, cloud_tag=None, keys=None, **unknown_fields):
        '''
        cloud_region : str
        cloud_tag : str
        keys : typing.Sequence[str]
        '''
        if cloud_region is not None and not isinstance(cloud_region, (bytes, str)):
            raise Exception('Expected cloud_region to be of type str')

        if cloud_tag is not None and not isinstance(cloud_tag, (bytes, str)):
            raise Exception('Expected cloud_tag to be of type str')

        if keys is not None and not isinstance(keys, list):
            raise Exception('Expected keys to be of type Sequence')

        self.cloud_region = cloud_region
        self.cloud_tag = cloud_tag
        self.keys = keys
        self.unknown_fields = unknown_fields



class ModelUserInfo(Type):
    _toSchema = {'access': 'access', 'display_name': 'display-name', 'last_connection': 'last-connection', 'user': 'user'}
    _toPy = {'access': 'access', 'display-name': 'display_name', 'last-connection': 'last_connection', 'user': 'user'}
    def __init__(self, access=None, display_name=None, last_connection=None, user=None, **unknown_fields):
        '''
        access : str
        display_name : str
        last_connection : str
        user : str
        '''
        if access is not None and not isinstance(access, (bytes, str)):
            raise Exception('Expected access to be of type str')

        if display_name is not None and not isinstance(display_name, (bytes, str)):
            raise Exception('Expected display_name to be of type str')

        if last_connection is not None and not isinstance(last_connection, (bytes, str)):
            raise Exception('Expected last_connection to be of type str')

        if user is not None and not isinstance(user, (bytes, str)):
            raise Exception('Expected user to be of type str')

        self.access = access
        self.display_name = display_name
        self.last_connection = last_connection
        self.user = user
        self.unknown_fields = unknown_fields



class ModelUserInfoResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : ModelUserInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, ModelUserInfo):
            raise Exception('Expected result to be of type ModelUserInfo')

        self.error = Error.from_json(error) if error else None
        self.result = ModelUserInfo.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class ModelUserInfoResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ModelUserInfoResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ModelUserInfoResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ModelVolumeInfo(Type):
    _toSchema = {'detachable': 'detachable', 'id_': 'id', 'message': 'message', 'provider_id': 'provider-id', 'status': 'status'}
    _toPy = {'detachable': 'detachable', 'id': 'id_', 'message': 'message', 'provider-id': 'provider_id', 'status': 'status'}
    def __init__(self, detachable=None, id_=None, message=None, provider_id=None, status=None, **unknown_fields):
        '''
        detachable : bool
        id_ : str
        message : str
        provider_id : str
        status : str
        '''
        if detachable is not None and not isinstance(detachable, bool):
            raise Exception('Expected detachable to be of type bool')

        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        if provider_id is not None and not isinstance(provider_id, (bytes, str)):
            raise Exception('Expected provider_id to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        self.detachable = detachable
        self.id_ = id_
        self.message = message
        self.provider_id = provider_id
        self.status = status
        self.unknown_fields = unknown_fields



class ModifyCloudAccess(Type):
    _toSchema = {'access': 'access', 'action': 'action', 'cloud_tag': 'cloud-tag', 'user_tag': 'user-tag'}
    _toPy = {'access': 'access', 'action': 'action', 'cloud-tag': 'cloud_tag', 'user-tag': 'user_tag'}
    def __init__(self, access=None, action=None, cloud_tag=None, user_tag=None, **unknown_fields):
        '''
        access : str
        action : str
        cloud_tag : str
        user_tag : str
        '''
        if access is not None and not isinstance(access, (bytes, str)):
            raise Exception('Expected access to be of type str')

        if action is not None and not isinstance(action, (bytes, str)):
            raise Exception('Expected action to be of type str')

        if cloud_tag is not None and not isinstance(cloud_tag, (bytes, str)):
            raise Exception('Expected cloud_tag to be of type str')

        if user_tag is not None and not isinstance(user_tag, (bytes, str)):
            raise Exception('Expected user_tag to be of type str')

        self.access = access
        self.action = action
        self.cloud_tag = cloud_tag
        self.user_tag = user_tag
        self.unknown_fields = unknown_fields



class ModifyCloudAccessRequest(Type):
    _toSchema = {'changes': 'changes'}
    _toPy = {'changes': 'changes'}
    def __init__(self, changes=None, **unknown_fields):
        '''
        changes : typing.Sequence[~ModifyCloudAccess]
        '''
        if changes is not None and not isinstance(changes, list):
            raise Exception('Expected changes to be of type Sequence')

        self.changes = [ModifyCloudAccess.from_json(o) for o in changes or []]
        self.unknown_fields = unknown_fields



class ModifyControllerAccess(Type):
    _toSchema = {'access': 'access', 'action': 'action', 'user_tag': 'user-tag'}
    _toPy = {'access': 'access', 'action': 'action', 'user-tag': 'user_tag'}
    def __init__(self, access=None, action=None, user_tag=None, **unknown_fields):
        '''
        access : str
        action : str
        user_tag : str
        '''
        if access is not None and not isinstance(access, (bytes, str)):
            raise Exception('Expected access to be of type str')

        if action is not None and not isinstance(action, (bytes, str)):
            raise Exception('Expected action to be of type str')

        if user_tag is not None and not isinstance(user_tag, (bytes, str)):
            raise Exception('Expected user_tag to be of type str')

        self.access = access
        self.action = action
        self.user_tag = user_tag
        self.unknown_fields = unknown_fields



class ModifyControllerAccessRequest(Type):
    _toSchema = {'changes': 'changes'}
    _toPy = {'changes': 'changes'}
    def __init__(self, changes=None, **unknown_fields):
        '''
        changes : typing.Sequence[~ModifyControllerAccess]
        '''
        if changes is not None and not isinstance(changes, list):
            raise Exception('Expected changes to be of type Sequence')

        self.changes = [ModifyControllerAccess.from_json(o) for o in changes or []]
        self.unknown_fields = unknown_fields



class ModifyModelAccess(Type):
    _toSchema = {'access': 'access', 'action': 'action', 'model_tag': 'model-tag', 'user_tag': 'user-tag'}
    _toPy = {'access': 'access', 'action': 'action', 'model-tag': 'model_tag', 'user-tag': 'user_tag'}
    def __init__(self, access=None, action=None, model_tag=None, user_tag=None, **unknown_fields):
        '''
        access : str
        action : str
        model_tag : str
        user_tag : str
        '''
        if access is not None and not isinstance(access, (bytes, str)):
            raise Exception('Expected access to be of type str')

        if action is not None and not isinstance(action, (bytes, str)):
            raise Exception('Expected action to be of type str')

        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception('Expected model_tag to be of type str')

        if user_tag is not None and not isinstance(user_tag, (bytes, str)):
            raise Exception('Expected user_tag to be of type str')

        self.access = access
        self.action = action
        self.model_tag = model_tag
        self.user_tag = user_tag
        self.unknown_fields = unknown_fields



class ModifyModelAccessRequest(Type):
    _toSchema = {'changes': 'changes'}
    _toPy = {'changes': 'changes'}
    def __init__(self, changes=None, **unknown_fields):
        '''
        changes : typing.Sequence[~ModifyModelAccess]
        '''
        if changes is not None and not isinstance(changes, list):
            raise Exception('Expected changes to be of type Sequence')

        self.changes = [ModifyModelAccess.from_json(o) for o in changes or []]
        self.unknown_fields = unknown_fields



class ModifyOfferAccess(Type):
    _toSchema = {'access': 'access', 'action': 'action', 'offer_url': 'offer-url', 'user_tag': 'user-tag'}
    _toPy = {'access': 'access', 'action': 'action', 'offer-url': 'offer_url', 'user-tag': 'user_tag'}
    def __init__(self, access=None, action=None, offer_url=None, user_tag=None, **unknown_fields):
        '''
        access : str
        action : str
        offer_url : str
        user_tag : str
        '''
        if access is not None and not isinstance(access, (bytes, str)):
            raise Exception('Expected access to be of type str')

        if action is not None and not isinstance(action, (bytes, str)):
            raise Exception('Expected action to be of type str')

        if offer_url is not None and not isinstance(offer_url, (bytes, str)):
            raise Exception('Expected offer_url to be of type str')

        if user_tag is not None and not isinstance(user_tag, (bytes, str)):
            raise Exception('Expected user_tag to be of type str')

        self.access = access
        self.action = action
        self.offer_url = offer_url
        self.user_tag = user_tag
        self.unknown_fields = unknown_fields



class ModifyOfferAccessRequest(Type):
    _toSchema = {'changes': 'changes'}
    _toPy = {'changes': 'changes'}
    def __init__(self, changes=None, **unknown_fields):
        '''
        changes : typing.Sequence[~ModifyOfferAccess]
        '''
        if changes is not None and not isinstance(changes, list):
            raise Exception('Expected changes to be of type Sequence')

        self.changes = [ModifyOfferAccess.from_json(o) for o in changes or []]
        self.unknown_fields = unknown_fields



class ModifyUserSSHKeys(Type):
    _toSchema = {'ssh_keys': 'ssh-keys', 'user': 'user'}
    _toPy = {'ssh-keys': 'ssh_keys', 'user': 'user'}
    def __init__(self, ssh_keys=None, user=None, **unknown_fields):
        '''
        ssh_keys : typing.Sequence[str]
        user : str
        '''
        if ssh_keys is not None and not isinstance(ssh_keys, list):
            raise Exception('Expected ssh_keys to be of type Sequence')

        if user is not None and not isinstance(user, (bytes, str)):
            raise Exception('Expected user to be of type str')

        self.ssh_keys = ssh_keys
        self.user = user
        self.unknown_fields = unknown_fields



class MongoUpgradeResults(Type):
    _toSchema = {'ha_members': 'ha-members', 'master': 'master', 'rs_members': 'rs-members'}
    _toPy = {'ha-members': 'ha_members', 'master': 'master', 'rs-members': 'rs_members'}
    def __init__(self, ha_members=None, master=None, rs_members=None, **unknown_fields):
        '''
        ha_members : typing.Sequence[~HAMember]
        master : HAMember
        rs_members : typing.Sequence[~Member]
        '''
        if ha_members is not None and not isinstance(ha_members, list):
            raise Exception('Expected ha_members to be of type Sequence')

        if master is not None and not isinstance(master, HAMember):
            raise Exception('Expected master to be of type HAMember')

        if rs_members is not None and not isinstance(rs_members, list):
            raise Exception('Expected rs_members to be of type Sequence')

        self.ha_members = [HAMember.from_json(o) for o in ha_members or []]
        self.master = HAMember.from_json(master) if master else None
        self.rs_members = [Member.from_json(o) for o in rs_members or []]
        self.unknown_fields = unknown_fields



class MongoVersion(Type):
    _toSchema = {'engine': 'engine', 'major': 'major', 'minor': 'minor', 'patch': 'patch'}
    _toPy = {'engine': 'engine', 'major': 'major', 'minor': 'minor', 'patch': 'patch'}
    def __init__(self, engine=None, major=None, minor=None, patch=None, **unknown_fields):
        '''
        engine : str
        major : int
        minor : int
        patch : str
        '''
        if engine is not None and not isinstance(engine, (bytes, str)):
            raise Exception('Expected engine to be of type str')

        if major is not None and not isinstance(major, int):
            raise Exception('Expected major to be of type int')

        if minor is not None and not isinstance(minor, int):
            raise Exception('Expected minor to be of type int')

        if patch is not None and not isinstance(patch, (bytes, str)):
            raise Exception('Expected patch to be of type str')

        self.engine = engine
        self.major = major
        self.minor = minor
        self.patch = patch
        self.unknown_fields = unknown_fields



class NetworkConfig(Type):
    _toSchema = {'address': 'address', 'cidr': 'cidr', 'config_type': 'config-type', 'device_index': 'device-index', 'disabled': 'disabled', 'dns_search_domains': 'dns-search-domains', 'dns_servers': 'dns-servers', 'gateway_address': 'gateway-address', 'interface_name': 'interface-name', 'interface_type': 'interface-type', 'is_default_gateway': 'is-default-gateway', 'mac_address': 'mac-address', 'mtu': 'mtu', 'no_auto_start': 'no-auto-start', 'parent_interface_name': 'parent-interface-name', 'provider_address_id': 'provider-address-id', 'provider_id': 'provider-id', 'provider_space_id': 'provider-space-id', 'provider_subnet_id': 'provider-subnet-id', 'provider_vlan_id': 'provider-vlan-id', 'routes': 'routes', 'vlan_tag': 'vlan-tag'}
    _toPy = {'address': 'address', 'cidr': 'cidr', 'config-type': 'config_type', 'device-index': 'device_index', 'disabled': 'disabled', 'dns-search-domains': 'dns_search_domains', 'dns-servers': 'dns_servers', 'gateway-address': 'gateway_address', 'interface-name': 'interface_name', 'interface-type': 'interface_type', 'is-default-gateway': 'is_default_gateway', 'mac-address': 'mac_address', 'mtu': 'mtu', 'no-auto-start': 'no_auto_start', 'parent-interface-name': 'parent_interface_name', 'provider-address-id': 'provider_address_id', 'provider-id': 'provider_id', 'provider-space-id': 'provider_space_id', 'provider-subnet-id': 'provider_subnet_id', 'provider-vlan-id': 'provider_vlan_id', 'routes': 'routes', 'vlan-tag': 'vlan_tag'}
    def __init__(self, address=None, cidr=None, config_type=None, device_index=None, disabled=None, dns_search_domains=None, dns_servers=None, gateway_address=None, interface_name=None, interface_type=None, is_default_gateway=None, mac_address=None, mtu=None, no_auto_start=None, parent_interface_name=None, provider_address_id=None, provider_id=None, provider_space_id=None, provider_subnet_id=None, provider_vlan_id=None, routes=None, vlan_tag=None, **unknown_fields):
        '''
        address : str
        cidr : str
        config_type : str
        device_index : int
        disabled : bool
        dns_search_domains : typing.Sequence[str]
        dns_servers : typing.Sequence[str]
        gateway_address : str
        interface_name : str
        interface_type : str
        is_default_gateway : bool
        mac_address : str
        mtu : int
        no_auto_start : bool
        parent_interface_name : str
        provider_address_id : str
        provider_id : str
        provider_space_id : str
        provider_subnet_id : str
        provider_vlan_id : str
        routes : typing.Sequence[~NetworkRoute]
        vlan_tag : int
        '''
        if address is not None and not isinstance(address, (bytes, str)):
            raise Exception('Expected address to be of type str')

        if cidr is not None and not isinstance(cidr, (bytes, str)):
            raise Exception('Expected cidr to be of type str')

        if config_type is not None and not isinstance(config_type, (bytes, str)):
            raise Exception('Expected config_type to be of type str')

        if device_index is not None and not isinstance(device_index, int):
            raise Exception('Expected device_index to be of type int')

        if disabled is not None and not isinstance(disabled, bool):
            raise Exception('Expected disabled to be of type bool')

        if dns_search_domains is not None and not isinstance(dns_search_domains, list):
            raise Exception('Expected dns_search_domains to be of type Sequence')

        if dns_servers is not None and not isinstance(dns_servers, list):
            raise Exception('Expected dns_servers to be of type Sequence')

        if gateway_address is not None and not isinstance(gateway_address, (bytes, str)):
            raise Exception('Expected gateway_address to be of type str')

        if interface_name is not None and not isinstance(interface_name, (bytes, str)):
            raise Exception('Expected interface_name to be of type str')

        if interface_type is not None and not isinstance(interface_type, (bytes, str)):
            raise Exception('Expected interface_type to be of type str')

        if is_default_gateway is not None and not isinstance(is_default_gateway, bool):
            raise Exception('Expected is_default_gateway to be of type bool')

        if mac_address is not None and not isinstance(mac_address, (bytes, str)):
            raise Exception('Expected mac_address to be of type str')

        if mtu is not None and not isinstance(mtu, int):
            raise Exception('Expected mtu to be of type int')

        if no_auto_start is not None and not isinstance(no_auto_start, bool):
            raise Exception('Expected no_auto_start to be of type bool')

        if parent_interface_name is not None and not isinstance(parent_interface_name, (bytes, str)):
            raise Exception('Expected parent_interface_name to be of type str')

        if provider_address_id is not None and not isinstance(provider_address_id, (bytes, str)):
            raise Exception('Expected provider_address_id to be of type str')

        if provider_id is not None and not isinstance(provider_id, (bytes, str)):
            raise Exception('Expected provider_id to be of type str')

        if provider_space_id is not None and not isinstance(provider_space_id, (bytes, str)):
            raise Exception('Expected provider_space_id to be of type str')

        if provider_subnet_id is not None and not isinstance(provider_subnet_id, (bytes, str)):
            raise Exception('Expected provider_subnet_id to be of type str')

        if provider_vlan_id is not None and not isinstance(provider_vlan_id, (bytes, str)):
            raise Exception('Expected provider_vlan_id to be of type str')

        if routes is not None and not isinstance(routes, list):
            raise Exception('Expected routes to be of type Sequence')

        if vlan_tag is not None and not isinstance(vlan_tag, int):
            raise Exception('Expected vlan_tag to be of type int')

        self.address = address
        self.cidr = cidr
        self.config_type = config_type
        self.device_index = device_index
        self.disabled = disabled
        self.dns_search_domains = dns_search_domains
        self.dns_servers = dns_servers
        self.gateway_address = gateway_address
        self.interface_name = interface_name
        self.interface_type = interface_type
        self.is_default_gateway = is_default_gateway
        self.mac_address = mac_address
        self.mtu = mtu
        self.no_auto_start = no_auto_start
        self.parent_interface_name = parent_interface_name
        self.provider_address_id = provider_address_id
        self.provider_id = provider_id
        self.provider_space_id = provider_space_id
        self.provider_subnet_id = provider_subnet_id
        self.provider_vlan_id = provider_vlan_id
        self.routes = [NetworkRoute.from_json(o) for o in routes or []]
        self.vlan_tag = vlan_tag
        self.unknown_fields = unknown_fields



class NetworkInfo(Type):
    _toSchema = {'addresses': 'addresses', 'interface_name': 'interface-name', 'mac_address': 'mac-address'}
    _toPy = {'addresses': 'addresses', 'interface-name': 'interface_name', 'mac-address': 'mac_address'}
    def __init__(self, addresses=None, interface_name=None, mac_address=None, **unknown_fields):
        '''
        addresses : typing.Sequence[~InterfaceAddress]
        interface_name : str
        mac_address : str
        '''
        if addresses is not None and not isinstance(addresses, list):
            raise Exception('Expected addresses to be of type Sequence')

        if interface_name is not None and not isinstance(interface_name, (bytes, str)):
            raise Exception('Expected interface_name to be of type str')

        if mac_address is not None and not isinstance(mac_address, (bytes, str)):
            raise Exception('Expected mac_address to be of type str')

        self.addresses = [InterfaceAddress.from_json(o) for o in addresses or []]
        self.interface_name = interface_name
        self.mac_address = mac_address
        self.unknown_fields = unknown_fields



class NetworkInfoParams(Type):
    _toSchema = {'bindings': 'bindings', 'relation_id': 'relation-id', 'unit': 'unit'}
    _toPy = {'bindings': 'bindings', 'relation-id': 'relation_id', 'unit': 'unit'}
    def __init__(self, bindings=None, relation_id=None, unit=None, **unknown_fields):
        '''
        bindings : typing.Sequence[str]
        relation_id : int
        unit : str
        '''
        if bindings is not None and not isinstance(bindings, list):
            raise Exception('Expected bindings to be of type Sequence')

        if relation_id is not None and not isinstance(relation_id, int):
            raise Exception('Expected relation_id to be of type int')

        if unit is not None and not isinstance(unit, (bytes, str)):
            raise Exception('Expected unit to be of type str')

        self.bindings = bindings
        self.relation_id = relation_id
        self.unit = unit
        self.unknown_fields = unknown_fields



class NetworkInfoResult(Type):
    _toSchema = {'bind_addresses': 'bind-addresses', 'egress_subnets': 'egress-subnets', 'error': 'error', 'ingress_addresses': 'ingress-addresses'}
    _toPy = {'bind-addresses': 'bind_addresses', 'egress-subnets': 'egress_subnets', 'error': 'error', 'ingress-addresses': 'ingress_addresses'}
    def __init__(self, bind_addresses=None, egress_subnets=None, error=None, ingress_addresses=None, **unknown_fields):
        '''
        bind_addresses : typing.Sequence[~NetworkInfo]
        egress_subnets : typing.Sequence[str]
        error : Error
        ingress_addresses : typing.Sequence[str]
        '''
        if bind_addresses is not None and not isinstance(bind_addresses, list):
            raise Exception('Expected bind_addresses to be of type Sequence')

        if egress_subnets is not None and not isinstance(egress_subnets, list):
            raise Exception('Expected egress_subnets to be of type Sequence')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if ingress_addresses is not None and not isinstance(ingress_addresses, list):
            raise Exception('Expected ingress_addresses to be of type Sequence')

        self.bind_addresses = [NetworkInfo.from_json(o) for o in bind_addresses or []]
        self.egress_subnets = egress_subnets
        self.error = Error.from_json(error) if error else None
        self.ingress_addresses = ingress_addresses
        self.unknown_fields = unknown_fields



class NetworkInfoResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Mapping[str, ~NetworkInfoResult]
        '''
        if results is not None and not isinstance(results, dict):
            raise Exception('Expected results to be of type Mapping')

        self.results = results
        self.unknown_fields = unknown_fields



class NetworkInterface(Type):
    _toSchema = {'dns_nameservers': 'dns-nameservers', 'gateway': 'gateway', 'ip_addresses': 'ip-addresses', 'is_up': 'is-up', 'mac_address': 'mac-address', 'space': 'space'}
    _toPy = {'dns-nameservers': 'dns_nameservers', 'gateway': 'gateway', 'ip-addresses': 'ip_addresses', 'is-up': 'is_up', 'mac-address': 'mac_address', 'space': 'space'}
    def __init__(self, dns_nameservers=None, gateway=None, ip_addresses=None, is_up=None, mac_address=None, space=None, **unknown_fields):
        '''
        dns_nameservers : typing.Sequence[str]
        gateway : str
        ip_addresses : typing.Sequence[str]
        is_up : bool
        mac_address : str
        space : str
        '''
        if dns_nameservers is not None and not isinstance(dns_nameservers, list):
            raise Exception('Expected dns_nameservers to be of type Sequence')

        if gateway is not None and not isinstance(gateway, (bytes, str)):
            raise Exception('Expected gateway to be of type str')

        if ip_addresses is not None and not isinstance(ip_addresses, list):
            raise Exception('Expected ip_addresses to be of type Sequence')

        if is_up is not None and not isinstance(is_up, bool):
            raise Exception('Expected is_up to be of type bool')

        if mac_address is not None and not isinstance(mac_address, (bytes, str)):
            raise Exception('Expected mac_address to be of type str')

        if space is not None and not isinstance(space, (bytes, str)):
            raise Exception('Expected space to be of type str')

        self.dns_nameservers = dns_nameservers
        self.gateway = gateway
        self.ip_addresses = ip_addresses
        self.is_up = is_up
        self.mac_address = mac_address
        self.space = space
        self.unknown_fields = unknown_fields



class NetworkRoute(Type):
    _toSchema = {'destination_cidr': 'destination-cidr', 'gateway_ip': 'gateway-ip', 'metric': 'metric'}
    _toPy = {'destination-cidr': 'destination_cidr', 'gateway-ip': 'gateway_ip', 'metric': 'metric'}
    def __init__(self, destination_cidr=None, gateway_ip=None, metric=None, **unknown_fields):
        '''
        destination_cidr : str
        gateway_ip : str
        metric : int
        '''
        if destination_cidr is not None and not isinstance(destination_cidr, (bytes, str)):
            raise Exception('Expected destination_cidr to be of type str')

        if gateway_ip is not None and not isinstance(gateway_ip, (bytes, str)):
            raise Exception('Expected gateway_ip to be of type str')

        if metric is not None and not isinstance(metric, int):
            raise Exception('Expected metric to be of type int')

        self.destination_cidr = destination_cidr
        self.gateway_ip = gateway_ip
        self.metric = metric
        self.unknown_fields = unknown_fields



class NotifyWatchResult(Type):
    _toSchema = {'error': 'error', 'notifywatcherid': 'NotifyWatcherId'}
    _toPy = {'NotifyWatcherId': 'notifywatcherid', 'error': 'error'}
    def __init__(self, notifywatcherid=None, error=None, **unknown_fields):
        '''
        notifywatcherid : str
        error : Error
        '''
        if notifywatcherid is not None and not isinstance(notifywatcherid, (bytes, str)):
            raise Exception('Expected notifywatcherid to be of type str')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.notifywatcherid = notifywatcherid
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class NotifyWatchResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~NotifyWatchResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [NotifyWatchResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class Number(Type):
    _toSchema = {'build': 'Build', 'major': 'Major', 'minor': 'Minor', 'patch': 'Patch', 'tag': 'Tag'}
    _toPy = {'Build': 'build', 'Major': 'major', 'Minor': 'minor', 'Patch': 'patch', 'Tag': 'tag'}
    def __init__(self, build=None, major=None, minor=None, patch=None, tag=None, **unknown_fields):
        '''
        build : int
        major : int
        minor : int
        patch : int
        tag : str
        '''
        if build is not None and not isinstance(build, int):
            raise Exception('Expected build to be of type int')

        if major is not None and not isinstance(major, int):
            raise Exception('Expected major to be of type int')

        if minor is not None and not isinstance(minor, int):
            raise Exception('Expected minor to be of type int')

        if patch is not None and not isinstance(patch, int):
            raise Exception('Expected patch to be of type int')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.build = build
        self.major = major
        self.minor = minor
        self.patch = patch
        self.tag = tag
        self.unknown_fields = unknown_fields



class OfferArg(Type):
    _toSchema = {'macaroons': 'macaroons', 'offer_uuid': 'offer-uuid'}
    _toPy = {'macaroons': 'macaroons', 'offer-uuid': 'offer_uuid'}
    def __init__(self, macaroons=None, offer_uuid=None, **unknown_fields):
        '''
        macaroons : typing.Sequence[~Macaroon]
        offer_uuid : str
        '''
        if macaroons is not None and not isinstance(macaroons, list):
            raise Exception('Expected macaroons to be of type Sequence')

        if offer_uuid is not None and not isinstance(offer_uuid, (bytes, str)):
            raise Exception('Expected offer_uuid to be of type str')

        self.macaroons = [Macaroon.from_json(o) for o in macaroons or []]
        self.offer_uuid = offer_uuid
        self.unknown_fields = unknown_fields



class OfferArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~OfferArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [OfferArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class OfferConnection(Type):
    _toSchema = {'endpoint': 'endpoint', 'ingress_subnets': 'ingress-subnets', 'relation_id': 'relation-id', 'source_model_tag': 'source-model-tag', 'status': 'status', 'username': 'username'}
    _toPy = {'endpoint': 'endpoint', 'ingress-subnets': 'ingress_subnets', 'relation-id': 'relation_id', 'source-model-tag': 'source_model_tag', 'status': 'status', 'username': 'username'}
    def __init__(self, endpoint=None, ingress_subnets=None, relation_id=None, source_model_tag=None, status=None, username=None, **unknown_fields):
        '''
        endpoint : str
        ingress_subnets : typing.Sequence[str]
        relation_id : int
        source_model_tag : str
        status : EntityStatus
        username : str
        '''
        if endpoint is not None and not isinstance(endpoint, (bytes, str)):
            raise Exception('Expected endpoint to be of type str')

        if ingress_subnets is not None and not isinstance(ingress_subnets, list):
            raise Exception('Expected ingress_subnets to be of type Sequence')

        if relation_id is not None and not isinstance(relation_id, int):
            raise Exception('Expected relation_id to be of type int')

        if source_model_tag is not None and not isinstance(source_model_tag, (bytes, str)):
            raise Exception('Expected source_model_tag to be of type str')

        if status is not None and not isinstance(status, EntityStatus):
            raise Exception('Expected status to be of type EntityStatus')

        if username is not None and not isinstance(username, (bytes, str)):
            raise Exception('Expected username to be of type str')

        self.endpoint = endpoint
        self.ingress_subnets = ingress_subnets
        self.relation_id = relation_id
        self.source_model_tag = source_model_tag
        self.status = EntityStatus.from_json(status) if status else None
        self.username = username
        self.unknown_fields = unknown_fields



class OfferFilter(Type):
    _toSchema = {'allowed_users': 'allowed-users', 'application_description': 'application-description', 'application_name': 'application-name', 'application_user': 'application-user', 'connected_users': 'connected-users', 'endpoints': 'endpoints', 'model_name': 'model-name', 'offer_name': 'offer-name', 'owner_name': 'owner-name'}
    _toPy = {'allowed-users': 'allowed_users', 'application-description': 'application_description', 'application-name': 'application_name', 'application-user': 'application_user', 'connected-users': 'connected_users', 'endpoints': 'endpoints', 'model-name': 'model_name', 'offer-name': 'offer_name', 'owner-name': 'owner_name'}
    def __init__(self, allowed_users=None, application_description=None, application_name=None, application_user=None, connected_users=None, endpoints=None, model_name=None, offer_name=None, owner_name=None, **unknown_fields):
        '''
        allowed_users : typing.Sequence[str]
        application_description : str
        application_name : str
        application_user : str
        connected_users : typing.Sequence[str]
        endpoints : typing.Sequence[~EndpointFilterAttributes]
        model_name : str
        offer_name : str
        owner_name : str
        '''
        if allowed_users is not None and not isinstance(allowed_users, list):
            raise Exception('Expected allowed_users to be of type Sequence')

        if application_description is not None and not isinstance(application_description, (bytes, str)):
            raise Exception('Expected application_description to be of type str')

        if application_name is not None and not isinstance(application_name, (bytes, str)):
            raise Exception('Expected application_name to be of type str')

        if application_user is not None and not isinstance(application_user, (bytes, str)):
            raise Exception('Expected application_user to be of type str')

        if connected_users is not None and not isinstance(connected_users, list):
            raise Exception('Expected connected_users to be of type Sequence')

        if endpoints is not None and not isinstance(endpoints, list):
            raise Exception('Expected endpoints to be of type Sequence')

        if model_name is not None and not isinstance(model_name, (bytes, str)):
            raise Exception('Expected model_name to be of type str')

        if offer_name is not None and not isinstance(offer_name, (bytes, str)):
            raise Exception('Expected offer_name to be of type str')

        if owner_name is not None and not isinstance(owner_name, (bytes, str)):
            raise Exception('Expected owner_name to be of type str')

        self.allowed_users = allowed_users
        self.application_description = application_description
        self.application_name = application_name
        self.application_user = application_user
        self.connected_users = connected_users
        self.endpoints = [EndpointFilterAttributes.from_json(o) for o in endpoints or []]
        self.model_name = model_name
        self.offer_name = offer_name
        self.owner_name = owner_name
        self.unknown_fields = unknown_fields



class OfferFilters(Type):
    _toSchema = {'filters': 'Filters'}
    _toPy = {'Filters': 'filters'}
    def __init__(self, filters=None, **unknown_fields):
        '''
        filters : typing.Sequence[~OfferFilter]
        '''
        if filters is not None and not isinstance(filters, list):
            raise Exception('Expected filters to be of type Sequence')

        self.filters = [OfferFilter.from_json(o) for o in filters or []]
        self.unknown_fields = unknown_fields



class OfferStatusChange(Type):
    _toSchema = {'offer_name': 'offer-name', 'status': 'status'}
    _toPy = {'offer-name': 'offer_name', 'status': 'status'}
    def __init__(self, offer_name=None, status=None, **unknown_fields):
        '''
        offer_name : str
        status : EntityStatus
        '''
        if offer_name is not None and not isinstance(offer_name, (bytes, str)):
            raise Exception('Expected offer_name to be of type str')

        if status is not None and not isinstance(status, EntityStatus):
            raise Exception('Expected status to be of type EntityStatus')

        self.offer_name = offer_name
        self.status = EntityStatus.from_json(status) if status else None
        self.unknown_fields = unknown_fields



class OfferStatusWatchResult(Type):
    _toSchema = {'changes': 'changes', 'error': 'error', 'watcher_id': 'watcher-id'}
    _toPy = {'changes': 'changes', 'error': 'error', 'watcher-id': 'watcher_id'}
    def __init__(self, changes=None, error=None, watcher_id=None, **unknown_fields):
        '''
        changes : typing.Sequence[~OfferStatusChange]
        error : Error
        watcher_id : str
        '''
        if changes is not None and not isinstance(changes, list):
            raise Exception('Expected changes to be of type Sequence')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if watcher_id is not None and not isinstance(watcher_id, (bytes, str)):
            raise Exception('Expected watcher_id to be of type str')

        self.changes = [OfferStatusChange.from_json(o) for o in changes or []]
        self.error = Error.from_json(error) if error else None
        self.watcher_id = watcher_id
        self.unknown_fields = unknown_fields



class OfferStatusWatchResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~OfferStatusWatchResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [OfferStatusWatchResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class OfferURLs(Type):
    _toSchema = {'offer_urls': 'offer-urls'}
    _toPy = {'offer-urls': 'offer_urls'}
    def __init__(self, offer_urls=None, **unknown_fields):
        '''
        offer_urls : typing.Sequence[str]
        '''
        if offer_urls is not None and not isinstance(offer_urls, list):
            raise Exception('Expected offer_urls to be of type Sequence')

        self.offer_urls = offer_urls
        self.unknown_fields = unknown_fields



class OfferUserDetails(Type):
    _toSchema = {'access': 'access', 'display_name': 'display-name', 'user': 'user'}
    _toPy = {'access': 'access', 'display-name': 'display_name', 'user': 'user'}
    def __init__(self, access=None, display_name=None, user=None, **unknown_fields):
        '''
        access : str
        display_name : str
        user : str
        '''
        if access is not None and not isinstance(access, (bytes, str)):
            raise Exception('Expected access to be of type str')

        if display_name is not None and not isinstance(display_name, (bytes, str)):
            raise Exception('Expected display_name to be of type str')

        if user is not None and not isinstance(user, (bytes, str)):
            raise Exception('Expected user to be of type str')

        self.access = access
        self.display_name = display_name
        self.user = user
        self.unknown_fields = unknown_fields



class OperatorProvisioningInfo(Type):
    _toSchema = {'api_addresses': 'api-addresses', 'charm_storage': 'charm-storage', 'image_path': 'image-path', 'tags': 'tags', 'version': 'version'}
    _toPy = {'api-addresses': 'api_addresses', 'charm-storage': 'charm_storage', 'image-path': 'image_path', 'tags': 'tags', 'version': 'version'}
    def __init__(self, api_addresses=None, charm_storage=None, image_path=None, tags=None, version=None, **unknown_fields):
        '''
        api_addresses : typing.Sequence[str]
        charm_storage : KubernetesFilesystemParams
        image_path : str
        tags : typing.Mapping[str, str]
        version : Number
        '''
        if api_addresses is not None and not isinstance(api_addresses, list):
            raise Exception('Expected api_addresses to be of type Sequence')

        if charm_storage is not None and not isinstance(charm_storage, KubernetesFilesystemParams):
            raise Exception('Expected charm_storage to be of type KubernetesFilesystemParams')

        if image_path is not None and not isinstance(image_path, (bytes, str)):
            raise Exception('Expected image_path to be of type str')

        if tags is not None and not isinstance(tags, dict):
            raise Exception('Expected tags to be of type Mapping')

        if version is not None and not isinstance(version, Number):
            raise Exception('Expected version to be of type Number')

        self.api_addresses = api_addresses
        self.charm_storage = KubernetesFilesystemParams.from_json(charm_storage) if charm_storage else None
        self.image_path = image_path
        self.tags = tags
        self.version = Number.from_json(version) if version else None
        self.unknown_fields = unknown_fields



class Payload(Type):
    _toSchema = {'class_': 'class', 'id_': 'id', 'labels': 'labels', 'machine': 'machine', 'status': 'status', 'type_': 'type', 'unit': 'unit'}
    _toPy = {'class': 'class_', 'id': 'id_', 'labels': 'labels', 'machine': 'machine', 'status': 'status', 'type': 'type_', 'unit': 'unit'}
    def __init__(self, class_=None, id_=None, labels=None, machine=None, status=None, type_=None, unit=None, **unknown_fields):
        '''
        class_ : str
        id_ : str
        labels : typing.Sequence[str]
        machine : str
        status : str
        type_ : str
        unit : str
        '''
        if class_ is not None and not isinstance(class_, (bytes, str)):
            raise Exception('Expected class_ to be of type str')

        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        if labels is not None and not isinstance(labels, list):
            raise Exception('Expected labels to be of type Sequence')

        if machine is not None and not isinstance(machine, (bytes, str)):
            raise Exception('Expected machine to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        if unit is not None and not isinstance(unit, (bytes, str)):
            raise Exception('Expected unit to be of type str')

        self.class_ = class_
        self.id_ = id_
        self.labels = labels
        self.machine = machine
        self.status = status
        self.type_ = type_
        self.unit = unit
        self.unknown_fields = unknown_fields



class PayloadListArgs(Type):
    _toSchema = {'patterns': 'patterns'}
    _toPy = {'patterns': 'patterns'}
    def __init__(self, patterns=None, **unknown_fields):
        '''
        patterns : typing.Sequence[str]
        '''
        if patterns is not None and not isinstance(patterns, list):
            raise Exception('Expected patterns to be of type Sequence')

        self.patterns = patterns
        self.unknown_fields = unknown_fields



class PayloadListResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~Payload]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [Payload.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class PayloadResult(Type):
    _toSchema = {'entity': 'Entity', 'error': 'error', 'not_found': 'not-found', 'payload': 'payload', 'tag': 'tag'}
    _toPy = {'Entity': 'entity', 'error': 'error', 'not-found': 'not_found', 'payload': 'payload', 'tag': 'tag'}
    def __init__(self, entity=None, error=None, not_found=None, payload=None, tag=None, **unknown_fields):
        '''
        entity : Entity
        error : Error
        not_found : bool
        payload : Payload
        tag : str
        '''
        if entity is not None and not isinstance(entity, Entity):
            raise Exception('Expected entity to be of type Entity')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if not_found is not None and not isinstance(not_found, bool):
            raise Exception('Expected not_found to be of type bool')

        if payload is not None and not isinstance(payload, Payload):
            raise Exception('Expected payload to be of type Payload')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.entity = Entity.from_json(entity) if entity else None
        self.error = Error.from_json(error) if error else None
        self.not_found = not_found
        self.payload = Payload.from_json(payload) if payload else None
        self.tag = tag
        self.unknown_fields = unknown_fields



class PayloadResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~PayloadResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [PayloadResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class PhaseResult(Type):
    _toSchema = {'error': 'error', 'phase': 'phase'}
    _toPy = {'error': 'error', 'phase': 'phase'}
    def __init__(self, error=None, phase=None, **unknown_fields):
        '''
        error : Error
        phase : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if phase is not None and not isinstance(phase, (bytes, str)):
            raise Exception('Expected phase to be of type str')

        self.error = Error.from_json(error) if error else None
        self.phase = phase
        self.unknown_fields = unknown_fields



class PhaseResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~PhaseResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [PhaseResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class PinApplicationResult(Type):
    _toSchema = {'application_name': 'application-name', 'error': 'error'}
    _toPy = {'application-name': 'application_name', 'error': 'error'}
    def __init__(self, application_name=None, error=None, **unknown_fields):
        '''
        application_name : str
        error : Error
        '''
        if application_name is not None and not isinstance(application_name, (bytes, str)):
            raise Exception('Expected application_name to be of type str')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.application_name = application_name
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class PinApplicationsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~PinApplicationResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [PinApplicationResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class PinnedLeadershipResult(Type):
    _toSchema = {'result': 'result'}
    _toPy = {'result': 'result'}
    def __init__(self, result=None, **unknown_fields):
        '''
        result : typing.Sequence[str]
        '''
        if result is not None and not isinstance(result, list):
            raise Exception('Expected result to be of type Sequence')

        self.result = result
        self.unknown_fields = unknown_fields



class Placement(Type):
    _toSchema = {'directive': 'directive', 'scope': 'scope'}
    _toPy = {'directive': 'directive', 'scope': 'scope'}
    def __init__(self, directive=None, scope=None, **unknown_fields):
        '''
        directive : str
        scope : str
        '''
        if directive is not None and not isinstance(directive, (bytes, str)):
            raise Exception('Expected directive to be of type str')

        if scope is not None and not isinstance(scope, (bytes, str)):
            raise Exception('Expected scope to be of type str')

        self.directive = directive
        self.scope = scope
        self.unknown_fields = unknown_fields



class PortRange(Type):
    _toSchema = {'from_port': 'from-port', 'protocol': 'protocol', 'to_port': 'to-port'}
    _toPy = {'from-port': 'from_port', 'protocol': 'protocol', 'to-port': 'to_port'}
    def __init__(self, from_port=None, protocol=None, to_port=None, **unknown_fields):
        '''
        from_port : int
        protocol : str
        to_port : int
        '''
        if from_port is not None and not isinstance(from_port, int):
            raise Exception('Expected from_port to be of type int')

        if protocol is not None and not isinstance(protocol, (bytes, str)):
            raise Exception('Expected protocol to be of type str')

        if to_port is not None and not isinstance(to_port, int):
            raise Exception('Expected to_port to be of type int')

        self.from_port = from_port
        self.protocol = protocol
        self.to_port = to_port
        self.unknown_fields = unknown_fields



class PrivateAddress(Type):
    _toSchema = {'target': 'target'}
    _toPy = {'target': 'target'}
    def __init__(self, target=None, **unknown_fields):
        '''
        target : str
        '''
        if target is not None and not isinstance(target, (bytes, str)):
            raise Exception('Expected target to be of type str')

        self.target = target
        self.unknown_fields = unknown_fields



class PrivateAddressResults(Type):
    _toSchema = {'private_address': 'private-address'}
    _toPy = {'private-address': 'private_address'}
    def __init__(self, private_address=None, **unknown_fields):
        '''
        private_address : str
        '''
        if private_address is not None and not isinstance(private_address, (bytes, str)):
            raise Exception('Expected private_address to be of type str')

        self.private_address = private_address
        self.unknown_fields = unknown_fields



class ProfileChangeResult(Type):
    _toSchema = {'error': 'error', 'new_profile_name': 'new-profile-name', 'old_profile_name': 'old-profile-name', 'profile': 'profile', 'subordinate': 'subordinate'}
    _toPy = {'error': 'error', 'new-profile-name': 'new_profile_name', 'old-profile-name': 'old_profile_name', 'profile': 'profile', 'subordinate': 'subordinate'}
    def __init__(self, error=None, new_profile_name=None, old_profile_name=None, profile=None, subordinate=None, **unknown_fields):
        '''
        error : Error
        new_profile_name : str
        old_profile_name : str
        profile : CharmLXDProfile
        subordinate : bool
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if new_profile_name is not None and not isinstance(new_profile_name, (bytes, str)):
            raise Exception('Expected new_profile_name to be of type str')

        if old_profile_name is not None and not isinstance(old_profile_name, (bytes, str)):
            raise Exception('Expected old_profile_name to be of type str')

        if profile is not None and not isinstance(profile, CharmLXDProfile):
            raise Exception('Expected profile to be of type CharmLXDProfile')

        if subordinate is not None and not isinstance(subordinate, bool):
            raise Exception('Expected subordinate to be of type bool')

        self.error = Error.from_json(error) if error else None
        self.new_profile_name = new_profile_name
        self.old_profile_name = old_profile_name
        self.profile = CharmLXDProfile.from_json(profile) if profile else None
        self.subordinate = subordinate
        self.unknown_fields = unknown_fields



class ProfileChangeResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ProfileChangeResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ProfileChangeResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ProfileInfoResult(Type):
    _toSchema = {'application_name': 'application-name', 'error': 'error', 'profile': 'profile', 'revision': 'revision'}
    _toPy = {'application-name': 'application_name', 'error': 'error', 'profile': 'profile', 'revision': 'revision'}
    def __init__(self, application_name=None, error=None, profile=None, revision=None, **unknown_fields):
        '''
        application_name : str
        error : Error
        profile : CharmLXDProfile
        revision : int
        '''
        if application_name is not None and not isinstance(application_name, (bytes, str)):
            raise Exception('Expected application_name to be of type str')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if profile is not None and not isinstance(profile, CharmLXDProfile):
            raise Exception('Expected profile to be of type CharmLXDProfile')

        if revision is not None and not isinstance(revision, int):
            raise Exception('Expected revision to be of type int')

        self.application_name = application_name
        self.error = Error.from_json(error) if error else None
        self.profile = CharmLXDProfile.from_json(profile) if profile else None
        self.revision = revision
        self.unknown_fields = unknown_fields



class ProviderInterfaceInfo(Type):
    _toSchema = {'interface_name': 'interface-name', 'mac_address': 'mac-address', 'provider_id': 'provider-id'}
    _toPy = {'interface-name': 'interface_name', 'mac-address': 'mac_address', 'provider-id': 'provider_id'}
    def __init__(self, interface_name=None, mac_address=None, provider_id=None, **unknown_fields):
        '''
        interface_name : str
        mac_address : str
        provider_id : str
        '''
        if interface_name is not None and not isinstance(interface_name, (bytes, str)):
            raise Exception('Expected interface_name to be of type str')

        if mac_address is not None and not isinstance(mac_address, (bytes, str)):
            raise Exception('Expected mac_address to be of type str')

        if provider_id is not None and not isinstance(provider_id, (bytes, str)):
            raise Exception('Expected provider_id to be of type str')

        self.interface_name = interface_name
        self.mac_address = mac_address
        self.provider_id = provider_id
        self.unknown_fields = unknown_fields



class ProviderInterfaceInfoResult(Type):
    _toSchema = {'error': 'error', 'interfaces': 'interfaces', 'machine_tag': 'machine-tag'}
    _toPy = {'error': 'error', 'interfaces': 'interfaces', 'machine-tag': 'machine_tag'}
    def __init__(self, error=None, interfaces=None, machine_tag=None, **unknown_fields):
        '''
        error : Error
        interfaces : typing.Sequence[~ProviderInterfaceInfo]
        machine_tag : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if interfaces is not None and not isinstance(interfaces, list):
            raise Exception('Expected interfaces to be of type Sequence')

        if machine_tag is not None and not isinstance(machine_tag, (bytes, str)):
            raise Exception('Expected machine_tag to be of type str')

        self.error = Error.from_json(error) if error else None
        self.interfaces = [ProviderInterfaceInfo.from_json(o) for o in interfaces or []]
        self.machine_tag = machine_tag
        self.unknown_fields = unknown_fields



class ProviderInterfaceInfoResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ProviderInterfaceInfoResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ProviderInterfaceInfoResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ProviderSpace(Type):
    _toSchema = {'error': 'error', 'name': 'name', 'provider_id': 'provider-id', 'subnets': 'subnets'}
    _toPy = {'error': 'error', 'name': 'name', 'provider-id': 'provider_id', 'subnets': 'subnets'}
    def __init__(self, error=None, name=None, provider_id=None, subnets=None, **unknown_fields):
        '''
        error : Error
        name : str
        provider_id : str
        subnets : typing.Sequence[~Subnet]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if provider_id is not None and not isinstance(provider_id, (bytes, str)):
            raise Exception('Expected provider_id to be of type str')

        if subnets is not None and not isinstance(subnets, list):
            raise Exception('Expected subnets to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.name = name
        self.provider_id = provider_id
        self.subnets = [Subnet.from_json(o) for o in subnets or []]
        self.unknown_fields = unknown_fields



class ProvisioningInfo(Type):
    _toSchema = {'charm_lxd_profiles': 'charm-lxd-profiles', 'cloudinit_userdata': 'cloudinit-userdata', 'constraints': 'constraints', 'controller_config': 'controller-config', 'endpoint_bindings': 'endpoint-bindings', 'image_metadata': 'image-metadata', 'jobs': 'jobs', 'placement': 'placement', 'series': 'series', 'subnets_to_zones': 'subnets-to-zones', 'tags': 'tags', 'volume_attachments': 'volume-attachments', 'volumes': 'volumes'}
    _toPy = {'charm-lxd-profiles': 'charm_lxd_profiles', 'cloudinit-userdata': 'cloudinit_userdata', 'constraints': 'constraints', 'controller-config': 'controller_config', 'endpoint-bindings': 'endpoint_bindings', 'image-metadata': 'image_metadata', 'jobs': 'jobs', 'placement': 'placement', 'series': 'series', 'subnets-to-zones': 'subnets_to_zones', 'tags': 'tags', 'volume-attachments': 'volume_attachments', 'volumes': 'volumes'}
    def __init__(self, charm_lxd_profiles=None, cloudinit_userdata=None, constraints=None, controller_config=None, endpoint_bindings=None, image_metadata=None, jobs=None, placement=None, series=None, subnets_to_zones=None, tags=None, volume_attachments=None, volumes=None, **unknown_fields):
        '''
        charm_lxd_profiles : typing.Sequence[str]
        cloudinit_userdata : typing.Mapping[str, typing.Any]
        constraints : Value
        controller_config : typing.Mapping[str, typing.Any]
        endpoint_bindings : typing.Mapping[str, str]
        image_metadata : typing.Sequence[~CloudImageMetadata]
        jobs : typing.Sequence[str]
        placement : str
        series : str
        subnets_to_zones : typing.Sequence[str]
        tags : typing.Mapping[str, str]
        volume_attachments : typing.Sequence[~VolumeAttachmentParams]
        volumes : typing.Sequence[~VolumeParams]
        '''
        if charm_lxd_profiles is not None and not isinstance(charm_lxd_profiles, list):
            raise Exception('Expected charm_lxd_profiles to be of type Sequence')

        if cloudinit_userdata is not None and not isinstance(cloudinit_userdata, dict):
            raise Exception('Expected cloudinit_userdata to be of type Mapping')

        if constraints is not None and not isinstance(constraints, Value):
            raise Exception('Expected constraints to be of type Value')

        if controller_config is not None and not isinstance(controller_config, dict):
            raise Exception('Expected controller_config to be of type Mapping')

        if endpoint_bindings is not None and not isinstance(endpoint_bindings, dict):
            raise Exception('Expected endpoint_bindings to be of type Mapping')

        if image_metadata is not None and not isinstance(image_metadata, list):
            raise Exception('Expected image_metadata to be of type Sequence')

        if jobs is not None and not isinstance(jobs, list):
            raise Exception('Expected jobs to be of type Sequence')

        if placement is not None and not isinstance(placement, (bytes, str)):
            raise Exception('Expected placement to be of type str')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        if subnets_to_zones is not None and not isinstance(subnets_to_zones, list):
            raise Exception('Expected subnets_to_zones to be of type Sequence')

        if tags is not None and not isinstance(tags, dict):
            raise Exception('Expected tags to be of type Mapping')

        if volume_attachments is not None and not isinstance(volume_attachments, list):
            raise Exception('Expected volume_attachments to be of type Sequence')

        if volumes is not None and not isinstance(volumes, list):
            raise Exception('Expected volumes to be of type Sequence')

        self.charm_lxd_profiles = charm_lxd_profiles
        self.cloudinit_userdata = cloudinit_userdata
        self.constraints = Value.from_json(constraints) if constraints else None
        self.controller_config = controller_config
        self.endpoint_bindings = endpoint_bindings
        self.image_metadata = [CloudImageMetadata.from_json(o) for o in image_metadata or []]
        self.jobs = jobs
        self.placement = placement
        self.series = series
        self.subnets_to_zones = subnets_to_zones
        self.tags = tags
        self.volume_attachments = [VolumeAttachmentParams.from_json(o) for o in volume_attachments or []]
        self.volumes = [VolumeParams.from_json(o) for o in volumes or []]
        self.unknown_fields = unknown_fields



class ProvisioningInfoResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : ProvisioningInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, ProvisioningInfo):
            raise Exception('Expected result to be of type ProvisioningInfo')

        self.error = Error.from_json(error) if error else None
        self.result = ProvisioningInfo.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class ProvisioningInfoResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ProvisioningInfoResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ProvisioningInfoResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ProvisioningScriptParams(Type):
    _toSchema = {'data_dir': 'data-dir', 'disable_package_commands': 'disable-package-commands', 'machine_id': 'machine-id', 'nonce': 'nonce'}
    _toPy = {'data-dir': 'data_dir', 'disable-package-commands': 'disable_package_commands', 'machine-id': 'machine_id', 'nonce': 'nonce'}
    def __init__(self, data_dir=None, disable_package_commands=None, machine_id=None, nonce=None, **unknown_fields):
        '''
        data_dir : str
        disable_package_commands : bool
        machine_id : str
        nonce : str
        '''
        if data_dir is not None and not isinstance(data_dir, (bytes, str)):
            raise Exception('Expected data_dir to be of type str')

        if disable_package_commands is not None and not isinstance(disable_package_commands, bool):
            raise Exception('Expected disable_package_commands to be of type bool')

        if machine_id is not None and not isinstance(machine_id, (bytes, str)):
            raise Exception('Expected machine_id to be of type str')

        if nonce is not None and not isinstance(nonce, (bytes, str)):
            raise Exception('Expected nonce to be of type str')

        self.data_dir = data_dir
        self.disable_package_commands = disable_package_commands
        self.machine_id = machine_id
        self.nonce = nonce
        self.unknown_fields = unknown_fields



class ProvisioningScriptResult(Type):
    _toSchema = {'script': 'script'}
    _toPy = {'script': 'script'}
    def __init__(self, script=None, **unknown_fields):
        '''
        script : str
        '''
        if script is not None and not isinstance(script, (bytes, str)):
            raise Exception('Expected script to be of type str')

        self.script = script
        self.unknown_fields = unknown_fields



class ProxyConfig(Type):
    _toSchema = {'ftp': 'ftp', 'http': 'http', 'https': 'https', 'no_proxy': 'no-proxy'}
    _toPy = {'ftp': 'ftp', 'http': 'http', 'https': 'https', 'no-proxy': 'no_proxy'}
    def __init__(self, ftp=None, http=None, https=None, no_proxy=None, **unknown_fields):
        '''
        ftp : str
        http : str
        https : str
        no_proxy : str
        '''
        if ftp is not None and not isinstance(ftp, (bytes, str)):
            raise Exception('Expected ftp to be of type str')

        if http is not None and not isinstance(http, (bytes, str)):
            raise Exception('Expected http to be of type str')

        if https is not None and not isinstance(https, (bytes, str)):
            raise Exception('Expected https to be of type str')

        if no_proxy is not None and not isinstance(no_proxy, (bytes, str)):
            raise Exception('Expected no_proxy to be of type str')

        self.ftp = ftp
        self.http = http
        self.https = https
        self.no_proxy = no_proxy
        self.unknown_fields = unknown_fields



class ProxyConfigResult(Type):
    _toSchema = {'apt_proxy_settings': 'apt-proxy-settings', 'error': 'error', 'juju_proxy_settings': 'juju-proxy-settings', 'legacy_proxy_settings': 'legacy-proxy-settings', 'snap_proxy_settings': 'snap-proxy-settings', 'snap_store_assertions': 'snap-store-assertions', 'snap_store_id': 'snap-store-id'}
    _toPy = {'apt-proxy-settings': 'apt_proxy_settings', 'error': 'error', 'juju-proxy-settings': 'juju_proxy_settings', 'legacy-proxy-settings': 'legacy_proxy_settings', 'snap-proxy-settings': 'snap_proxy_settings', 'snap-store-assertions': 'snap_store_assertions', 'snap-store-id': 'snap_store_id'}
    def __init__(self, apt_proxy_settings=None, error=None, juju_proxy_settings=None, legacy_proxy_settings=None, snap_proxy_settings=None, snap_store_assertions=None, snap_store_id=None, **unknown_fields):
        '''
        apt_proxy_settings : ProxyConfig
        error : Error
        juju_proxy_settings : ProxyConfig
        legacy_proxy_settings : ProxyConfig
        snap_proxy_settings : ProxyConfig
        snap_store_assertions : str
        snap_store_id : str
        '''
        if apt_proxy_settings is not None and not isinstance(apt_proxy_settings, ProxyConfig):
            raise Exception('Expected apt_proxy_settings to be of type ProxyConfig')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if juju_proxy_settings is not None and not isinstance(juju_proxy_settings, ProxyConfig):
            raise Exception('Expected juju_proxy_settings to be of type ProxyConfig')

        if legacy_proxy_settings is not None and not isinstance(legacy_proxy_settings, ProxyConfig):
            raise Exception('Expected legacy_proxy_settings to be of type ProxyConfig')

        if snap_proxy_settings is not None and not isinstance(snap_proxy_settings, ProxyConfig):
            raise Exception('Expected snap_proxy_settings to be of type ProxyConfig')

        if snap_store_assertions is not None and not isinstance(snap_store_assertions, (bytes, str)):
            raise Exception('Expected snap_store_assertions to be of type str')

        if snap_store_id is not None and not isinstance(snap_store_id, (bytes, str)):
            raise Exception('Expected snap_store_id to be of type str')

        self.apt_proxy_settings = ProxyConfig.from_json(apt_proxy_settings) if apt_proxy_settings else None
        self.error = Error.from_json(error) if error else None
        self.juju_proxy_settings = ProxyConfig.from_json(juju_proxy_settings) if juju_proxy_settings else None
        self.legacy_proxy_settings = ProxyConfig.from_json(legacy_proxy_settings) if legacy_proxy_settings else None
        self.snap_proxy_settings = ProxyConfig.from_json(snap_proxy_settings) if snap_proxy_settings else None
        self.snap_store_assertions = snap_store_assertions
        self.snap_store_id = snap_store_id
        self.unknown_fields = unknown_fields



class ProxyConfigResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ProxyConfigResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ProxyConfigResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class PublicAddress(Type):
    _toSchema = {'target': 'target'}
    _toPy = {'target': 'target'}
    def __init__(self, target=None, **unknown_fields):
        '''
        target : str
        '''
        if target is not None and not isinstance(target, (bytes, str)):
            raise Exception('Expected target to be of type str')

        self.target = target
        self.unknown_fields = unknown_fields



class PublicAddressResults(Type):
    _toSchema = {'public_address': 'public-address'}
    _toPy = {'public-address': 'public_address'}
    def __init__(self, public_address=None, **unknown_fields):
        '''
        public_address : str
        '''
        if public_address is not None and not isinstance(public_address, (bytes, str)):
            raise Exception('Expected public_address to be of type str')

        self.public_address = public_address
        self.unknown_fields = unknown_fields



class QueryApplicationOffersResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ApplicationOfferAdminDetails]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ApplicationOfferAdminDetails.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RebootActionResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, (bytes, str)):
            raise Exception('Expected result to be of type str')

        self.error = Error.from_json(error) if error else None
        self.result = result
        self.unknown_fields = unknown_fields



class RebootActionResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~RebootActionResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [RebootActionResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RegionDefaults(Type):
    _toSchema = {'region_name': 'region-name', 'value': 'value'}
    _toPy = {'region-name': 'region_name', 'value': 'value'}
    def __init__(self, region_name=None, value=None, **unknown_fields):
        '''
        region_name : str
        value : typing.Mapping[str, typing.Any]
        '''
        if region_name is not None and not isinstance(region_name, (bytes, str)):
            raise Exception('Expected region_name to be of type str')

        if value is not None and not isinstance(value, dict):
            raise Exception('Expected value to be of type Mapping')

        self.region_name = region_name
        self.value = value
        self.unknown_fields = unknown_fields



class RegisterRemoteRelationArg(Type):
    _toSchema = {'application_token': 'application-token', 'local_endpoint_name': 'local-endpoint-name', 'macaroons': 'macaroons', 'offer_uuid': 'offer-uuid', 'relation_token': 'relation-token', 'remote_endpoint': 'remote-endpoint', 'remote_space': 'remote-space', 'source_model_tag': 'source-model-tag'}
    _toPy = {'application-token': 'application_token', 'local-endpoint-name': 'local_endpoint_name', 'macaroons': 'macaroons', 'offer-uuid': 'offer_uuid', 'relation-token': 'relation_token', 'remote-endpoint': 'remote_endpoint', 'remote-space': 'remote_space', 'source-model-tag': 'source_model_tag'}
    def __init__(self, application_token=None, local_endpoint_name=None, macaroons=None, offer_uuid=None, relation_token=None, remote_endpoint=None, remote_space=None, source_model_tag=None, **unknown_fields):
        '''
        application_token : str
        local_endpoint_name : str
        macaroons : typing.Sequence[~Macaroon]
        offer_uuid : str
        relation_token : str
        remote_endpoint : RemoteEndpoint
        remote_space : RemoteSpace
        source_model_tag : str
        '''
        if application_token is not None and not isinstance(application_token, (bytes, str)):
            raise Exception('Expected application_token to be of type str')

        if local_endpoint_name is not None and not isinstance(local_endpoint_name, (bytes, str)):
            raise Exception('Expected local_endpoint_name to be of type str')

        if macaroons is not None and not isinstance(macaroons, list):
            raise Exception('Expected macaroons to be of type Sequence')

        if offer_uuid is not None and not isinstance(offer_uuid, (bytes, str)):
            raise Exception('Expected offer_uuid to be of type str')

        if relation_token is not None and not isinstance(relation_token, (bytes, str)):
            raise Exception('Expected relation_token to be of type str')

        if remote_endpoint is not None and not isinstance(remote_endpoint, RemoteEndpoint):
            raise Exception('Expected remote_endpoint to be of type RemoteEndpoint')

        if remote_space is not None and not isinstance(remote_space, RemoteSpace):
            raise Exception('Expected remote_space to be of type RemoteSpace')

        if source_model_tag is not None and not isinstance(source_model_tag, (bytes, str)):
            raise Exception('Expected source_model_tag to be of type str')

        self.application_token = application_token
        self.local_endpoint_name = local_endpoint_name
        self.macaroons = [Macaroon.from_json(o) for o in macaroons or []]
        self.offer_uuid = offer_uuid
        self.relation_token = relation_token
        self.remote_endpoint = RemoteEndpoint.from_json(remote_endpoint) if remote_endpoint else None
        self.remote_space = RemoteSpace.from_json(remote_space) if remote_space else None
        self.source_model_tag = source_model_tag
        self.unknown_fields = unknown_fields



class RegisterRemoteRelationArgs(Type):
    _toSchema = {'relations': 'relations'}
    _toPy = {'relations': 'relations'}
    def __init__(self, relations=None, **unknown_fields):
        '''
        relations : typing.Sequence[~RegisterRemoteRelationArg]
        '''
        if relations is not None and not isinstance(relations, list):
            raise Exception('Expected relations to be of type Sequence')

        self.relations = [RegisterRemoteRelationArg.from_json(o) for o in relations or []]
        self.unknown_fields = unknown_fields



class RegisterRemoteRelationResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : RemoteRelationDetails
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, RemoteRelationDetails):
            raise Exception('Expected result to be of type RemoteRelationDetails')

        self.error = Error.from_json(error) if error else None
        self.result = RemoteRelationDetails.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class RegisterRemoteRelationResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~RegisterRemoteRelationResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [RegisterRemoteRelationResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RelationChange(Type):
    _toSchema = {'changedunits': 'changedunits', 'departedunits': 'departedunits', 'id_': 'id', 'life': 'life'}
    _toPy = {'changedunits': 'changedunits', 'departedunits': 'departedunits', 'id': 'id_', 'life': 'life'}
    def __init__(self, changedunits=None, departedunits=None, id_=None, life=None, **unknown_fields):
        '''
        changedunits : typing.Mapping[str, ~RelationUnitChange]
        departedunits : typing.Sequence[str]
        id_ : int
        life : str
        '''
        if changedunits is not None and not isinstance(changedunits, dict):
            raise Exception('Expected changedunits to be of type Mapping')

        if departedunits is not None and not isinstance(departedunits, list):
            raise Exception('Expected departedunits to be of type Sequence')

        if id_ is not None and not isinstance(id_, int):
            raise Exception('Expected id_ to be of type int')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        self.changedunits = changedunits
        self.departedunits = departedunits
        self.id_ = id_
        self.life = life
        self.unknown_fields = unknown_fields



class RelationIds(Type):
    _toSchema = {'relation_ids': 'relation-ids'}
    _toPy = {'relation-ids': 'relation_ids'}
    def __init__(self, relation_ids=None, **unknown_fields):
        '''
        relation_ids : typing.Sequence[int]
        '''
        if relation_ids is not None and not isinstance(relation_ids, list):
            raise Exception('Expected relation_ids to be of type Sequence')

        self.relation_ids = relation_ids
        self.unknown_fields = unknown_fields



class RelationLifeSuspendedStatusChange(Type):
    _toSchema = {'key': 'key', 'life': 'life', 'suspended': 'suspended', 'suspended_reason': 'suspended-reason'}
    _toPy = {'key': 'key', 'life': 'life', 'suspended': 'suspended', 'suspended-reason': 'suspended_reason'}
    def __init__(self, key=None, life=None, suspended=None, suspended_reason=None, **unknown_fields):
        '''
        key : str
        life : str
        suspended : bool
        suspended_reason : str
        '''
        if key is not None and not isinstance(key, (bytes, str)):
            raise Exception('Expected key to be of type str')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if suspended is not None and not isinstance(suspended, bool):
            raise Exception('Expected suspended to be of type bool')

        if suspended_reason is not None and not isinstance(suspended_reason, (bytes, str)):
            raise Exception('Expected suspended_reason to be of type str')

        self.key = key
        self.life = life
        self.suspended = suspended
        self.suspended_reason = suspended_reason
        self.unknown_fields = unknown_fields



class RelationLifeSuspendedStatusWatchResult(Type):
    _toSchema = {'changes': 'changes', 'error': 'error', 'watcher_id': 'watcher-id'}
    _toPy = {'changes': 'changes', 'error': 'error', 'watcher-id': 'watcher_id'}
    def __init__(self, changes=None, error=None, watcher_id=None, **unknown_fields):
        '''
        changes : typing.Sequence[~RelationLifeSuspendedStatusChange]
        error : Error
        watcher_id : str
        '''
        if changes is not None and not isinstance(changes, list):
            raise Exception('Expected changes to be of type Sequence')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if watcher_id is not None and not isinstance(watcher_id, (bytes, str)):
            raise Exception('Expected watcher_id to be of type str')

        self.changes = [RelationLifeSuspendedStatusChange.from_json(o) for o in changes or []]
        self.error = Error.from_json(error) if error else None
        self.watcher_id = watcher_id
        self.unknown_fields = unknown_fields



class RelationResult(Type):
    _toSchema = {'bool_': 'bool', 'endpoint': 'endpoint', 'error': 'error', 'id_': 'id', 'key': 'key', 'life': 'life', 'other_application': 'other-application'}
    _toPy = {'bool': 'bool_', 'endpoint': 'endpoint', 'error': 'error', 'id': 'id_', 'key': 'key', 'life': 'life', 'other-application': 'other_application'}
    def __init__(self, bool_=None, endpoint=None, error=None, id_=None, key=None, life=None, other_application=None, **unknown_fields):
        '''
        bool_ : bool
        endpoint : Endpoint
        error : Error
        id_ : int
        key : str
        life : str
        other_application : str
        '''
        if bool_ is not None and not isinstance(bool_, bool):
            raise Exception('Expected bool_ to be of type bool')

        if endpoint is not None and not isinstance(endpoint, Endpoint):
            raise Exception('Expected endpoint to be of type Endpoint')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if id_ is not None and not isinstance(id_, int):
            raise Exception('Expected id_ to be of type int')

        if key is not None and not isinstance(key, (bytes, str)):
            raise Exception('Expected key to be of type str')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if other_application is not None and not isinstance(other_application, (bytes, str)):
            raise Exception('Expected other_application to be of type str')

        self.bool_ = bool_
        self.endpoint = Endpoint.from_json(endpoint) if endpoint else None
        self.error = Error.from_json(error) if error else None
        self.id_ = id_
        self.key = key
        self.life = life
        self.other_application = other_application
        self.unknown_fields = unknown_fields



class RelationResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~RelationResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [RelationResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RelationStatus(Type):
    _toSchema = {'endpoints': 'endpoints', 'id_': 'id', 'interface': 'interface', 'key': 'key', 'scope': 'scope', 'status': 'status'}
    _toPy = {'endpoints': 'endpoints', 'id': 'id_', 'interface': 'interface', 'key': 'key', 'scope': 'scope', 'status': 'status'}
    def __init__(self, endpoints=None, id_=None, interface=None, key=None, scope=None, status=None, **unknown_fields):
        '''
        endpoints : typing.Sequence[~EndpointStatus]
        id_ : int
        interface : str
        key : str
        scope : str
        status : DetailedStatus
        '''
        if endpoints is not None and not isinstance(endpoints, list):
            raise Exception('Expected endpoints to be of type Sequence')

        if id_ is not None and not isinstance(id_, int):
            raise Exception('Expected id_ to be of type int')

        if interface is not None and not isinstance(interface, (bytes, str)):
            raise Exception('Expected interface to be of type str')

        if key is not None and not isinstance(key, (bytes, str)):
            raise Exception('Expected key to be of type str')

        if scope is not None and not isinstance(scope, (bytes, str)):
            raise Exception('Expected scope to be of type str')

        if status is not None and not isinstance(status, DetailedStatus):
            raise Exception('Expected status to be of type DetailedStatus')

        self.endpoints = [EndpointStatus.from_json(o) for o in endpoints or []]
        self.id_ = id_
        self.interface = interface
        self.key = key
        self.scope = scope
        self.status = DetailedStatus.from_json(status) if status else None
        self.unknown_fields = unknown_fields



class RelationStatusArg(Type):
    _toSchema = {'message': 'message', 'relation_id': 'relation-id', 'status': 'status', 'unit_tag': 'unit-tag'}
    _toPy = {'message': 'message', 'relation-id': 'relation_id', 'status': 'status', 'unit-tag': 'unit_tag'}
    def __init__(self, message=None, relation_id=None, status=None, unit_tag=None, **unknown_fields):
        '''
        message : str
        relation_id : int
        status : str
        unit_tag : str
        '''
        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        if relation_id is not None and not isinstance(relation_id, int):
            raise Exception('Expected relation_id to be of type int')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        if unit_tag is not None and not isinstance(unit_tag, (bytes, str)):
            raise Exception('Expected unit_tag to be of type str')

        self.message = message
        self.relation_id = relation_id
        self.status = status
        self.unit_tag = unit_tag
        self.unknown_fields = unknown_fields



class RelationStatusArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~RelationStatusArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [RelationStatusArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class RelationStatusWatchResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~RelationLifeSuspendedStatusWatchResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [RelationLifeSuspendedStatusWatchResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RelationSuspendedArg(Type):
    _toSchema = {'message': 'message', 'relation_id': 'relation-id', 'suspended': 'suspended'}
    _toPy = {'message': 'message', 'relation-id': 'relation_id', 'suspended': 'suspended'}
    def __init__(self, message=None, relation_id=None, suspended=None, **unknown_fields):
        '''
        message : str
        relation_id : int
        suspended : bool
        '''
        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        if relation_id is not None and not isinstance(relation_id, int):
            raise Exception('Expected relation_id to be of type int')

        if suspended is not None and not isinstance(suspended, bool):
            raise Exception('Expected suspended to be of type bool')

        self.message = message
        self.relation_id = relation_id
        self.suspended = suspended
        self.unknown_fields = unknown_fields



class RelationSuspendedArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~RelationSuspendedArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [RelationSuspendedArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class RelationUnit(Type):
    _toSchema = {'relation': 'relation', 'unit': 'unit'}
    _toPy = {'relation': 'relation', 'unit': 'unit'}
    def __init__(self, relation=None, unit=None, **unknown_fields):
        '''
        relation : str
        unit : str
        '''
        if relation is not None and not isinstance(relation, (bytes, str)):
            raise Exception('Expected relation to be of type str')

        if unit is not None and not isinstance(unit, (bytes, str)):
            raise Exception('Expected unit to be of type str')

        self.relation = relation
        self.unit = unit
        self.unknown_fields = unknown_fields



class RelationUnitChange(Type):
    _toSchema = {'settings': 'settings'}
    _toPy = {'settings': 'settings'}
    def __init__(self, settings=None, **unknown_fields):
        '''
        settings : typing.Mapping[str, typing.Any]
        '''
        if settings is not None and not isinstance(settings, dict):
            raise Exception('Expected settings to be of type Mapping')

        self.settings = settings
        self.unknown_fields = unknown_fields



class RelationUnitPair(Type):
    _toSchema = {'local_unit': 'local-unit', 'relation': 'relation', 'remote_unit': 'remote-unit'}
    _toPy = {'local-unit': 'local_unit', 'relation': 'relation', 'remote-unit': 'remote_unit'}
    def __init__(self, local_unit=None, relation=None, remote_unit=None, **unknown_fields):
        '''
        local_unit : str
        relation : str
        remote_unit : str
        '''
        if local_unit is not None and not isinstance(local_unit, (bytes, str)):
            raise Exception('Expected local_unit to be of type str')

        if relation is not None and not isinstance(relation, (bytes, str)):
            raise Exception('Expected relation to be of type str')

        if remote_unit is not None and not isinstance(remote_unit, (bytes, str)):
            raise Exception('Expected remote_unit to be of type str')

        self.local_unit = local_unit
        self.relation = relation
        self.remote_unit = remote_unit
        self.unknown_fields = unknown_fields



class RelationUnitPairs(Type):
    _toSchema = {'relation_unit_pairs': 'relation-unit-pairs'}
    _toPy = {'relation-unit-pairs': 'relation_unit_pairs'}
    def __init__(self, relation_unit_pairs=None, **unknown_fields):
        '''
        relation_unit_pairs : typing.Sequence[~RelationUnitPair]
        '''
        if relation_unit_pairs is not None and not isinstance(relation_unit_pairs, list):
            raise Exception('Expected relation_unit_pairs to be of type Sequence')

        self.relation_unit_pairs = [RelationUnitPair.from_json(o) for o in relation_unit_pairs or []]
        self.unknown_fields = unknown_fields



class RelationUnitSettings(Type):
    _toSchema = {'relation': 'relation', 'settings': 'settings', 'unit': 'unit'}
    _toPy = {'relation': 'relation', 'settings': 'settings', 'unit': 'unit'}
    def __init__(self, relation=None, settings=None, unit=None, **unknown_fields):
        '''
        relation : str
        settings : typing.Mapping[str, str]
        unit : str
        '''
        if relation is not None and not isinstance(relation, (bytes, str)):
            raise Exception('Expected relation to be of type str')

        if settings is not None and not isinstance(settings, dict):
            raise Exception('Expected settings to be of type Mapping')

        if unit is not None and not isinstance(unit, (bytes, str)):
            raise Exception('Expected unit to be of type str')

        self.relation = relation
        self.settings = settings
        self.unit = unit
        self.unknown_fields = unknown_fields



class RelationUnitStatus(Type):
    _toSchema = {'in_scope': 'in-scope', 'relation_tag': 'relation-tag', 'suspended': 'suspended'}
    _toPy = {'in-scope': 'in_scope', 'relation-tag': 'relation_tag', 'suspended': 'suspended'}
    def __init__(self, in_scope=None, relation_tag=None, suspended=None, **unknown_fields):
        '''
        in_scope : bool
        relation_tag : str
        suspended : bool
        '''
        if in_scope is not None and not isinstance(in_scope, bool):
            raise Exception('Expected in_scope to be of type bool')

        if relation_tag is not None and not isinstance(relation_tag, (bytes, str)):
            raise Exception('Expected relation_tag to be of type str')

        if suspended is not None and not isinstance(suspended, bool):
            raise Exception('Expected suspended to be of type bool')

        self.in_scope = in_scope
        self.relation_tag = relation_tag
        self.suspended = suspended
        self.unknown_fields = unknown_fields



class RelationUnitStatusResult(Type):
    _toSchema = {'error': 'error', 'results': 'results'}
    _toPy = {'error': 'error', 'results': 'results'}
    def __init__(self, error=None, results=None, **unknown_fields):
        '''
        error : Error
        results : typing.Sequence[~RelationUnitStatus]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.results = [RelationUnitStatus.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RelationUnitStatusResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~RelationUnitStatusResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [RelationUnitStatusResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RelationUnits(Type):
    _toSchema = {'relation_units': 'relation-units'}
    _toPy = {'relation-units': 'relation_units'}
    def __init__(self, relation_units=None, **unknown_fields):
        '''
        relation_units : typing.Sequence[~RelationUnit]
        '''
        if relation_units is not None and not isinstance(relation_units, list):
            raise Exception('Expected relation_units to be of type Sequence')

        self.relation_units = [RelationUnit.from_json(o) for o in relation_units or []]
        self.unknown_fields = unknown_fields



class RelationUnitsChange(Type):
    _toSchema = {'changed': 'changed', 'departed': 'departed'}
    _toPy = {'changed': 'changed', 'departed': 'departed'}
    def __init__(self, changed=None, departed=None, **unknown_fields):
        '''
        changed : typing.Mapping[str, ~UnitSettings]
        departed : typing.Sequence[str]
        '''
        if changed is not None and not isinstance(changed, dict):
            raise Exception('Expected changed to be of type Mapping')

        if departed is not None and not isinstance(departed, list):
            raise Exception('Expected departed to be of type Sequence')

        self.changed = changed
        self.departed = departed
        self.unknown_fields = unknown_fields



class RelationUnitsSettings(Type):
    _toSchema = {'relation_units': 'relation-units'}
    _toPy = {'relation-units': 'relation_units'}
    def __init__(self, relation_units=None, **unknown_fields):
        '''
        relation_units : typing.Sequence[~RelationUnitSettings]
        '''
        if relation_units is not None and not isinstance(relation_units, list):
            raise Exception('Expected relation_units to be of type Sequence')

        self.relation_units = [RelationUnitSettings.from_json(o) for o in relation_units or []]
        self.unknown_fields = unknown_fields



class RelationUnitsWatchResult(Type):
    _toSchema = {'changes': 'changes', 'error': 'error', 'watcher_id': 'watcher-id'}
    _toPy = {'changes': 'changes', 'error': 'error', 'watcher-id': 'watcher_id'}
    def __init__(self, changes=None, error=None, watcher_id=None, **unknown_fields):
        '''
        changes : RelationUnitsChange
        error : Error
        watcher_id : str
        '''
        if changes is not None and not isinstance(changes, RelationUnitsChange):
            raise Exception('Expected changes to be of type RelationUnitsChange')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if watcher_id is not None and not isinstance(watcher_id, (bytes, str)):
            raise Exception('Expected watcher_id to be of type str')

        self.changes = RelationUnitsChange.from_json(changes) if changes else None
        self.error = Error.from_json(error) if error else None
        self.watcher_id = watcher_id
        self.unknown_fields = unknown_fields



class RelationUnitsWatchResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~RelationUnitsWatchResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [RelationUnitsWatchResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RemoteApplication(Type):
    _toSchema = {'is_consumer_proxy': 'is-consumer-proxy', 'life': 'life', 'macaroon': 'macaroon', 'model_uuid': 'model-uuid', 'name': 'name', 'offer_uuid': 'offer-uuid', 'status': 'status'}
    _toPy = {'is-consumer-proxy': 'is_consumer_proxy', 'life': 'life', 'macaroon': 'macaroon', 'model-uuid': 'model_uuid', 'name': 'name', 'offer-uuid': 'offer_uuid', 'status': 'status'}
    def __init__(self, is_consumer_proxy=None, life=None, macaroon=None, model_uuid=None, name=None, offer_uuid=None, status=None, **unknown_fields):
        '''
        is_consumer_proxy : bool
        life : str
        macaroon : Macaroon
        model_uuid : str
        name : str
        offer_uuid : str
        status : str
        '''
        if is_consumer_proxy is not None and not isinstance(is_consumer_proxy, bool):
            raise Exception('Expected is_consumer_proxy to be of type bool')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if macaroon is not None and not isinstance(macaroon, Macaroon):
            raise Exception('Expected macaroon to be of type Macaroon')

        if model_uuid is not None and not isinstance(model_uuid, (bytes, str)):
            raise Exception('Expected model_uuid to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if offer_uuid is not None and not isinstance(offer_uuid, (bytes, str)):
            raise Exception('Expected offer_uuid to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        self.is_consumer_proxy = is_consumer_proxy
        self.life = life
        self.macaroon = Macaroon.from_json(macaroon) if macaroon else None
        self.model_uuid = model_uuid
        self.name = name
        self.offer_uuid = offer_uuid
        self.status = status
        self.unknown_fields = unknown_fields



class RemoteApplicationChange(Type):
    _toSchema = {'application_tag': 'application-tag', 'life': 'life', 'relations': 'relations'}
    _toPy = {'application-tag': 'application_tag', 'life': 'life', 'relations': 'relations'}
    def __init__(self, application_tag=None, life=None, relations=None, **unknown_fields):
        '''
        application_tag : str
        life : str
        relations : RemoteRelationsChange
        '''
        if application_tag is not None and not isinstance(application_tag, (bytes, str)):
            raise Exception('Expected application_tag to be of type str')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if relations is not None and not isinstance(relations, RemoteRelationsChange):
            raise Exception('Expected relations to be of type RemoteRelationsChange')

        self.application_tag = application_tag
        self.life = life
        self.relations = RemoteRelationsChange.from_json(relations) if relations else None
        self.unknown_fields = unknown_fields



class RemoteApplicationInfo(Type):
    _toSchema = {'description': 'description', 'endpoints': 'endpoints', 'icon_url_path': 'icon-url-path', 'model_tag': 'model-tag', 'name': 'name', 'offer_url': 'offer-url', 'source_model_label': 'source-model-label'}
    _toPy = {'description': 'description', 'endpoints': 'endpoints', 'icon-url-path': 'icon_url_path', 'model-tag': 'model_tag', 'name': 'name', 'offer-url': 'offer_url', 'source-model-label': 'source_model_label'}
    def __init__(self, description=None, endpoints=None, icon_url_path=None, model_tag=None, name=None, offer_url=None, source_model_label=None, **unknown_fields):
        '''
        description : str
        endpoints : typing.Sequence[~RemoteEndpoint]
        icon_url_path : str
        model_tag : str
        name : str
        offer_url : str
        source_model_label : str
        '''
        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if endpoints is not None and not isinstance(endpoints, list):
            raise Exception('Expected endpoints to be of type Sequence')

        if icon_url_path is not None and not isinstance(icon_url_path, (bytes, str)):
            raise Exception('Expected icon_url_path to be of type str')

        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception('Expected model_tag to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if offer_url is not None and not isinstance(offer_url, (bytes, str)):
            raise Exception('Expected offer_url to be of type str')

        if source_model_label is not None and not isinstance(source_model_label, (bytes, str)):
            raise Exception('Expected source_model_label to be of type str')

        self.description = description
        self.endpoints = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        self.icon_url_path = icon_url_path
        self.model_tag = model_tag
        self.name = name
        self.offer_url = offer_url
        self.source_model_label = source_model_label
        self.unknown_fields = unknown_fields



class RemoteApplicationInfoResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : RemoteApplicationInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, RemoteApplicationInfo):
            raise Exception('Expected result to be of type RemoteApplicationInfo')

        self.error = Error.from_json(error) if error else None
        self.result = RemoteApplicationInfo.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class RemoteApplicationInfoResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~RemoteApplicationInfoResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [RemoteApplicationInfoResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RemoteApplicationResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : RemoteApplication
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, RemoteApplication):
            raise Exception('Expected result to be of type RemoteApplication')

        self.error = Error.from_json(error) if error else None
        self.result = RemoteApplication.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class RemoteApplicationResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~RemoteApplicationResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [RemoteApplicationResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RemoteApplicationStatus(Type):
    _toSchema = {'endpoints': 'endpoints', 'err': 'err', 'life': 'life', 'offer_name': 'offer-name', 'offer_url': 'offer-url', 'relations': 'relations', 'status': 'status'}
    _toPy = {'endpoints': 'endpoints', 'err': 'err', 'life': 'life', 'offer-name': 'offer_name', 'offer-url': 'offer_url', 'relations': 'relations', 'status': 'status'}
    def __init__(self, endpoints=None, err=None, life=None, offer_name=None, offer_url=None, relations=None, status=None, **unknown_fields):
        '''
        endpoints : typing.Sequence[~RemoteEndpoint]
        err : Error
        life : str
        offer_name : str
        offer_url : str
        relations : typing.Sequence[str]
        status : DetailedStatus
        '''
        if endpoints is not None and not isinstance(endpoints, list):
            raise Exception('Expected endpoints to be of type Sequence')

        if err is not None and not isinstance(err, Error):
            raise Exception('Expected err to be of type Error')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if offer_name is not None and not isinstance(offer_name, (bytes, str)):
            raise Exception('Expected offer_name to be of type str')

        if offer_url is not None and not isinstance(offer_url, (bytes, str)):
            raise Exception('Expected offer_url to be of type str')

        if relations is not None and not isinstance(relations, list):
            raise Exception('Expected relations to be of type Sequence')

        if status is not None and not isinstance(status, DetailedStatus):
            raise Exception('Expected status to be of type DetailedStatus')

        self.endpoints = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        self.err = Error.from_json(err) if err else None
        self.life = life
        self.offer_name = offer_name
        self.offer_url = offer_url
        self.relations = relations
        self.status = DetailedStatus.from_json(status) if status else None
        self.unknown_fields = unknown_fields



class RemoteApplicationWatchResult(Type):
    _toSchema = {'change': 'change', 'error': 'error', 'id_': 'id'}
    _toPy = {'change': 'change', 'error': 'error', 'id': 'id_'}
    def __init__(self, change=None, error=None, id_=None, **unknown_fields):
        '''
        change : RemoteApplicationChange
        error : Error
        id_ : str
        '''
        if change is not None and not isinstance(change, RemoteApplicationChange):
            raise Exception('Expected change to be of type RemoteApplicationChange')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        self.change = RemoteApplicationChange.from_json(change) if change else None
        self.error = Error.from_json(error) if error else None
        self.id_ = id_
        self.unknown_fields = unknown_fields



class RemoteEndpoint(Type):
    _toSchema = {'interface': 'interface', 'limit': 'limit', 'name': 'name', 'role': 'role'}
    _toPy = {'interface': 'interface', 'limit': 'limit', 'name': 'name', 'role': 'role'}
    def __init__(self, interface=None, limit=None, name=None, role=None, **unknown_fields):
        '''
        interface : str
        limit : int
        name : str
        role : str
        '''
        if interface is not None and not isinstance(interface, (bytes, str)):
            raise Exception('Expected interface to be of type str')

        if limit is not None and not isinstance(limit, int):
            raise Exception('Expected limit to be of type int')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if role is not None and not isinstance(role, (bytes, str)):
            raise Exception('Expected role to be of type str')

        self.interface = interface
        self.limit = limit
        self.name = name
        self.role = role
        self.unknown_fields = unknown_fields



class RemoteEntityArg(Type):
    _toSchema = {'macaroons': 'macaroons', 'relation_token': 'relation-token'}
    _toPy = {'macaroons': 'macaroons', 'relation-token': 'relation_token'}
    def __init__(self, macaroons=None, relation_token=None, **unknown_fields):
        '''
        macaroons : typing.Sequence[~Macaroon]
        relation_token : str
        '''
        if macaroons is not None and not isinstance(macaroons, list):
            raise Exception('Expected macaroons to be of type Sequence')

        if relation_token is not None and not isinstance(relation_token, (bytes, str)):
            raise Exception('Expected relation_token to be of type str')

        self.macaroons = [Macaroon.from_json(o) for o in macaroons or []]
        self.relation_token = relation_token
        self.unknown_fields = unknown_fields



class RemoteEntityArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~RemoteEntityArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [RemoteEntityArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class RemoteEntityId(Type):
    _toSchema = {'model_uuid': 'model-uuid', 'token': 'token'}
    _toPy = {'model-uuid': 'model_uuid', 'token': 'token'}
    def __init__(self, model_uuid=None, token=None, **unknown_fields):
        '''
        model_uuid : str
        token : str
        '''
        if model_uuid is not None and not isinstance(model_uuid, (bytes, str)):
            raise Exception('Expected model_uuid to be of type str')

        if token is not None and not isinstance(token, (bytes, str)):
            raise Exception('Expected token to be of type str')

        self.model_uuid = model_uuid
        self.token = token
        self.unknown_fields = unknown_fields



class RemoteEntityTokenArg(Type):
    _toSchema = {'tag': 'tag', 'token': 'token'}
    _toPy = {'tag': 'tag', 'token': 'token'}
    def __init__(self, tag=None, token=None, **unknown_fields):
        '''
        tag : str
        token : str
        '''
        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        if token is not None and not isinstance(token, (bytes, str)):
            raise Exception('Expected token to be of type str')

        self.tag = tag
        self.token = token
        self.unknown_fields = unknown_fields



class RemoteEntityTokenArgs(Type):
    _toSchema = {'args': 'Args'}
    _toPy = {'Args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~RemoteEntityTokenArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [RemoteEntityTokenArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class RemoteRelation(Type):
    _toSchema = {'application_name': 'application-name', 'endpoint': 'endpoint', 'id_': 'id', 'key': 'key', 'life': 'life', 'remote_application_name': 'remote-application-name', 'remote_endpoint_name': 'remote-endpoint-name', 'source_model_uuid': 'source-model-uuid', 'suspended': 'suspended'}
    _toPy = {'application-name': 'application_name', 'endpoint': 'endpoint', 'id': 'id_', 'key': 'key', 'life': 'life', 'remote-application-name': 'remote_application_name', 'remote-endpoint-name': 'remote_endpoint_name', 'source-model-uuid': 'source_model_uuid', 'suspended': 'suspended'}
    def __init__(self, application_name=None, endpoint=None, id_=None, key=None, life=None, remote_application_name=None, remote_endpoint_name=None, source_model_uuid=None, suspended=None, **unknown_fields):
        '''
        application_name : str
        endpoint : RemoteEndpoint
        id_ : int
        key : str
        life : str
        remote_application_name : str
        remote_endpoint_name : str
        source_model_uuid : str
        suspended : bool
        '''
        if application_name is not None and not isinstance(application_name, (bytes, str)):
            raise Exception('Expected application_name to be of type str')

        if endpoint is not None and not isinstance(endpoint, RemoteEndpoint):
            raise Exception('Expected endpoint to be of type RemoteEndpoint')

        if id_ is not None and not isinstance(id_, int):
            raise Exception('Expected id_ to be of type int')

        if key is not None and not isinstance(key, (bytes, str)):
            raise Exception('Expected key to be of type str')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if remote_application_name is not None and not isinstance(remote_application_name, (bytes, str)):
            raise Exception('Expected remote_application_name to be of type str')

        if remote_endpoint_name is not None and not isinstance(remote_endpoint_name, (bytes, str)):
            raise Exception('Expected remote_endpoint_name to be of type str')

        if source_model_uuid is not None and not isinstance(source_model_uuid, (bytes, str)):
            raise Exception('Expected source_model_uuid to be of type str')

        if suspended is not None and not isinstance(suspended, bool):
            raise Exception('Expected suspended to be of type bool')

        self.application_name = application_name
        self.endpoint = RemoteEndpoint.from_json(endpoint) if endpoint else None
        self.id_ = id_
        self.key = key
        self.life = life
        self.remote_application_name = remote_application_name
        self.remote_endpoint_name = remote_endpoint_name
        self.source_model_uuid = source_model_uuid
        self.suspended = suspended
        self.unknown_fields = unknown_fields



class RemoteRelationChange(Type):
    _toSchema = {'changed_units': 'changed-units', 'departed_units': 'departed-units', 'id_': 'id', 'life': 'life'}
    _toPy = {'changed-units': 'changed_units', 'departed-units': 'departed_units', 'id': 'id_', 'life': 'life'}
    def __init__(self, changed_units=None, departed_units=None, id_=None, life=None, **unknown_fields):
        '''
        changed_units : typing.Mapping[str, ~RemoteRelationUnitChange]
        departed_units : typing.Sequence[str]
        id_ : int
        life : str
        '''
        if changed_units is not None and not isinstance(changed_units, dict):
            raise Exception('Expected changed_units to be of type Mapping')

        if departed_units is not None and not isinstance(departed_units, list):
            raise Exception('Expected departed_units to be of type Sequence')

        if id_ is not None and not isinstance(id_, int):
            raise Exception('Expected id_ to be of type int')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        self.changed_units = changed_units
        self.departed_units = departed_units
        self.id_ = id_
        self.life = life
        self.unknown_fields = unknown_fields



class RemoteRelationChangeEvent(Type):
    _toSchema = {'application_token': 'application-token', 'changed_units': 'changed-units', 'departed_units': 'departed-units', 'force_cleanup': 'force-cleanup', 'life': 'life', 'macaroons': 'macaroons', 'relation_token': 'relation-token', 'suspended': 'suspended', 'suspended_reason': 'suspended-reason'}
    _toPy = {'application-token': 'application_token', 'changed-units': 'changed_units', 'departed-units': 'departed_units', 'force-cleanup': 'force_cleanup', 'life': 'life', 'macaroons': 'macaroons', 'relation-token': 'relation_token', 'suspended': 'suspended', 'suspended-reason': 'suspended_reason'}
    def __init__(self, application_token=None, changed_units=None, departed_units=None, force_cleanup=None, life=None, macaroons=None, relation_token=None, suspended=None, suspended_reason=None, **unknown_fields):
        '''
        application_token : str
        changed_units : typing.Sequence[~RemoteRelationUnitChange]
        departed_units : typing.Sequence[int]
        force_cleanup : bool
        life : str
        macaroons : typing.Sequence[~Macaroon]
        relation_token : str
        suspended : bool
        suspended_reason : str
        '''
        if application_token is not None and not isinstance(application_token, (bytes, str)):
            raise Exception('Expected application_token to be of type str')

        if changed_units is not None and not isinstance(changed_units, list):
            raise Exception('Expected changed_units to be of type Sequence')

        if departed_units is not None and not isinstance(departed_units, list):
            raise Exception('Expected departed_units to be of type Sequence')

        if force_cleanup is not None and not isinstance(force_cleanup, bool):
            raise Exception('Expected force_cleanup to be of type bool')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if macaroons is not None and not isinstance(macaroons, list):
            raise Exception('Expected macaroons to be of type Sequence')

        if relation_token is not None and not isinstance(relation_token, (bytes, str)):
            raise Exception('Expected relation_token to be of type str')

        if suspended is not None and not isinstance(suspended, bool):
            raise Exception('Expected suspended to be of type bool')

        if suspended_reason is not None and not isinstance(suspended_reason, (bytes, str)):
            raise Exception('Expected suspended_reason to be of type str')

        self.application_token = application_token
        self.changed_units = [RemoteRelationUnitChange.from_json(o) for o in changed_units or []]
        self.departed_units = departed_units
        self.force_cleanup = force_cleanup
        self.life = life
        self.macaroons = [Macaroon.from_json(o) for o in macaroons or []]
        self.relation_token = relation_token
        self.suspended = suspended
        self.suspended_reason = suspended_reason
        self.unknown_fields = unknown_fields



class RemoteRelationDetails(Type):
    _toSchema = {'macaroon': 'macaroon', 'relation_token': 'relation-token'}
    _toPy = {'macaroon': 'macaroon', 'relation-token': 'relation_token'}
    def __init__(self, macaroon=None, relation_token=None, **unknown_fields):
        '''
        macaroon : Macaroon
        relation_token : str
        '''
        if macaroon is not None and not isinstance(macaroon, Macaroon):
            raise Exception('Expected macaroon to be of type Macaroon')

        if relation_token is not None and not isinstance(relation_token, (bytes, str)):
            raise Exception('Expected relation_token to be of type str')

        self.macaroon = Macaroon.from_json(macaroon) if macaroon else None
        self.relation_token = relation_token
        self.unknown_fields = unknown_fields



class RemoteRelationResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : RemoteRelation
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, RemoteRelation):
            raise Exception('Expected result to be of type RemoteRelation')

        self.error = Error.from_json(error) if error else None
        self.result = RemoteRelation.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class RemoteRelationResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~RemoteRelationResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [RemoteRelationResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RemoteRelationUnit(Type):
    _toSchema = {'macaroons': 'macaroons', 'relation_token': 'relation-token', 'unit': 'unit'}
    _toPy = {'macaroons': 'macaroons', 'relation-token': 'relation_token', 'unit': 'unit'}
    def __init__(self, macaroons=None, relation_token=None, unit=None, **unknown_fields):
        '''
        macaroons : typing.Sequence[~Macaroon]
        relation_token : str
        unit : str
        '''
        if macaroons is not None and not isinstance(macaroons, list):
            raise Exception('Expected macaroons to be of type Sequence')

        if relation_token is not None and not isinstance(relation_token, (bytes, str)):
            raise Exception('Expected relation_token to be of type str')

        if unit is not None and not isinstance(unit, (bytes, str)):
            raise Exception('Expected unit to be of type str')

        self.macaroons = [Macaroon.from_json(o) for o in macaroons or []]
        self.relation_token = relation_token
        self.unit = unit
        self.unknown_fields = unknown_fields



class RemoteRelationUnitChange(Type):
    _toSchema = {'settings': 'settings', 'unit_id': 'unit-id'}
    _toPy = {'settings': 'settings', 'unit-id': 'unit_id'}
    def __init__(self, settings=None, unit_id=None, **unknown_fields):
        '''
        settings : typing.Mapping[str, typing.Any]
        unit_id : int
        '''
        if settings is not None and not isinstance(settings, dict):
            raise Exception('Expected settings to be of type Mapping')

        if unit_id is not None and not isinstance(unit_id, int):
            raise Exception('Expected unit_id to be of type int')

        self.settings = settings
        self.unit_id = unit_id
        self.unknown_fields = unknown_fields



class RemoteRelationUnits(Type):
    _toSchema = {'relation_units': 'relation-units'}
    _toPy = {'relation-units': 'relation_units'}
    def __init__(self, relation_units=None, **unknown_fields):
        '''
        relation_units : typing.Sequence[~RemoteRelationUnit]
        '''
        if relation_units is not None and not isinstance(relation_units, list):
            raise Exception('Expected relation_units to be of type Sequence')

        self.relation_units = [RemoteRelationUnit.from_json(o) for o in relation_units or []]
        self.unknown_fields = unknown_fields



class RemoteRelationsChange(Type):
    _toSchema = {'changed': 'changed', 'initial': 'initial', 'removed': 'removed'}
    _toPy = {'changed': 'changed', 'initial': 'initial', 'removed': 'removed'}
    def __init__(self, changed=None, initial=None, removed=None, **unknown_fields):
        '''
        changed : typing.Sequence[~RemoteRelationChange]
        initial : bool
        removed : typing.Sequence[int]
        '''
        if changed is not None and not isinstance(changed, list):
            raise Exception('Expected changed to be of type Sequence')

        if initial is not None and not isinstance(initial, bool):
            raise Exception('Expected initial to be of type bool')

        if removed is not None and not isinstance(removed, list):
            raise Exception('Expected removed to be of type Sequence')

        self.changed = [RemoteRelationChange.from_json(o) for o in changed or []]
        self.initial = initial
        self.removed = removed
        self.unknown_fields = unknown_fields



class RemoteRelationsChanges(Type):
    _toSchema = {'changes': 'changes'}
    _toPy = {'changes': 'changes'}
    def __init__(self, changes=None, **unknown_fields):
        '''
        changes : typing.Sequence[~RemoteRelationChangeEvent]
        '''
        if changes is not None and not isinstance(changes, list):
            raise Exception('Expected changes to be of type Sequence')

        self.changes = [RemoteRelationChangeEvent.from_json(o) for o in changes or []]
        self.unknown_fields = unknown_fields



class RemoteRelationsWatchResult(Type):
    _toSchema = {'change': 'change', 'error': 'error', 'remoterelationswatcherid': 'RemoteRelationsWatcherId'}
    _toPy = {'RemoteRelationsWatcherId': 'remoterelationswatcherid', 'change': 'change', 'error': 'error'}
    def __init__(self, remoterelationswatcherid=None, change=None, error=None, **unknown_fields):
        '''
        remoterelationswatcherid : str
        change : RemoteRelationsChange
        error : Error
        '''
        if remoterelationswatcherid is not None and not isinstance(remoterelationswatcherid, (bytes, str)):
            raise Exception('Expected remoterelationswatcherid to be of type str')

        if change is not None and not isinstance(change, RemoteRelationsChange):
            raise Exception('Expected change to be of type RemoteRelationsChange')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.remoterelationswatcherid = remoterelationswatcherid
        self.change = RemoteRelationsChange.from_json(change) if change else None
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class RemoteSpace(Type):
    _toSchema = {'cloud_type': 'cloud-type', 'name': 'name', 'provider_attributes': 'provider-attributes', 'provider_id': 'provider-id', 'subnets': 'subnets'}
    _toPy = {'cloud-type': 'cloud_type', 'name': 'name', 'provider-attributes': 'provider_attributes', 'provider-id': 'provider_id', 'subnets': 'subnets'}
    def __init__(self, cloud_type=None, name=None, provider_attributes=None, provider_id=None, subnets=None, **unknown_fields):
        '''
        cloud_type : str
        name : str
        provider_attributes : typing.Mapping[str, typing.Any]
        provider_id : str
        subnets : typing.Sequence[~Subnet]
        '''
        if cloud_type is not None and not isinstance(cloud_type, (bytes, str)):
            raise Exception('Expected cloud_type to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if provider_attributes is not None and not isinstance(provider_attributes, dict):
            raise Exception('Expected provider_attributes to be of type Mapping')

        if provider_id is not None and not isinstance(provider_id, (bytes, str)):
            raise Exception('Expected provider_id to be of type str')

        if subnets is not None and not isinstance(subnets, list):
            raise Exception('Expected subnets to be of type Sequence')

        self.cloud_type = cloud_type
        self.name = name
        self.provider_attributes = provider_attributes
        self.provider_id = provider_id
        self.subnets = [Subnet.from_json(o) for o in subnets or []]
        self.unknown_fields = unknown_fields



class RemoveBlocksArgs(Type):
    _toSchema = {'all_': 'all'}
    _toPy = {'all': 'all_'}
    def __init__(self, all_=None, **unknown_fields):
        '''
        all_ : bool
        '''
        if all_ is not None and not isinstance(all_, bool):
            raise Exception('Expected all_ to be of type bool')

        self.all_ = all_
        self.unknown_fields = unknown_fields



class RemoveFilesystemParams(Type):
    _toSchema = {'destroy': 'destroy', 'filesystem_id': 'filesystem-id', 'provider': 'provider'}
    _toPy = {'destroy': 'destroy', 'filesystem-id': 'filesystem_id', 'provider': 'provider'}
    def __init__(self, destroy=None, filesystem_id=None, provider=None, **unknown_fields):
        '''
        destroy : bool
        filesystem_id : str
        provider : str
        '''
        if destroy is not None and not isinstance(destroy, bool):
            raise Exception('Expected destroy to be of type bool')

        if filesystem_id is not None and not isinstance(filesystem_id, (bytes, str)):
            raise Exception('Expected filesystem_id to be of type str')

        if provider is not None and not isinstance(provider, (bytes, str)):
            raise Exception('Expected provider to be of type str')

        self.destroy = destroy
        self.filesystem_id = filesystem_id
        self.provider = provider
        self.unknown_fields = unknown_fields



class RemoveFilesystemParamsResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : RemoveFilesystemParams
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, RemoveFilesystemParams):
            raise Exception('Expected result to be of type RemoveFilesystemParams')

        self.error = Error.from_json(error) if error else None
        self.result = RemoveFilesystemParams.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class RemoveFilesystemParamsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~RemoveFilesystemParamsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [RemoveFilesystemParamsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RemoveStorage(Type):
    _toSchema = {'storage': 'storage'}
    _toPy = {'storage': 'storage'}
    def __init__(self, storage=None, **unknown_fields):
        '''
        storage : typing.Sequence[~RemoveStorageInstance]
        '''
        if storage is not None and not isinstance(storage, list):
            raise Exception('Expected storage to be of type Sequence')

        self.storage = [RemoveStorageInstance.from_json(o) for o in storage or []]
        self.unknown_fields = unknown_fields



class RemoveStorageInstance(Type):
    _toSchema = {'destroy_attachments': 'destroy-attachments', 'destroy_storage': 'destroy-storage', 'force': 'force', 'max_wait': 'max-wait', 'tag': 'tag'}
    _toPy = {'destroy-attachments': 'destroy_attachments', 'destroy-storage': 'destroy_storage', 'force': 'force', 'max-wait': 'max_wait', 'tag': 'tag'}
    def __init__(self, destroy_attachments=None, destroy_storage=None, force=None, max_wait=None, tag=None, **unknown_fields):
        '''
        destroy_attachments : bool
        destroy_storage : bool
        force : bool
        max_wait : int
        tag : str
        '''
        if destroy_attachments is not None and not isinstance(destroy_attachments, bool):
            raise Exception('Expected destroy_attachments to be of type bool')

        if destroy_storage is not None and not isinstance(destroy_storage, bool):
            raise Exception('Expected destroy_storage to be of type bool')

        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if max_wait is not None and not isinstance(max_wait, int):
            raise Exception('Expected max_wait to be of type int')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.destroy_attachments = destroy_attachments
        self.destroy_storage = destroy_storage
        self.force = force
        self.max_wait = max_wait
        self.tag = tag
        self.unknown_fields = unknown_fields



class RemoveVolumeParams(Type):
    _toSchema = {'destroy': 'destroy', 'provider': 'provider', 'volume_id': 'volume-id'}
    _toPy = {'destroy': 'destroy', 'provider': 'provider', 'volume-id': 'volume_id'}
    def __init__(self, destroy=None, provider=None, volume_id=None, **unknown_fields):
        '''
        destroy : bool
        provider : str
        volume_id : str
        '''
        if destroy is not None and not isinstance(destroy, bool):
            raise Exception('Expected destroy to be of type bool')

        if provider is not None and not isinstance(provider, (bytes, str)):
            raise Exception('Expected provider to be of type str')

        if volume_id is not None and not isinstance(volume_id, (bytes, str)):
            raise Exception('Expected volume_id to be of type str')

        self.destroy = destroy
        self.provider = provider
        self.volume_id = volume_id
        self.unknown_fields = unknown_fields



class RemoveVolumeParamsResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : RemoveVolumeParams
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, RemoveVolumeParams):
            raise Exception('Expected result to be of type RemoveVolumeParams')

        self.error = Error.from_json(error) if error else None
        self.result = RemoveVolumeParams.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class RemoveVolumeParamsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~RemoveVolumeParamsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [RemoveVolumeParamsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ResolveCharmResult(Type):
    _toSchema = {'error': 'error', 'url': 'url'}
    _toPy = {'error': 'error', 'url': 'url'}
    def __init__(self, error=None, url=None, **unknown_fields):
        '''
        error : str
        url : str
        '''
        if error is not None and not isinstance(error, (bytes, str)):
            raise Exception('Expected error to be of type str')

        if url is not None and not isinstance(url, (bytes, str)):
            raise Exception('Expected url to be of type str')

        self.error = error
        self.url = url
        self.unknown_fields = unknown_fields



class ResolveCharmResults(Type):
    _toSchema = {'urls': 'urls'}
    _toPy = {'urls': 'urls'}
    def __init__(self, urls=None, **unknown_fields):
        '''
        urls : typing.Sequence[~ResolveCharmResult]
        '''
        if urls is not None and not isinstance(urls, list):
            raise Exception('Expected urls to be of type Sequence')

        self.urls = [ResolveCharmResult.from_json(o) for o in urls or []]
        self.unknown_fields = unknown_fields



class ResolveCharms(Type):
    _toSchema = {'references': 'references'}
    _toPy = {'references': 'references'}
    def __init__(self, references=None, **unknown_fields):
        '''
        references : typing.Sequence[str]
        '''
        if references is not None and not isinstance(references, list):
            raise Exception('Expected references to be of type Sequence')

        self.references = references
        self.unknown_fields = unknown_fields



class Resolved(Type):
    _toSchema = {'retry': 'retry', 'unit_name': 'unit-name'}
    _toPy = {'retry': 'retry', 'unit-name': 'unit_name'}
    def __init__(self, retry=None, unit_name=None, **unknown_fields):
        '''
        retry : bool
        unit_name : str
        '''
        if retry is not None and not isinstance(retry, bool):
            raise Exception('Expected retry to be of type bool')

        if unit_name is not None and not isinstance(unit_name, (bytes, str)):
            raise Exception('Expected unit_name to be of type str')

        self.retry = retry
        self.unit_name = unit_name
        self.unknown_fields = unknown_fields



class ResolvedModeResult(Type):
    _toSchema = {'error': 'error', 'mode': 'mode'}
    _toPy = {'error': 'error', 'mode': 'mode'}
    def __init__(self, error=None, mode=None, **unknown_fields):
        '''
        error : Error
        mode : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if mode is not None and not isinstance(mode, (bytes, str)):
            raise Exception('Expected mode to be of type str')

        self.error = Error.from_json(error) if error else None
        self.mode = mode
        self.unknown_fields = unknown_fields



class ResolvedModeResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ResolvedModeResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ResolvedModeResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class Resource(Type):
    _toSchema = {'application': 'application', 'charmresource': 'CharmResource', 'description': 'description', 'fingerprint': 'fingerprint', 'id_': 'id', 'name': 'name', 'origin': 'origin', 'path': 'path', 'pending_id': 'pending-id', 'revision': 'revision', 'size': 'size', 'timestamp': 'timestamp', 'type_': 'type', 'username': 'username'}
    _toPy = {'CharmResource': 'charmresource', 'application': 'application', 'description': 'description', 'fingerprint': 'fingerprint', 'id': 'id_', 'name': 'name', 'origin': 'origin', 'path': 'path', 'pending-id': 'pending_id', 'revision': 'revision', 'size': 'size', 'timestamp': 'timestamp', 'type': 'type_', 'username': 'username'}
    def __init__(self, charmresource=None, application=None, description=None, fingerprint=None, id_=None, name=None, origin=None, path=None, pending_id=None, revision=None, size=None, timestamp=None, type_=None, username=None, **unknown_fields):
        '''
        charmresource : CharmResource
        application : str
        description : str
        fingerprint : typing.Sequence[int]
        id_ : str
        name : str
        origin : str
        path : str
        pending_id : str
        revision : int
        size : int
        timestamp : str
        type_ : str
        username : str
        '''
        if charmresource is not None and not isinstance(charmresource, CharmResource):
            raise Exception('Expected charmresource to be of type CharmResource')

        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if fingerprint is not None and not isinstance(fingerprint, list):
            raise Exception('Expected fingerprint to be of type Sequence')

        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if origin is not None and not isinstance(origin, (bytes, str)):
            raise Exception('Expected origin to be of type str')

        if path is not None and not isinstance(path, (bytes, str)):
            raise Exception('Expected path to be of type str')

        if pending_id is not None and not isinstance(pending_id, (bytes, str)):
            raise Exception('Expected pending_id to be of type str')

        if revision is not None and not isinstance(revision, int):
            raise Exception('Expected revision to be of type int')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if timestamp is not None and not isinstance(timestamp, (bytes, str)):
            raise Exception('Expected timestamp to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        if username is not None and not isinstance(username, (bytes, str)):
            raise Exception('Expected username to be of type str')

        self.charmresource = CharmResource.from_json(charmresource) if charmresource else None
        self.application = application
        self.description = description
        self.fingerprint = fingerprint
        self.id_ = id_
        self.name = name
        self.origin = origin
        self.path = path
        self.pending_id = pending_id
        self.revision = revision
        self.size = size
        self.timestamp = timestamp
        self.type_ = type_
        self.username = username
        self.unknown_fields = unknown_fields



class ResourceResult(Type):
    _toSchema = {'errorresult': 'ErrorResult', 'resource': 'resource'}
    _toPy = {'ErrorResult': 'errorresult', 'resource': 'resource'}
    def __init__(self, errorresult=None, resource=None, **unknown_fields):
        '''
        errorresult : ErrorResult
        resource : Resource
        '''
        if errorresult is not None and not isinstance(errorresult, ErrorResult):
            raise Exception('Expected errorresult to be of type ErrorResult')

        if resource is not None and not isinstance(resource, Resource):
            raise Exception('Expected resource to be of type Resource')

        self.errorresult = ErrorResult.from_json(errorresult) if errorresult else None
        self.resource = Resource.from_json(resource) if resource else None
        self.unknown_fields = unknown_fields



class ResourcesResult(Type):
    _toSchema = {'charm_store_resources': 'charm-store-resources', 'error': 'error', 'errorresult': 'ErrorResult', 'resources': 'resources', 'unit_resources': 'unit-resources'}
    _toPy = {'ErrorResult': 'errorresult', 'charm-store-resources': 'charm_store_resources', 'error': 'error', 'resources': 'resources', 'unit-resources': 'unit_resources'}
    def __init__(self, errorresult=None, charm_store_resources=None, error=None, resources=None, unit_resources=None, **unknown_fields):
        '''
        errorresult : ErrorResult
        charm_store_resources : typing.Sequence[~CharmResource]
        error : Error
        resources : typing.Sequence[~Resource]
        unit_resources : typing.Sequence[~UnitResources]
        '''
        if errorresult is not None and not isinstance(errorresult, ErrorResult):
            raise Exception('Expected errorresult to be of type ErrorResult')

        if charm_store_resources is not None and not isinstance(charm_store_resources, list):
            raise Exception('Expected charm_store_resources to be of type Sequence')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if resources is not None and not isinstance(resources, list):
            raise Exception('Expected resources to be of type Sequence')

        if unit_resources is not None and not isinstance(unit_resources, list):
            raise Exception('Expected unit_resources to be of type Sequence')

        self.errorresult = ErrorResult.from_json(errorresult) if errorresult else None
        self.charm_store_resources = [CharmResource.from_json(o) for o in charm_store_resources or []]
        self.error = Error.from_json(error) if error else None
        self.resources = [Resource.from_json(o) for o in resources or []]
        self.unit_resources = [UnitResources.from_json(o) for o in unit_resources or []]
        self.unknown_fields = unknown_fields



class ResourcesResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ResourcesResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ResourcesResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RestoreArgs(Type):
    _toSchema = {'backup_id': 'backup-id'}
    _toPy = {'backup-id': 'backup_id'}
    def __init__(self, backup_id=None, **unknown_fields):
        '''
        backup_id : str
        '''
        if backup_id is not None and not isinstance(backup_id, (bytes, str)):
            raise Exception('Expected backup_id to be of type str')

        self.backup_id = backup_id
        self.unknown_fields = unknown_fields



class ResumeReplicationParams(Type):
    _toSchema = {'members': 'members'}
    _toPy = {'members': 'members'}
    def __init__(self, members=None, **unknown_fields):
        '''
        members : typing.Sequence[~Member]
        '''
        if members is not None and not isinstance(members, list):
            raise Exception('Expected members to be of type Sequence')

        self.members = [Member.from_json(o) for o in members or []]
        self.unknown_fields = unknown_fields



class RetryStrategy(Type):
    _toSchema = {'jitter_retry_time': 'jitter-retry-time', 'max_retry_time': 'max-retry-time', 'min_retry_time': 'min-retry-time', 'retry_time_factor': 'retry-time-factor', 'should_retry': 'should-retry'}
    _toPy = {'jitter-retry-time': 'jitter_retry_time', 'max-retry-time': 'max_retry_time', 'min-retry-time': 'min_retry_time', 'retry-time-factor': 'retry_time_factor', 'should-retry': 'should_retry'}
    def __init__(self, jitter_retry_time=None, max_retry_time=None, min_retry_time=None, retry_time_factor=None, should_retry=None, **unknown_fields):
        '''
        jitter_retry_time : bool
        max_retry_time : int
        min_retry_time : int
        retry_time_factor : int
        should_retry : bool
        '''
        if jitter_retry_time is not None and not isinstance(jitter_retry_time, bool):
            raise Exception('Expected jitter_retry_time to be of type bool')

        if max_retry_time is not None and not isinstance(max_retry_time, int):
            raise Exception('Expected max_retry_time to be of type int')

        if min_retry_time is not None and not isinstance(min_retry_time, int):
            raise Exception('Expected min_retry_time to be of type int')

        if retry_time_factor is not None and not isinstance(retry_time_factor, int):
            raise Exception('Expected retry_time_factor to be of type int')

        if should_retry is not None and not isinstance(should_retry, bool):
            raise Exception('Expected should_retry to be of type bool')

        self.jitter_retry_time = jitter_retry_time
        self.max_retry_time = max_retry_time
        self.min_retry_time = min_retry_time
        self.retry_time_factor = retry_time_factor
        self.should_retry = should_retry
        self.unknown_fields = unknown_fields



class RetryStrategyResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : RetryStrategy
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, RetryStrategy):
            raise Exception('Expected result to be of type RetryStrategy')

        self.error = Error.from_json(error) if error else None
        self.result = RetryStrategy.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class RetryStrategyResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~RetryStrategyResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [RetryStrategyResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class RevokeCredentialArg(Type):
    _toSchema = {'force': 'force', 'tag': 'tag'}
    _toPy = {'force': 'force', 'tag': 'tag'}
    def __init__(self, force=None, tag=None, **unknown_fields):
        '''
        force : bool
        tag : str
        '''
        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.force = force
        self.tag = tag
        self.unknown_fields = unknown_fields



class RevokeCredentialArgs(Type):
    _toSchema = {'credentials': 'credentials'}
    _toPy = {'credentials': 'credentials'}
    def __init__(self, credentials=None, **unknown_fields):
        '''
        credentials : typing.Sequence[~RevokeCredentialArg]
        '''
        if credentials is not None and not isinstance(credentials, list):
            raise Exception('Expected credentials to be of type Sequence')

        self.credentials = [RevokeCredentialArg.from_json(o) for o in credentials or []]
        self.unknown_fields = unknown_fields



class RunParams(Type):
    _toSchema = {'applications': 'applications', 'commands': 'commands', 'machines': 'machines', 'timeout': 'timeout', 'units': 'units'}
    _toPy = {'applications': 'applications', 'commands': 'commands', 'machines': 'machines', 'timeout': 'timeout', 'units': 'units'}
    def __init__(self, applications=None, commands=None, machines=None, timeout=None, units=None, **unknown_fields):
        '''
        applications : typing.Sequence[str]
        commands : str
        machines : typing.Sequence[str]
        timeout : int
        units : typing.Sequence[str]
        '''
        if applications is not None and not isinstance(applications, list):
            raise Exception('Expected applications to be of type Sequence')

        if commands is not None and not isinstance(commands, (bytes, str)):
            raise Exception('Expected commands to be of type str')

        if machines is not None and not isinstance(machines, list):
            raise Exception('Expected machines to be of type Sequence')

        if timeout is not None and not isinstance(timeout, int):
            raise Exception('Expected timeout to be of type int')

        if units is not None and not isinstance(units, list):
            raise Exception('Expected units to be of type Sequence')

        self.applications = applications
        self.commands = commands
        self.machines = machines
        self.timeout = timeout
        self.units = units
        self.unknown_fields = unknown_fields



class SSHAddressResult(Type):
    _toSchema = {'address': 'address', 'error': 'error'}
    _toPy = {'address': 'address', 'error': 'error'}
    def __init__(self, address=None, error=None, **unknown_fields):
        '''
        address : str
        error : Error
        '''
        if address is not None and not isinstance(address, (bytes, str)):
            raise Exception('Expected address to be of type str')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.address = address
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class SSHAddressResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~SSHAddressResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [SSHAddressResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class SSHAddressesResult(Type):
    _toSchema = {'addresses': 'addresses', 'error': 'error'}
    _toPy = {'addresses': 'addresses', 'error': 'error'}
    def __init__(self, addresses=None, error=None, **unknown_fields):
        '''
        addresses : typing.Sequence[str]
        error : Error
        '''
        if addresses is not None and not isinstance(addresses, list):
            raise Exception('Expected addresses to be of type Sequence')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        self.addresses = addresses
        self.error = Error.from_json(error) if error else None
        self.unknown_fields = unknown_fields



class SSHAddressesResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~SSHAddressesResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [SSHAddressesResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class SSHHostKeySet(Type):
    _toSchema = {'entity_keys': 'entity-keys'}
    _toPy = {'entity-keys': 'entity_keys'}
    def __init__(self, entity_keys=None, **unknown_fields):
        '''
        entity_keys : typing.Sequence[~SSHHostKeys]
        '''
        if entity_keys is not None and not isinstance(entity_keys, list):
            raise Exception('Expected entity_keys to be of type Sequence')

        self.entity_keys = [SSHHostKeys.from_json(o) for o in entity_keys or []]
        self.unknown_fields = unknown_fields



class SSHHostKeys(Type):
    _toSchema = {'public_keys': 'public-keys', 'tag': 'tag'}
    _toPy = {'public-keys': 'public_keys', 'tag': 'tag'}
    def __init__(self, public_keys=None, tag=None, **unknown_fields):
        '''
        public_keys : typing.Sequence[str]
        tag : str
        '''
        if public_keys is not None and not isinstance(public_keys, list):
            raise Exception('Expected public_keys to be of type Sequence')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.public_keys = public_keys
        self.tag = tag
        self.unknown_fields = unknown_fields



class SSHProxyResult(Type):
    _toSchema = {'use_proxy': 'use-proxy'}
    _toPy = {'use-proxy': 'use_proxy'}
    def __init__(self, use_proxy=None, **unknown_fields):
        '''
        use_proxy : bool
        '''
        if use_proxy is not None and not isinstance(use_proxy, bool):
            raise Exception('Expected use_proxy to be of type bool')

        self.use_proxy = use_proxy
        self.unknown_fields = unknown_fields



class SSHPublicKeysResult(Type):
    _toSchema = {'error': 'error', 'public_keys': 'public-keys'}
    _toPy = {'error': 'error', 'public-keys': 'public_keys'}
    def __init__(self, error=None, public_keys=None, **unknown_fields):
        '''
        error : Error
        public_keys : typing.Sequence[str]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if public_keys is not None and not isinstance(public_keys, list):
            raise Exception('Expected public_keys to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.public_keys = public_keys
        self.unknown_fields = unknown_fields



class SSHPublicKeysResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~SSHPublicKeysResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [SSHPublicKeysResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ScaleApplicationInfo(Type):
    _toSchema = {'num_units': 'num-units'}
    _toPy = {'num-units': 'num_units'}
    def __init__(self, num_units=None, **unknown_fields):
        '''
        num_units : int
        '''
        if num_units is not None and not isinstance(num_units, int):
            raise Exception('Expected num_units to be of type int')

        self.num_units = num_units
        self.unknown_fields = unknown_fields



class ScaleApplicationParams(Type):
    _toSchema = {'application_tag': 'application-tag', 'force': 'force', 'scale': 'scale', 'scale_change': 'scale-change'}
    _toPy = {'application-tag': 'application_tag', 'force': 'force', 'scale': 'scale', 'scale-change': 'scale_change'}
    def __init__(self, application_tag=None, force=None, scale=None, scale_change=None, **unknown_fields):
        '''
        application_tag : str
        force : bool
        scale : int
        scale_change : int
        '''
        if application_tag is not None and not isinstance(application_tag, (bytes, str)):
            raise Exception('Expected application_tag to be of type str')

        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if scale is not None and not isinstance(scale, int):
            raise Exception('Expected scale to be of type int')

        if scale_change is not None and not isinstance(scale_change, int):
            raise Exception('Expected scale_change to be of type int')

        self.application_tag = application_tag
        self.force = force
        self.scale = scale
        self.scale_change = scale_change
        self.unknown_fields = unknown_fields



class ScaleApplicationResult(Type):
    _toSchema = {'error': 'error', 'info': 'info'}
    _toPy = {'error': 'error', 'info': 'info'}
    def __init__(self, error=None, info=None, **unknown_fields):
        '''
        error : Error
        info : ScaleApplicationInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if info is not None and not isinstance(info, ScaleApplicationInfo):
            raise Exception('Expected info to be of type ScaleApplicationInfo')

        self.error = Error.from_json(error) if error else None
        self.info = ScaleApplicationInfo.from_json(info) if info else None
        self.unknown_fields = unknown_fields



class ScaleApplicationResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ScaleApplicationResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ScaleApplicationResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class ScaleApplicationsParams(Type):
    _toSchema = {'applications': 'applications'}
    _toPy = {'applications': 'applications'}
    def __init__(self, applications=None, **unknown_fields):
        '''
        applications : typing.Sequence[~ScaleApplicationParams]
        '''
        if applications is not None and not isinstance(applications, list):
            raise Exception('Expected applications to be of type Sequence')

        self.applications = [ScaleApplicationParams.from_json(o) for o in applications or []]
        self.unknown_fields = unknown_fields



class SerializedModel(Type):
    _toSchema = {'bytes_': 'bytes', 'charms': 'charms', 'resources': 'resources', 'tools': 'tools'}
    _toPy = {'bytes': 'bytes_', 'charms': 'charms', 'resources': 'resources', 'tools': 'tools'}
    def __init__(self, bytes_=None, charms=None, resources=None, tools=None, **unknown_fields):
        '''
        bytes_ : typing.Sequence[int]
        charms : typing.Sequence[str]
        resources : typing.Sequence[~SerializedModelResource]
        tools : typing.Sequence[~SerializedModelTools]
        '''
        if bytes_ is not None and not isinstance(bytes_, list):
            raise Exception('Expected bytes_ to be of type Sequence')

        if charms is not None and not isinstance(charms, list):
            raise Exception('Expected charms to be of type Sequence')

        if resources is not None and not isinstance(resources, list):
            raise Exception('Expected resources to be of type Sequence')

        if tools is not None and not isinstance(tools, list):
            raise Exception('Expected tools to be of type Sequence')

        self.bytes_ = bytes_
        self.charms = charms
        self.resources = [SerializedModelResource.from_json(o) for o in resources or []]
        self.tools = [SerializedModelTools.from_json(o) for o in tools or []]
        self.unknown_fields = unknown_fields



class SerializedModelResource(Type):
    _toSchema = {'application': 'application', 'application_revision': 'application-revision', 'charmstore_revision': 'charmstore-revision', 'name': 'name', 'unit_revisions': 'unit-revisions'}
    _toPy = {'application': 'application', 'application-revision': 'application_revision', 'charmstore-revision': 'charmstore_revision', 'name': 'name', 'unit-revisions': 'unit_revisions'}
    def __init__(self, application=None, application_revision=None, charmstore_revision=None, name=None, unit_revisions=None, **unknown_fields):
        '''
        application : str
        application_revision : SerializedModelResourceRevision
        charmstore_revision : SerializedModelResourceRevision
        name : str
        unit_revisions : typing.Mapping[str, ~SerializedModelResourceRevision]
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if application_revision is not None and not isinstance(application_revision, SerializedModelResourceRevision):
            raise Exception('Expected application_revision to be of type SerializedModelResourceRevision')

        if charmstore_revision is not None and not isinstance(charmstore_revision, SerializedModelResourceRevision):
            raise Exception('Expected charmstore_revision to be of type SerializedModelResourceRevision')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if unit_revisions is not None and not isinstance(unit_revisions, dict):
            raise Exception('Expected unit_revisions to be of type Mapping')

        self.application = application
        self.application_revision = SerializedModelResourceRevision.from_json(application_revision) if application_revision else None
        self.charmstore_revision = SerializedModelResourceRevision.from_json(charmstore_revision) if charmstore_revision else None
        self.name = name
        self.unit_revisions = unit_revisions
        self.unknown_fields = unknown_fields



class SerializedModelResourceRevision(Type):
    _toSchema = {'description': 'description', 'fingerprint': 'fingerprint', 'origin': 'origin', 'path': 'path', 'revision': 'revision', 'size': 'size', 'timestamp': 'timestamp', 'type_': 'type', 'username': 'username'}
    _toPy = {'description': 'description', 'fingerprint': 'fingerprint', 'origin': 'origin', 'path': 'path', 'revision': 'revision', 'size': 'size', 'timestamp': 'timestamp', 'type': 'type_', 'username': 'username'}
    def __init__(self, description=None, fingerprint=None, origin=None, path=None, revision=None, size=None, timestamp=None, type_=None, username=None, **unknown_fields):
        '''
        description : str
        fingerprint : str
        origin : str
        path : str
        revision : int
        size : int
        timestamp : str
        type_ : str
        username : str
        '''
        if description is not None and not isinstance(description, (bytes, str)):
            raise Exception('Expected description to be of type str')

        if fingerprint is not None and not isinstance(fingerprint, (bytes, str)):
            raise Exception('Expected fingerprint to be of type str')

        if origin is not None and not isinstance(origin, (bytes, str)):
            raise Exception('Expected origin to be of type str')

        if path is not None and not isinstance(path, (bytes, str)):
            raise Exception('Expected path to be of type str')

        if revision is not None and not isinstance(revision, int):
            raise Exception('Expected revision to be of type int')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if timestamp is not None and not isinstance(timestamp, (bytes, str)):
            raise Exception('Expected timestamp to be of type str')

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception('Expected type_ to be of type str')

        if username is not None and not isinstance(username, (bytes, str)):
            raise Exception('Expected username to be of type str')

        self.description = description
        self.fingerprint = fingerprint
        self.origin = origin
        self.path = path
        self.revision = revision
        self.size = size
        self.timestamp = timestamp
        self.type_ = type_
        self.username = username
        self.unknown_fields = unknown_fields



class SerializedModelTools(Type):
    _toSchema = {'uri': 'uri', 'version': 'version'}
    _toPy = {'uri': 'uri', 'version': 'version'}
    def __init__(self, uri=None, version=None, **unknown_fields):
        '''
        uri : str
        version : str
        '''
        if uri is not None and not isinstance(uri, (bytes, str)):
            raise Exception('Expected uri to be of type str')

        if version is not None and not isinstance(version, (bytes, str)):
            raise Exception('Expected version to be of type str')

        self.uri = uri
        self.version = version
        self.unknown_fields = unknown_fields



class SetConstraints(Type):
    _toSchema = {'application': 'application', 'constraints': 'constraints'}
    _toPy = {'application': 'application', 'constraints': 'constraints'}
    def __init__(self, application=None, constraints=None, **unknown_fields):
        '''
        application : str
        constraints : Value
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception('Expected application to be of type str')

        if constraints is not None and not isinstance(constraints, Value):
            raise Exception('Expected constraints to be of type Value')

        self.application = application
        self.constraints = Value.from_json(constraints) if constraints else None
        self.unknown_fields = unknown_fields



class SetExternalControllerInfoParams(Type):
    _toSchema = {'info': 'info'}
    _toPy = {'info': 'info'}
    def __init__(self, info=None, **unknown_fields):
        '''
        info : ExternalControllerInfo
        '''
        if info is not None and not isinstance(info, ExternalControllerInfo):
            raise Exception('Expected info to be of type ExternalControllerInfo')

        self.info = ExternalControllerInfo.from_json(info) if info else None
        self.unknown_fields = unknown_fields



class SetExternalControllersInfoParams(Type):
    _toSchema = {'controllers': 'controllers'}
    _toPy = {'controllers': 'controllers'}
    def __init__(self, controllers=None, **unknown_fields):
        '''
        controllers : typing.Sequence[~SetExternalControllerInfoParams]
        '''
        if controllers is not None and not isinstance(controllers, list):
            raise Exception('Expected controllers to be of type Sequence')

        self.controllers = [SetExternalControllerInfoParams.from_json(o) for o in controllers or []]
        self.unknown_fields = unknown_fields



class SetMachineBlockDevices(Type):
    _toSchema = {'machine_block_devices': 'machine-block-devices'}
    _toPy = {'machine-block-devices': 'machine_block_devices'}
    def __init__(self, machine_block_devices=None, **unknown_fields):
        '''
        machine_block_devices : typing.Sequence[~MachineBlockDevices]
        '''
        if machine_block_devices is not None and not isinstance(machine_block_devices, list):
            raise Exception('Expected machine_block_devices to be of type Sequence')

        self.machine_block_devices = [MachineBlockDevices.from_json(o) for o in machine_block_devices or []]
        self.unknown_fields = unknown_fields



class SetMachineNetworkConfig(Type):
    _toSchema = {'config': 'config', 'tag': 'tag'}
    _toPy = {'config': 'config', 'tag': 'tag'}
    def __init__(self, config=None, tag=None, **unknown_fields):
        '''
        config : typing.Sequence[~NetworkConfig]
        tag : str
        '''
        if config is not None and not isinstance(config, list):
            raise Exception('Expected config to be of type Sequence')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.config = [NetworkConfig.from_json(o) for o in config or []]
        self.tag = tag
        self.unknown_fields = unknown_fields



class SetMachinesAddresses(Type):
    _toSchema = {'machine_addresses': 'machine-addresses'}
    _toPy = {'machine-addresses': 'machine_addresses'}
    def __init__(self, machine_addresses=None, **unknown_fields):
        '''
        machine_addresses : typing.Sequence[~MachineAddresses]
        '''
        if machine_addresses is not None and not isinstance(machine_addresses, list):
            raise Exception('Expected machine_addresses to be of type Sequence')

        self.machine_addresses = [MachineAddresses.from_json(o) for o in machine_addresses or []]
        self.unknown_fields = unknown_fields



class SetMigrationPhaseArgs(Type):
    _toSchema = {'phase': 'phase'}
    _toPy = {'phase': 'phase'}
    def __init__(self, phase=None, **unknown_fields):
        '''
        phase : str
        '''
        if phase is not None and not isinstance(phase, (bytes, str)):
            raise Exception('Expected phase to be of type str')

        self.phase = phase
        self.unknown_fields = unknown_fields



class SetMigrationStatusMessageArgs(Type):
    _toSchema = {'message': 'message'}
    _toPy = {'message': 'message'}
    def __init__(self, message=None, **unknown_fields):
        '''
        message : str
        '''
        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        self.message = message
        self.unknown_fields = unknown_fields



class SetModelAgentVersion(Type):
    _toSchema = {'force': 'force', 'version': 'version'}
    _toPy = {'force': 'force', 'version': 'version'}
    def __init__(self, force=None, version=None, **unknown_fields):
        '''
        force : bool
        version : Number
        '''
        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if version is not None and not isinstance(version, Number):
            raise Exception('Expected version to be of type Number')

        self.force = force
        self.version = Number.from_json(version) if version else None
        self.unknown_fields = unknown_fields



class SetModelDefaults(Type):
    _toSchema = {'config': 'config'}
    _toPy = {'config': 'config'}
    def __init__(self, config=None, **unknown_fields):
        '''
        config : typing.Sequence[~ModelDefaultValues]
        '''
        if config is not None and not isinstance(config, list):
            raise Exception('Expected config to be of type Sequence')

        self.config = [ModelDefaultValues.from_json(o) for o in config or []]
        self.unknown_fields = unknown_fields



class SetModelEnvironVersion(Type):
    _toSchema = {'model_tag': 'model-tag', 'version': 'version'}
    _toPy = {'model-tag': 'model_tag', 'version': 'version'}
    def __init__(self, model_tag=None, version=None, **unknown_fields):
        '''
        model_tag : str
        version : int
        '''
        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception('Expected model_tag to be of type str')

        if version is not None and not isinstance(version, int):
            raise Exception('Expected version to be of type int')

        self.model_tag = model_tag
        self.version = version
        self.unknown_fields = unknown_fields



class SetModelEnvironVersions(Type):
    _toSchema = {'models': 'models'}
    _toPy = {'models': 'models'}
    def __init__(self, models=None, **unknown_fields):
        '''
        models : typing.Sequence[~SetModelEnvironVersion]
        '''
        if models is not None and not isinstance(models, list):
            raise Exception('Expected models to be of type Sequence')

        self.models = [SetModelEnvironVersion.from_json(o) for o in models or []]
        self.unknown_fields = unknown_fields



class SetPayloadStatusArg(Type):
    _toSchema = {'entity': 'Entity', 'status': 'status', 'tag': 'tag'}
    _toPy = {'Entity': 'entity', 'status': 'status', 'tag': 'tag'}
    def __init__(self, entity=None, status=None, tag=None, **unknown_fields):
        '''
        entity : Entity
        status : str
        tag : str
        '''
        if entity is not None and not isinstance(entity, Entity):
            raise Exception('Expected entity to be of type Entity')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.entity = Entity.from_json(entity) if entity else None
        self.status = status
        self.tag = tag
        self.unknown_fields = unknown_fields



class SetPayloadStatusArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~SetPayloadStatusArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [SetPayloadStatusArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class SetPodSpecParams(Type):
    _toSchema = {'specs': 'specs'}
    _toPy = {'specs': 'specs'}
    def __init__(self, specs=None, **unknown_fields):
        '''
        specs : typing.Sequence[~EntityString]
        '''
        if specs is not None and not isinstance(specs, list):
            raise Exception('Expected specs to be of type Sequence')

        self.specs = [EntityString.from_json(o) for o in specs or []]
        self.unknown_fields = unknown_fields



class SetProfileArg(Type):
    _toSchema = {'entity': 'entity', 'profiles': 'profiles'}
    _toPy = {'entity': 'entity', 'profiles': 'profiles'}
    def __init__(self, entity=None, profiles=None, **unknown_fields):
        '''
        entity : Entity
        profiles : typing.Sequence[str]
        '''
        if entity is not None and not isinstance(entity, Entity):
            raise Exception('Expected entity to be of type Entity')

        if profiles is not None and not isinstance(profiles, list):
            raise Exception('Expected profiles to be of type Sequence')

        self.entity = Entity.from_json(entity) if entity else None
        self.profiles = profiles
        self.unknown_fields = unknown_fields



class SetProfileArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~SetProfileArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [SetProfileArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class SetProfileUpgradeCompleteArg(Type):
    _toSchema = {'entity': 'entity', 'message': 'message'}
    _toPy = {'entity': 'entity', 'message': 'message'}
    def __init__(self, entity=None, message=None, **unknown_fields):
        '''
        entity : Entity
        message : str
        '''
        if entity is not None and not isinstance(entity, Entity):
            raise Exception('Expected entity to be of type Entity')

        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        self.entity = Entity.from_json(entity) if entity else None
        self.message = message
        self.unknown_fields = unknown_fields



class SetProfileUpgradeCompleteArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~SetProfileUpgradeCompleteArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [SetProfileUpgradeCompleteArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class SetStatus(Type):
    _toSchema = {'entities': 'entities'}
    _toPy = {'entities': 'entities'}
    def __init__(self, entities=None, **unknown_fields):
        '''
        entities : typing.Sequence[~EntityStatusArgs]
        '''
        if entities is not None and not isinstance(entities, list):
            raise Exception('Expected entities to be of type Sequence')

        self.entities = [EntityStatusArgs.from_json(o) for o in entities or []]
        self.unknown_fields = unknown_fields



class SetStatusArg(Type):
    _toSchema = {'entity': 'Entity', 'status': 'status'}
    _toPy = {'Entity': 'entity', 'status': 'status'}
    def __init__(self, entity=None, status=None, **unknown_fields):
        '''
        entity : Entity
        status : str
        '''
        if entity is not None and not isinstance(entity, Entity):
            raise Exception('Expected entity to be of type Entity')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        self.entity = Entity.from_json(entity) if entity else None
        self.status = status
        self.unknown_fields = unknown_fields



class SetStatusArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~SetStatusArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [SetStatusArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class Settings(Type):
    _toSchema = {'autonoproxy': 'AutoNoProxy', 'ftp': 'Ftp', 'http': 'Http', 'https': 'Https', 'noproxy': 'NoProxy'}
    _toPy = {'AutoNoProxy': 'autonoproxy', 'Ftp': 'ftp', 'Http': 'http', 'Https': 'https', 'NoProxy': 'noproxy'}
    def __init__(self, autonoproxy=None, ftp=None, http=None, https=None, noproxy=None, **unknown_fields):
        '''
        autonoproxy : str
        ftp : str
        http : str
        https : str
        noproxy : str
        '''
        if autonoproxy is not None and not isinstance(autonoproxy, (bytes, str)):
            raise Exception('Expected autonoproxy to be of type str')

        if ftp is not None and not isinstance(ftp, (bytes, str)):
            raise Exception('Expected ftp to be of type str')

        if http is not None and not isinstance(http, (bytes, str)):
            raise Exception('Expected http to be of type str')

        if https is not None and not isinstance(https, (bytes, str)):
            raise Exception('Expected https to be of type str')

        if noproxy is not None and not isinstance(noproxy, (bytes, str)):
            raise Exception('Expected noproxy to be of type str')

        self.autonoproxy = autonoproxy
        self.ftp = ftp
        self.http = http
        self.https = https
        self.noproxy = noproxy
        self.unknown_fields = unknown_fields



class SettingsResult(Type):
    _toSchema = {'error': 'error', 'settings': 'settings'}
    _toPy = {'error': 'error', 'settings': 'settings'}
    def __init__(self, error=None, settings=None, **unknown_fields):
        '''
        error : Error
        settings : typing.Mapping[str, str]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if settings is not None and not isinstance(settings, dict):
            raise Exception('Expected settings to be of type Mapping')

        self.error = Error.from_json(error) if error else None
        self.settings = settings
        self.unknown_fields = unknown_fields



class SettingsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~SettingsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [SettingsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class SingularClaim(Type):
    _toSchema = {'claimant_tag': 'claimant-tag', 'duration': 'duration', 'entity_tag': 'entity-tag'}
    _toPy = {'claimant-tag': 'claimant_tag', 'duration': 'duration', 'entity-tag': 'entity_tag'}
    def __init__(self, claimant_tag=None, duration=None, entity_tag=None, **unknown_fields):
        '''
        claimant_tag : str
        duration : int
        entity_tag : str
        '''
        if claimant_tag is not None and not isinstance(claimant_tag, (bytes, str)):
            raise Exception('Expected claimant_tag to be of type str')

        if duration is not None and not isinstance(duration, int):
            raise Exception('Expected duration to be of type int')

        if entity_tag is not None and not isinstance(entity_tag, (bytes, str)):
            raise Exception('Expected entity_tag to be of type str')

        self.claimant_tag = claimant_tag
        self.duration = duration
        self.entity_tag = entity_tag
        self.unknown_fields = unknown_fields



class SingularClaims(Type):
    _toSchema = {'claims': 'claims'}
    _toPy = {'claims': 'claims'}
    def __init__(self, claims=None, **unknown_fields):
        '''
        claims : typing.Sequence[~SingularClaim]
        '''
        if claims is not None and not isinstance(claims, list):
            raise Exception('Expected claims to be of type Sequence')

        self.claims = [SingularClaim.from_json(o) for o in claims or []]
        self.unknown_fields = unknown_fields



class Space(Type):
    _toSchema = {'error': 'error', 'name': 'name', 'subnets': 'subnets'}
    _toPy = {'error': 'error', 'name': 'name', 'subnets': 'subnets'}
    def __init__(self, error=None, name=None, subnets=None, **unknown_fields):
        '''
        error : Error
        name : str
        subnets : typing.Sequence[~Subnet]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if subnets is not None and not isinstance(subnets, list):
            raise Exception('Expected subnets to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.name = name
        self.subnets = [Subnet.from_json(o) for o in subnets or []]
        self.unknown_fields = unknown_fields



class SpaceResult(Type):
    _toSchema = {'error': 'error', 'tag': 'tag'}
    _toPy = {'error': 'error', 'tag': 'tag'}
    def __init__(self, error=None, tag=None, **unknown_fields):
        '''
        error : Error
        tag : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.error = Error.from_json(error) if error else None
        self.tag = tag
        self.unknown_fields = unknown_fields



class SpaceResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~SpaceResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [SpaceResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class StateServingInfo(Type):
    _toSchema = {'api_port': 'api-port', 'ca_private_key': 'ca-private-key', 'cert': 'cert', 'controller_api_port': 'controller-api-port', 'private_key': 'private-key', 'shared_secret': 'shared-secret', 'state_port': 'state-port', 'system_identity': 'system-identity'}
    _toPy = {'api-port': 'api_port', 'ca-private-key': 'ca_private_key', 'cert': 'cert', 'controller-api-port': 'controller_api_port', 'private-key': 'private_key', 'shared-secret': 'shared_secret', 'state-port': 'state_port', 'system-identity': 'system_identity'}
    def __init__(self, api_port=None, ca_private_key=None, cert=None, controller_api_port=None, private_key=None, shared_secret=None, state_port=None, system_identity=None, **unknown_fields):
        '''
        api_port : int
        ca_private_key : str
        cert : str
        controller_api_port : int
        private_key : str
        shared_secret : str
        state_port : int
        system_identity : str
        '''
        if api_port is not None and not isinstance(api_port, int):
            raise Exception('Expected api_port to be of type int')

        if ca_private_key is not None and not isinstance(ca_private_key, (bytes, str)):
            raise Exception('Expected ca_private_key to be of type str')

        if cert is not None and not isinstance(cert, (bytes, str)):
            raise Exception('Expected cert to be of type str')

        if controller_api_port is not None and not isinstance(controller_api_port, int):
            raise Exception('Expected controller_api_port to be of type int')

        if private_key is not None and not isinstance(private_key, (bytes, str)):
            raise Exception('Expected private_key to be of type str')

        if shared_secret is not None and not isinstance(shared_secret, (bytes, str)):
            raise Exception('Expected shared_secret to be of type str')

        if state_port is not None and not isinstance(state_port, int):
            raise Exception('Expected state_port to be of type int')

        if system_identity is not None and not isinstance(system_identity, (bytes, str)):
            raise Exception('Expected system_identity to be of type str')

        self.api_port = api_port
        self.ca_private_key = ca_private_key
        self.cert = cert
        self.controller_api_port = controller_api_port
        self.private_key = private_key
        self.shared_secret = shared_secret
        self.state_port = state_port
        self.system_identity = system_identity
        self.unknown_fields = unknown_fields



class StatusHistoryFilter(Type):
    _toSchema = {'date': 'date', 'delta': 'delta', 'exclude': 'exclude', 'size': 'size'}
    _toPy = {'date': 'date', 'delta': 'delta', 'exclude': 'exclude', 'size': 'size'}
    def __init__(self, date=None, delta=None, exclude=None, size=None, **unknown_fields):
        '''
        date : str
        delta : int
        exclude : typing.Sequence[str]
        size : int
        '''
        if date is not None and not isinstance(date, (bytes, str)):
            raise Exception('Expected date to be of type str')

        if delta is not None and not isinstance(delta, int):
            raise Exception('Expected delta to be of type int')

        if exclude is not None and not isinstance(exclude, list):
            raise Exception('Expected exclude to be of type Sequence')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        self.date = date
        self.delta = delta
        self.exclude = exclude
        self.size = size
        self.unknown_fields = unknown_fields



class StatusHistoryPruneArgs(Type):
    _toSchema = {'max_history_mb': 'max-history-mb', 'max_history_time': 'max-history-time'}
    _toPy = {'max-history-mb': 'max_history_mb', 'max-history-time': 'max_history_time'}
    def __init__(self, max_history_mb=None, max_history_time=None, **unknown_fields):
        '''
        max_history_mb : int
        max_history_time : int
        '''
        if max_history_mb is not None and not isinstance(max_history_mb, int):
            raise Exception('Expected max_history_mb to be of type int')

        if max_history_time is not None and not isinstance(max_history_time, int):
            raise Exception('Expected max_history_time to be of type int')

        self.max_history_mb = max_history_mb
        self.max_history_time = max_history_time
        self.unknown_fields = unknown_fields



class StatusHistoryRequest(Type):
    _toSchema = {'filter_': 'filter', 'historykind': 'historyKind', 'size': 'size', 'tag': 'tag'}
    _toPy = {'filter': 'filter_', 'historyKind': 'historykind', 'size': 'size', 'tag': 'tag'}
    def __init__(self, filter_=None, historykind=None, size=None, tag=None, **unknown_fields):
        '''
        filter_ : StatusHistoryFilter
        historykind : str
        size : int
        tag : str
        '''
        if filter_ is not None and not isinstance(filter_, StatusHistoryFilter):
            raise Exception('Expected filter_ to be of type StatusHistoryFilter')

        if historykind is not None and not isinstance(historykind, (bytes, str)):
            raise Exception('Expected historykind to be of type str')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.filter_ = StatusHistoryFilter.from_json(filter_) if filter_ else None
        self.historykind = historykind
        self.size = size
        self.tag = tag
        self.unknown_fields = unknown_fields



class StatusHistoryRequests(Type):
    _toSchema = {'requests': 'requests'}
    _toPy = {'requests': 'requests'}
    def __init__(self, requests=None, **unknown_fields):
        '''
        requests : typing.Sequence[~StatusHistoryRequest]
        '''
        if requests is not None and not isinstance(requests, list):
            raise Exception('Expected requests to be of type Sequence')

        self.requests = [StatusHistoryRequest.from_json(o) for o in requests or []]
        self.unknown_fields = unknown_fields



class StatusHistoryResult(Type):
    _toSchema = {'error': 'error', 'history': 'history'}
    _toPy = {'error': 'error', 'history': 'history'}
    def __init__(self, error=None, history=None, **unknown_fields):
        '''
        error : Error
        history : History
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if history is not None and not isinstance(history, History):
            raise Exception('Expected history to be of type History')

        self.error = Error.from_json(error) if error else None
        self.history = History.from_json(history) if history else None
        self.unknown_fields = unknown_fields



class StatusHistoryResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~StatusHistoryResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [StatusHistoryResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class StatusParams(Type):
    _toSchema = {'patterns': 'patterns'}
    _toPy = {'patterns': 'patterns'}
    def __init__(self, patterns=None, **unknown_fields):
        '''
        patterns : typing.Sequence[str]
        '''
        if patterns is not None and not isinstance(patterns, list):
            raise Exception('Expected patterns to be of type Sequence')

        self.patterns = patterns
        self.unknown_fields = unknown_fields



class StatusResult(Type):
    _toSchema = {'data': 'data', 'error': 'error', 'id_': 'id', 'info': 'info', 'life': 'life', 'since': 'since', 'status': 'status'}
    _toPy = {'data': 'data', 'error': 'error', 'id': 'id_', 'info': 'info', 'life': 'life', 'since': 'since', 'status': 'status'}
    def __init__(self, data=None, error=None, id_=None, info=None, life=None, since=None, status=None, **unknown_fields):
        '''
        data : typing.Mapping[str, typing.Any]
        error : Error
        id_ : str
        info : str
        life : str
        since : str
        status : str
        '''
        if data is not None and not isinstance(data, dict):
            raise Exception('Expected data to be of type Mapping')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if id_ is not None and not isinstance(id_, (bytes, str)):
            raise Exception('Expected id_ to be of type str')

        if info is not None and not isinstance(info, (bytes, str)):
            raise Exception('Expected info to be of type str')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if since is not None and not isinstance(since, (bytes, str)):
            raise Exception('Expected since to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        self.data = data
        self.error = Error.from_json(error) if error else None
        self.id_ = id_
        self.info = info
        self.life = life
        self.since = since
        self.status = status
        self.unknown_fields = unknown_fields



class StatusResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~StatusResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [StatusResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class StorageAddParams(Type):
    _toSchema = {'name': 'name', 'storage': 'storage', 'unit': 'unit'}
    _toPy = {'name': 'name', 'storage': 'storage', 'unit': 'unit'}
    def __init__(self, name=None, storage=None, unit=None, **unknown_fields):
        '''
        name : str
        storage : StorageConstraints
        unit : str
        '''
        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if storage is not None and not isinstance(storage, StorageConstraints):
            raise Exception('Expected storage to be of type StorageConstraints')

        if unit is not None and not isinstance(unit, (bytes, str)):
            raise Exception('Expected unit to be of type str')

        self.name = name
        self.storage = StorageConstraints.from_json(storage) if storage else None
        self.unit = unit
        self.unknown_fields = unknown_fields



class StorageAttachment(Type):
    _toSchema = {'kind': 'kind', 'life': 'life', 'location': 'location', 'owner_tag': 'owner-tag', 'storage_tag': 'storage-tag', 'unit_tag': 'unit-tag'}
    _toPy = {'kind': 'kind', 'life': 'life', 'location': 'location', 'owner-tag': 'owner_tag', 'storage-tag': 'storage_tag', 'unit-tag': 'unit_tag'}
    def __init__(self, kind=None, life=None, location=None, owner_tag=None, storage_tag=None, unit_tag=None, **unknown_fields):
        '''
        kind : int
        life : str
        location : str
        owner_tag : str
        storage_tag : str
        unit_tag : str
        '''
        if kind is not None and not isinstance(kind, int):
            raise Exception('Expected kind to be of type int')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if location is not None and not isinstance(location, (bytes, str)):
            raise Exception('Expected location to be of type str')

        if owner_tag is not None and not isinstance(owner_tag, (bytes, str)):
            raise Exception('Expected owner_tag to be of type str')

        if storage_tag is not None and not isinstance(storage_tag, (bytes, str)):
            raise Exception('Expected storage_tag to be of type str')

        if unit_tag is not None and not isinstance(unit_tag, (bytes, str)):
            raise Exception('Expected unit_tag to be of type str')

        self.kind = kind
        self.life = life
        self.location = location
        self.owner_tag = owner_tag
        self.storage_tag = storage_tag
        self.unit_tag = unit_tag
        self.unknown_fields = unknown_fields



class StorageAttachmentDetails(Type):
    _toSchema = {'life': 'life', 'location': 'location', 'machine_tag': 'machine-tag', 'storage_tag': 'storage-tag', 'unit_tag': 'unit-tag'}
    _toPy = {'life': 'life', 'location': 'location', 'machine-tag': 'machine_tag', 'storage-tag': 'storage_tag', 'unit-tag': 'unit_tag'}
    def __init__(self, life=None, location=None, machine_tag=None, storage_tag=None, unit_tag=None, **unknown_fields):
        '''
        life : str
        location : str
        machine_tag : str
        storage_tag : str
        unit_tag : str
        '''
        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if location is not None and not isinstance(location, (bytes, str)):
            raise Exception('Expected location to be of type str')

        if machine_tag is not None and not isinstance(machine_tag, (bytes, str)):
            raise Exception('Expected machine_tag to be of type str')

        if storage_tag is not None and not isinstance(storage_tag, (bytes, str)):
            raise Exception('Expected storage_tag to be of type str')

        if unit_tag is not None and not isinstance(unit_tag, (bytes, str)):
            raise Exception('Expected unit_tag to be of type str')

        self.life = life
        self.location = location
        self.machine_tag = machine_tag
        self.storage_tag = storage_tag
        self.unit_tag = unit_tag
        self.unknown_fields = unknown_fields



class StorageAttachmentId(Type):
    _toSchema = {'storage_tag': 'storage-tag', 'unit_tag': 'unit-tag'}
    _toPy = {'storage-tag': 'storage_tag', 'unit-tag': 'unit_tag'}
    def __init__(self, storage_tag=None, unit_tag=None, **unknown_fields):
        '''
        storage_tag : str
        unit_tag : str
        '''
        if storage_tag is not None and not isinstance(storage_tag, (bytes, str)):
            raise Exception('Expected storage_tag to be of type str')

        if unit_tag is not None and not isinstance(unit_tag, (bytes, str)):
            raise Exception('Expected unit_tag to be of type str')

        self.storage_tag = storage_tag
        self.unit_tag = unit_tag
        self.unknown_fields = unknown_fields



class StorageAttachmentIds(Type):
    _toSchema = {'ids': 'ids'}
    _toPy = {'ids': 'ids'}
    def __init__(self, ids=None, **unknown_fields):
        '''
        ids : typing.Sequence[~StorageAttachmentId]
        '''
        if ids is not None and not isinstance(ids, list):
            raise Exception('Expected ids to be of type Sequence')

        self.ids = [StorageAttachmentId.from_json(o) for o in ids or []]
        self.unknown_fields = unknown_fields



class StorageAttachmentIdsResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : StorageAttachmentIds
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, StorageAttachmentIds):
            raise Exception('Expected result to be of type StorageAttachmentIds')

        self.error = Error.from_json(error) if error else None
        self.result = StorageAttachmentIds.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class StorageAttachmentIdsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~StorageAttachmentIdsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [StorageAttachmentIdsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class StorageAttachmentResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : StorageAttachment
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, StorageAttachment):
            raise Exception('Expected result to be of type StorageAttachment')

        self.error = Error.from_json(error) if error else None
        self.result = StorageAttachment.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class StorageAttachmentResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~StorageAttachmentResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [StorageAttachmentResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class StorageConstraints(Type):
    _toSchema = {'count': 'count', 'pool': 'pool', 'size': 'size'}
    _toPy = {'count': 'count', 'pool': 'pool', 'size': 'size'}
    def __init__(self, count=None, pool=None, size=None, **unknown_fields):
        '''
        count : int
        pool : str
        size : int
        '''
        if count is not None and not isinstance(count, int):
            raise Exception('Expected count to be of type int')

        if pool is not None and not isinstance(pool, (bytes, str)):
            raise Exception('Expected pool to be of type str')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        self.count = count
        self.pool = pool
        self.size = size
        self.unknown_fields = unknown_fields



class StorageDetachmentParams(Type):
    _toSchema = {'force': 'force', 'ids': 'ids', 'max_wait': 'max-wait'}
    _toPy = {'force': 'force', 'ids': 'ids', 'max-wait': 'max_wait'}
    def __init__(self, force=None, ids=None, max_wait=None, **unknown_fields):
        '''
        force : bool
        ids : StorageAttachmentIds
        max_wait : int
        '''
        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if ids is not None and not isinstance(ids, StorageAttachmentIds):
            raise Exception('Expected ids to be of type StorageAttachmentIds')

        if max_wait is not None and not isinstance(max_wait, int):
            raise Exception('Expected max_wait to be of type int')

        self.force = force
        self.ids = StorageAttachmentIds.from_json(ids) if ids else None
        self.max_wait = max_wait
        self.unknown_fields = unknown_fields



class StorageDetails(Type):
    _toSchema = {'attachments': 'attachments', 'kind': 'kind', 'life': 'life', 'owner_tag': 'owner-tag', 'persistent': 'persistent', 'status': 'status', 'storage_tag': 'storage-tag'}
    _toPy = {'attachments': 'attachments', 'kind': 'kind', 'life': 'life', 'owner-tag': 'owner_tag', 'persistent': 'persistent', 'status': 'status', 'storage-tag': 'storage_tag'}
    def __init__(self, attachments=None, kind=None, life=None, owner_tag=None, persistent=None, status=None, storage_tag=None, **unknown_fields):
        '''
        attachments : typing.Mapping[str, ~StorageAttachmentDetails]
        kind : int
        life : str
        owner_tag : str
        persistent : bool
        status : EntityStatus
        storage_tag : str
        '''
        if attachments is not None and not isinstance(attachments, dict):
            raise Exception('Expected attachments to be of type Mapping')

        if kind is not None and not isinstance(kind, int):
            raise Exception('Expected kind to be of type int')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if owner_tag is not None and not isinstance(owner_tag, (bytes, str)):
            raise Exception('Expected owner_tag to be of type str')

        if persistent is not None and not isinstance(persistent, bool):
            raise Exception('Expected persistent to be of type bool')

        if status is not None and not isinstance(status, EntityStatus):
            raise Exception('Expected status to be of type EntityStatus')

        if storage_tag is not None and not isinstance(storage_tag, (bytes, str)):
            raise Exception('Expected storage_tag to be of type str')

        self.attachments = attachments
        self.kind = kind
        self.life = life
        self.owner_tag = owner_tag
        self.persistent = persistent
        self.status = EntityStatus.from_json(status) if status else None
        self.storage_tag = storage_tag
        self.unknown_fields = unknown_fields



class StorageDetailsListResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : typing.Sequence[~StorageDetails]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, list):
            raise Exception('Expected result to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.result = [StorageDetails.from_json(o) for o in result or []]
        self.unknown_fields = unknown_fields



class StorageDetailsListResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~StorageDetailsListResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [StorageDetailsListResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class StorageDetailsResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : StorageDetails
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, StorageDetails):
            raise Exception('Expected result to be of type StorageDetails')

        self.error = Error.from_json(error) if error else None
        self.result = StorageDetails.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class StorageDetailsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~StorageDetailsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [StorageDetailsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class StorageFilter(Type):
    _toSchema = {}
    _toPy = {}
    def __init__(self, **unknown_fields):
        '''

        '''
        self.unknown_fields = unknown_fields



class StorageFilters(Type):
    _toSchema = {'filters': 'filters'}
    _toPy = {'filters': 'filters'}
    def __init__(self, filters=None, **unknown_fields):
        '''
        filters : typing.Sequence[~StorageFilter]
        '''
        if filters is not None and not isinstance(filters, list):
            raise Exception('Expected filters to be of type Sequence')

        self.filters = [StorageFilter.from_json(o) for o in filters or []]
        self.unknown_fields = unknown_fields



class StoragePool(Type):
    _toSchema = {'attrs': 'attrs', 'name': 'name', 'provider': 'provider'}
    _toPy = {'attrs': 'attrs', 'name': 'name', 'provider': 'provider'}
    def __init__(self, attrs=None, name=None, provider=None, **unknown_fields):
        '''
        attrs : typing.Mapping[str, typing.Any]
        name : str
        provider : str
        '''
        if attrs is not None and not isinstance(attrs, dict):
            raise Exception('Expected attrs to be of type Mapping')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if provider is not None and not isinstance(provider, (bytes, str)):
            raise Exception('Expected provider to be of type str')

        self.attrs = attrs
        self.name = name
        self.provider = provider
        self.unknown_fields = unknown_fields



class StoragePoolArgs(Type):
    _toSchema = {'pools': 'pools'}
    _toPy = {'pools': 'pools'}
    def __init__(self, pools=None, **unknown_fields):
        '''
        pools : typing.Sequence[~StoragePool]
        '''
        if pools is not None and not isinstance(pools, list):
            raise Exception('Expected pools to be of type Sequence')

        self.pools = [StoragePool.from_json(o) for o in pools or []]
        self.unknown_fields = unknown_fields



class StoragePoolDeleteArg(Type):
    _toSchema = {'name': 'name'}
    _toPy = {'name': 'name'}
    def __init__(self, name=None, **unknown_fields):
        '''
        name : str
        '''
        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        self.name = name
        self.unknown_fields = unknown_fields



class StoragePoolDeleteArgs(Type):
    _toSchema = {'pools': 'pools'}
    _toPy = {'pools': 'pools'}
    def __init__(self, pools=None, **unknown_fields):
        '''
        pools : typing.Sequence[~StoragePoolDeleteArg]
        '''
        if pools is not None and not isinstance(pools, list):
            raise Exception('Expected pools to be of type Sequence')

        self.pools = [StoragePoolDeleteArg.from_json(o) for o in pools or []]
        self.unknown_fields = unknown_fields



class StoragePoolFilter(Type):
    _toSchema = {'names': 'names', 'providers': 'providers'}
    _toPy = {'names': 'names', 'providers': 'providers'}
    def __init__(self, names=None, providers=None, **unknown_fields):
        '''
        names : typing.Sequence[str]
        providers : typing.Sequence[str]
        '''
        if names is not None and not isinstance(names, list):
            raise Exception('Expected names to be of type Sequence')

        if providers is not None and not isinstance(providers, list):
            raise Exception('Expected providers to be of type Sequence')

        self.names = names
        self.providers = providers
        self.unknown_fields = unknown_fields



class StoragePoolFilters(Type):
    _toSchema = {'filters': 'filters'}
    _toPy = {'filters': 'filters'}
    def __init__(self, filters=None, **unknown_fields):
        '''
        filters : typing.Sequence[~StoragePoolFilter]
        '''
        if filters is not None and not isinstance(filters, list):
            raise Exception('Expected filters to be of type Sequence')

        self.filters = [StoragePoolFilter.from_json(o) for o in filters or []]
        self.unknown_fields = unknown_fields



class StoragePoolsResult(Type):
    _toSchema = {'error': 'error', 'storage_pools': 'storage-pools'}
    _toPy = {'error': 'error', 'storage-pools': 'storage_pools'}
    def __init__(self, error=None, storage_pools=None, **unknown_fields):
        '''
        error : Error
        storage_pools : typing.Sequence[~StoragePool]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if storage_pools is not None and not isinstance(storage_pools, list):
            raise Exception('Expected storage_pools to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.storage_pools = [StoragePool.from_json(o) for o in storage_pools or []]
        self.unknown_fields = unknown_fields



class StoragePoolsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~StoragePoolsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [StoragePoolsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class StoragesAddParams(Type):
    _toSchema = {'storages': 'storages'}
    _toPy = {'storages': 'storages'}
    def __init__(self, storages=None, **unknown_fields):
        '''
        storages : typing.Sequence[~StorageAddParams]
        '''
        if storages is not None and not isinstance(storages, list):
            raise Exception('Expected storages to be of type Sequence')

        self.storages = [StorageAddParams.from_json(o) for o in storages or []]
        self.unknown_fields = unknown_fields



class StringBoolResult(Type):
    _toSchema = {'error': 'error', 'ok': 'ok', 'result': 'result'}
    _toPy = {'error': 'error', 'ok': 'ok', 'result': 'result'}
    def __init__(self, error=None, ok=None, result=None, **unknown_fields):
        '''
        error : Error
        ok : bool
        result : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if ok is not None and not isinstance(ok, bool):
            raise Exception('Expected ok to be of type bool')

        if result is not None and not isinstance(result, (bytes, str)):
            raise Exception('Expected result to be of type str')

        self.error = Error.from_json(error) if error else None
        self.ok = ok
        self.result = result
        self.unknown_fields = unknown_fields



class StringBoolResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~StringBoolResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [StringBoolResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class StringResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, (bytes, str)):
            raise Exception('Expected result to be of type str')

        self.error = Error.from_json(error) if error else None
        self.result = result
        self.unknown_fields = unknown_fields



class StringResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~StringResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [StringResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class StringsResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : typing.Sequence[str]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, list):
            raise Exception('Expected result to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.result = result
        self.unknown_fields = unknown_fields



class StringsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~StringsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [StringsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class StringsWatchResult(Type):
    _toSchema = {'changes': 'changes', 'error': 'error', 'watcher_id': 'watcher-id'}
    _toPy = {'changes': 'changes', 'error': 'error', 'watcher-id': 'watcher_id'}
    def __init__(self, changes=None, error=None, watcher_id=None, **unknown_fields):
        '''
        changes : typing.Sequence[str]
        error : Error
        watcher_id : str
        '''
        if changes is not None and not isinstance(changes, list):
            raise Exception('Expected changes to be of type Sequence')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if watcher_id is not None and not isinstance(watcher_id, (bytes, str)):
            raise Exception('Expected watcher_id to be of type str')

        self.changes = changes
        self.error = Error.from_json(error) if error else None
        self.watcher_id = watcher_id
        self.unknown_fields = unknown_fields



class StringsWatchResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~StringsWatchResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [StringsWatchResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class Subnet(Type):
    _toSchema = {'cidr': 'cidr', 'life': 'life', 'provider_id': 'provider-id', 'provider_network_id': 'provider-network-id', 'provider_space_id': 'provider-space-id', 'space_tag': 'space-tag', 'status': 'status', 'vlan_tag': 'vlan-tag', 'zones': 'zones'}
    _toPy = {'cidr': 'cidr', 'life': 'life', 'provider-id': 'provider_id', 'provider-network-id': 'provider_network_id', 'provider-space-id': 'provider_space_id', 'space-tag': 'space_tag', 'status': 'status', 'vlan-tag': 'vlan_tag', 'zones': 'zones'}
    def __init__(self, cidr=None, life=None, provider_id=None, provider_network_id=None, provider_space_id=None, space_tag=None, status=None, vlan_tag=None, zones=None, **unknown_fields):
        '''
        cidr : str
        life : str
        provider_id : str
        provider_network_id : str
        provider_space_id : str
        space_tag : str
        status : str
        vlan_tag : int
        zones : typing.Sequence[str]
        '''
        if cidr is not None and not isinstance(cidr, (bytes, str)):
            raise Exception('Expected cidr to be of type str')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if provider_id is not None and not isinstance(provider_id, (bytes, str)):
            raise Exception('Expected provider_id to be of type str')

        if provider_network_id is not None and not isinstance(provider_network_id, (bytes, str)):
            raise Exception('Expected provider_network_id to be of type str')

        if provider_space_id is not None and not isinstance(provider_space_id, (bytes, str)):
            raise Exception('Expected provider_space_id to be of type str')

        if space_tag is not None and not isinstance(space_tag, (bytes, str)):
            raise Exception('Expected space_tag to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        if vlan_tag is not None and not isinstance(vlan_tag, int):
            raise Exception('Expected vlan_tag to be of type int')

        if zones is not None and not isinstance(zones, list):
            raise Exception('Expected zones to be of type Sequence')

        self.cidr = cidr
        self.life = life
        self.provider_id = provider_id
        self.provider_network_id = provider_network_id
        self.provider_space_id = provider_space_id
        self.space_tag = space_tag
        self.status = status
        self.vlan_tag = vlan_tag
        self.zones = zones
        self.unknown_fields = unknown_fields



class SubnetsFilters(Type):
    _toSchema = {'space_tag': 'space-tag', 'zone': 'zone'}
    _toPy = {'space-tag': 'space_tag', 'zone': 'zone'}
    def __init__(self, space_tag=None, zone=None, **unknown_fields):
        '''
        space_tag : str
        zone : str
        '''
        if space_tag is not None and not isinstance(space_tag, (bytes, str)):
            raise Exception('Expected space_tag to be of type str')

        if zone is not None and not isinstance(zone, (bytes, str)):
            raise Exception('Expected zone to be of type str')

        self.space_tag = space_tag
        self.zone = zone
        self.unknown_fields = unknown_fields



class TaggedCredential(Type):
    _toSchema = {'credential': 'credential', 'tag': 'tag'}
    _toPy = {'credential': 'credential', 'tag': 'tag'}
    def __init__(self, credential=None, tag=None, **unknown_fields):
        '''
        credential : CloudCredential
        tag : str
        '''
        if credential is not None and not isinstance(credential, CloudCredential):
            raise Exception('Expected credential to be of type CloudCredential')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.credential = CloudCredential.from_json(credential) if credential else None
        self.tag = tag
        self.unknown_fields = unknown_fields



class TaggedCredentials(Type):
    _toSchema = {'credentials': 'credentials'}
    _toPy = {'credentials': 'credentials'}
    def __init__(self, credentials=None, **unknown_fields):
        '''
        credentials : typing.Sequence[~TaggedCredential]
        '''
        if credentials is not None and not isinstance(credentials, list):
            raise Exception('Expected credentials to be of type Sequence')

        self.credentials = [TaggedCredential.from_json(o) for o in credentials or []]
        self.unknown_fields = unknown_fields



class TokenResult(Type):
    _toSchema = {'error': 'error', 'token': 'token'}
    _toPy = {'error': 'error', 'token': 'token'}
    def __init__(self, error=None, token=None, **unknown_fields):
        '''
        error : Error
        token : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if token is not None and not isinstance(token, (bytes, str)):
            raise Exception('Expected token to be of type str')

        self.error = Error.from_json(error) if error else None
        self.token = token
        self.unknown_fields = unknown_fields



class TokenResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~TokenResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [TokenResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class Tools(Type):
    _toSchema = {'sha256': 'sha256', 'size': 'size', 'url': 'url', 'version': 'version'}
    _toPy = {'sha256': 'sha256', 'size': 'size', 'url': 'url', 'version': 'version'}
    def __init__(self, sha256=None, size=None, url=None, version=None, **unknown_fields):
        '''
        sha256 : str
        size : int
        url : str
        version : Binary
        '''
        if sha256 is not None and not isinstance(sha256, (bytes, str)):
            raise Exception('Expected sha256 to be of type str')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if url is not None and not isinstance(url, (bytes, str)):
            raise Exception('Expected url to be of type str')

        if version is not None and not isinstance(version, Binary):
            raise Exception('Expected version to be of type Binary')

        self.sha256 = sha256
        self.size = size
        self.url = url
        self.version = Binary.from_json(version) if version else None
        self.unknown_fields = unknown_fields



class ToolsResult(Type):
    _toSchema = {'disable_ssl_hostname_verification': 'disable-ssl-hostname-verification', 'error': 'error', 'tools': 'tools'}
    _toPy = {'disable-ssl-hostname-verification': 'disable_ssl_hostname_verification', 'error': 'error', 'tools': 'tools'}
    def __init__(self, disable_ssl_hostname_verification=None, error=None, tools=None, **unknown_fields):
        '''
        disable_ssl_hostname_verification : bool
        error : Error
        tools : typing.Sequence[~Tools]
        '''
        if disable_ssl_hostname_verification is not None and not isinstance(disable_ssl_hostname_verification, bool):
            raise Exception('Expected disable_ssl_hostname_verification to be of type bool')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if tools is not None and not isinstance(tools, list):
            raise Exception('Expected tools to be of type Sequence')

        self.disable_ssl_hostname_verification = disable_ssl_hostname_verification
        self.error = Error.from_json(error) if error else None
        self.tools = [Tools.from_json(o) for o in tools or []]
        self.unknown_fields = unknown_fields



class ToolsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ToolsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ToolsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class TrackArgs(Type):
    _toSchema = {'payloads': 'payloads'}
    _toPy = {'payloads': 'payloads'}
    def __init__(self, payloads=None, **unknown_fields):
        '''
        payloads : typing.Sequence[~Payload]
        '''
        if payloads is not None and not isinstance(payloads, list):
            raise Exception('Expected payloads to be of type Sequence')

        self.payloads = [Payload.from_json(o) for o in payloads or []]
        self.unknown_fields = unknown_fields



class TrackPayloadArgs(Type):
    _toSchema = {'payloads': 'payloads'}
    _toPy = {'payloads': 'payloads'}
    def __init__(self, payloads=None, **unknown_fields):
        '''
        payloads : typing.Sequence[~Payload]
        '''
        if payloads is not None and not isinstance(payloads, list):
            raise Exception('Expected payloads to be of type Sequence')

        self.payloads = [Payload.from_json(o) for o in payloads or []]
        self.unknown_fields = unknown_fields



class UndertakerModelInfo(Type):
    _toSchema = {'force_destroyed': 'force-destroyed', 'global_name': 'global-name', 'is_system': 'is-system', 'life': 'life', 'name': 'name', 'uuid': 'uuid'}
    _toPy = {'force-destroyed': 'force_destroyed', 'global-name': 'global_name', 'is-system': 'is_system', 'life': 'life', 'name': 'name', 'uuid': 'uuid'}
    def __init__(self, force_destroyed=None, global_name=None, is_system=None, life=None, name=None, uuid=None, **unknown_fields):
        '''
        force_destroyed : bool
        global_name : str
        is_system : bool
        life : str
        name : str
        uuid : str
        '''
        if force_destroyed is not None and not isinstance(force_destroyed, bool):
            raise Exception('Expected force_destroyed to be of type bool')

        if global_name is not None and not isinstance(global_name, (bytes, str)):
            raise Exception('Expected global_name to be of type str')

        if is_system is not None and not isinstance(is_system, bool):
            raise Exception('Expected is_system to be of type bool')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if uuid is not None and not isinstance(uuid, (bytes, str)):
            raise Exception('Expected uuid to be of type str')

        self.force_destroyed = force_destroyed
        self.global_name = global_name
        self.is_system = is_system
        self.life = life
        self.name = name
        self.uuid = uuid
        self.unknown_fields = unknown_fields



class UndertakerModelInfoResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : UndertakerModelInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, UndertakerModelInfo):
            raise Exception('Expected result to be of type UndertakerModelInfo')

        self.error = Error.from_json(error) if error else None
        self.result = UndertakerModelInfo.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class UnitNetworkConfig(Type):
    _toSchema = {'binding_name': 'binding-name', 'unit_tag': 'unit-tag'}
    _toPy = {'binding-name': 'binding_name', 'unit-tag': 'unit_tag'}
    def __init__(self, binding_name=None, unit_tag=None, **unknown_fields):
        '''
        binding_name : str
        unit_tag : str
        '''
        if binding_name is not None and not isinstance(binding_name, (bytes, str)):
            raise Exception('Expected binding_name to be of type str')

        if unit_tag is not None and not isinstance(unit_tag, (bytes, str)):
            raise Exception('Expected unit_tag to be of type str')

        self.binding_name = binding_name
        self.unit_tag = unit_tag
        self.unknown_fields = unknown_fields



class UnitNetworkConfigResult(Type):
    _toSchema = {'error': 'error', 'info': 'info'}
    _toPy = {'error': 'error', 'info': 'info'}
    def __init__(self, error=None, info=None, **unknown_fields):
        '''
        error : Error
        info : typing.Sequence[~NetworkConfig]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if info is not None and not isinstance(info, list):
            raise Exception('Expected info to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.info = [NetworkConfig.from_json(o) for o in info or []]
        self.unknown_fields = unknown_fields



class UnitNetworkConfigResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~UnitNetworkConfigResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [UnitNetworkConfigResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class UnitRefreshResult(Type):
    _toSchema = {'error': 'Error', 'life': 'Life', 'resolved': 'Resolved'}
    _toPy = {'Error': 'error', 'Life': 'life', 'Resolved': 'resolved'}
    def __init__(self, error=None, life=None, resolved=None, **unknown_fields):
        '''
        error : Error
        life : str
        resolved : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if resolved is not None and not isinstance(resolved, (bytes, str)):
            raise Exception('Expected resolved to be of type str')

        self.error = Error.from_json(error) if error else None
        self.life = life
        self.resolved = resolved
        self.unknown_fields = unknown_fields



class UnitRefreshResults(Type):
    _toSchema = {'results': 'Results'}
    _toPy = {'Results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~UnitRefreshResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [UnitRefreshResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class UnitResourceResult(Type):
    _toSchema = {'error': 'error', 'errorresult': 'ErrorResult', 'resource': 'resource'}
    _toPy = {'ErrorResult': 'errorresult', 'error': 'error', 'resource': 'resource'}
    def __init__(self, errorresult=None, error=None, resource=None, **unknown_fields):
        '''
        errorresult : ErrorResult
        error : Error
        resource : Resource
        '''
        if errorresult is not None and not isinstance(errorresult, ErrorResult):
            raise Exception('Expected errorresult to be of type ErrorResult')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if resource is not None and not isinstance(resource, Resource):
            raise Exception('Expected resource to be of type Resource')

        self.errorresult = ErrorResult.from_json(errorresult) if errorresult else None
        self.error = Error.from_json(error) if error else None
        self.resource = Resource.from_json(resource) if resource else None
        self.unknown_fields = unknown_fields



class UnitResources(Type):
    _toSchema = {'download_progress': 'download-progress', 'entity': 'Entity', 'resources': 'resources', 'tag': 'tag'}
    _toPy = {'Entity': 'entity', 'download-progress': 'download_progress', 'resources': 'resources', 'tag': 'tag'}
    def __init__(self, entity=None, download_progress=None, resources=None, tag=None, **unknown_fields):
        '''
        entity : Entity
        download_progress : typing.Mapping[str, int]
        resources : typing.Sequence[~Resource]
        tag : str
        '''
        if entity is not None and not isinstance(entity, Entity):
            raise Exception('Expected entity to be of type Entity')

        if download_progress is not None and not isinstance(download_progress, dict):
            raise Exception('Expected download_progress to be of type Mapping')

        if resources is not None and not isinstance(resources, list):
            raise Exception('Expected resources to be of type Sequence')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.entity = Entity.from_json(entity) if entity else None
        self.download_progress = download_progress
        self.resources = [Resource.from_json(o) for o in resources or []]
        self.tag = tag
        self.unknown_fields = unknown_fields



class UnitResourcesResult(Type):
    _toSchema = {'error': 'error', 'errorresult': 'ErrorResult', 'resources': 'resources'}
    _toPy = {'ErrorResult': 'errorresult', 'error': 'error', 'resources': 'resources'}
    def __init__(self, errorresult=None, error=None, resources=None, **unknown_fields):
        '''
        errorresult : ErrorResult
        error : Error
        resources : typing.Sequence[~UnitResourceResult]
        '''
        if errorresult is not None and not isinstance(errorresult, ErrorResult):
            raise Exception('Expected errorresult to be of type ErrorResult')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if resources is not None and not isinstance(resources, list):
            raise Exception('Expected resources to be of type Sequence')

        self.errorresult = ErrorResult.from_json(errorresult) if errorresult else None
        self.error = Error.from_json(error) if error else None
        self.resources = [UnitResourceResult.from_json(o) for o in resources or []]
        self.unknown_fields = unknown_fields



class UnitSettings(Type):
    _toSchema = {'version': 'version'}
    _toPy = {'version': 'version'}
    def __init__(self, version=None, **unknown_fields):
        '''
        version : int
        '''
        if version is not None and not isinstance(version, int):
            raise Exception('Expected version to be of type int')

        self.version = version
        self.unknown_fields = unknown_fields



class UnitStatus(Type):
    _toSchema = {'address': 'address', 'agent_status': 'agent-status', 'charm': 'charm', 'leader': 'leader', 'machine': 'machine', 'opened_ports': 'opened-ports', 'provider_id': 'provider-id', 'public_address': 'public-address', 'subordinates': 'subordinates', 'workload_status': 'workload-status', 'workload_version': 'workload-version'}
    _toPy = {'address': 'address', 'agent-status': 'agent_status', 'charm': 'charm', 'leader': 'leader', 'machine': 'machine', 'opened-ports': 'opened_ports', 'provider-id': 'provider_id', 'public-address': 'public_address', 'subordinates': 'subordinates', 'workload-status': 'workload_status', 'workload-version': 'workload_version'}
    def __init__(self, address=None, agent_status=None, charm=None, leader=None, machine=None, opened_ports=None, provider_id=None, public_address=None, subordinates=None, workload_status=None, workload_version=None, **unknown_fields):
        '''
        address : str
        agent_status : DetailedStatus
        charm : str
        leader : bool
        machine : str
        opened_ports : typing.Sequence[str]
        provider_id : str
        public_address : str
        subordinates : typing.Mapping[str, ~UnitStatus]
        workload_status : DetailedStatus
        workload_version : str
        '''
        if address is not None and not isinstance(address, (bytes, str)):
            raise Exception('Expected address to be of type str')

        if agent_status is not None and not isinstance(agent_status, DetailedStatus):
            raise Exception('Expected agent_status to be of type DetailedStatus')

        if charm is not None and not isinstance(charm, (bytes, str)):
            raise Exception('Expected charm to be of type str')

        if leader is not None and not isinstance(leader, bool):
            raise Exception('Expected leader to be of type bool')

        if machine is not None and not isinstance(machine, (bytes, str)):
            raise Exception('Expected machine to be of type str')

        if opened_ports is not None and not isinstance(opened_ports, list):
            raise Exception('Expected opened_ports to be of type Sequence')

        if provider_id is not None and not isinstance(provider_id, (bytes, str)):
            raise Exception('Expected provider_id to be of type str')

        if public_address is not None and not isinstance(public_address, (bytes, str)):
            raise Exception('Expected public_address to be of type str')

        if subordinates is not None and not isinstance(subordinates, dict):
            raise Exception('Expected subordinates to be of type Mapping')

        if workload_status is not None and not isinstance(workload_status, DetailedStatus):
            raise Exception('Expected workload_status to be of type DetailedStatus')

        if workload_version is not None and not isinstance(workload_version, (bytes, str)):
            raise Exception('Expected workload_version to be of type str')

        self.address = address
        self.agent_status = DetailedStatus.from_json(agent_status) if agent_status else None
        self.charm = charm
        self.leader = leader
        self.machine = machine
        self.opened_ports = opened_ports
        self.provider_id = provider_id
        self.public_address = public_address
        self.subordinates = subordinates
        self.workload_status = DetailedStatus.from_json(workload_status) if workload_status else None
        self.workload_version = workload_version
        self.unknown_fields = unknown_fields



class UnitsNetworkConfig(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~UnitNetworkConfig]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [UnitNetworkConfig.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class UnitsResolved(Type):
    _toSchema = {'all_': 'all', 'retry': 'retry', 'tags': 'tags'}
    _toPy = {'all': 'all_', 'retry': 'retry', 'tags': 'tags'}
    def __init__(self, all_=None, retry=None, tags=None, **unknown_fields):
        '''
        all_ : bool
        retry : bool
        tags : Entities
        '''
        if all_ is not None and not isinstance(all_, bool):
            raise Exception('Expected all_ to be of type bool')

        if retry is not None and not isinstance(retry, bool):
            raise Exception('Expected retry to be of type bool')

        if tags is not None and not isinstance(tags, Entities):
            raise Exception('Expected tags to be of type Entities')

        self.all_ = all_
        self.retry = retry
        self.tags = Entities.from_json(tags) if tags else None
        self.unknown_fields = unknown_fields



class UnsetModelDefaults(Type):
    _toSchema = {'keys': 'keys'}
    _toPy = {'keys': 'keys'}
    def __init__(self, keys=None, **unknown_fields):
        '''
        keys : typing.Sequence[~ModelUnsetKeys]
        '''
        if keys is not None and not isinstance(keys, list):
            raise Exception('Expected keys to be of type Sequence')

        self.keys = [ModelUnsetKeys.from_json(o) for o in keys or []]
        self.unknown_fields = unknown_fields



class UpdateApplicationServiceArg(Type):
    _toSchema = {'addresses': 'addresses', 'application_tag': 'application-tag', 'generation': 'generation', 'provider_id': 'provider-id', 'scale': 'scale'}
    _toPy = {'addresses': 'addresses', 'application-tag': 'application_tag', 'generation': 'generation', 'provider-id': 'provider_id', 'scale': 'scale'}
    def __init__(self, addresses=None, application_tag=None, generation=None, provider_id=None, scale=None, **unknown_fields):
        '''
        addresses : typing.Sequence[~Address]
        application_tag : str
        generation : int
        provider_id : str
        scale : int
        '''
        if addresses is not None and not isinstance(addresses, list):
            raise Exception('Expected addresses to be of type Sequence')

        if application_tag is not None and not isinstance(application_tag, (bytes, str)):
            raise Exception('Expected application_tag to be of type str')

        if generation is not None and not isinstance(generation, int):
            raise Exception('Expected generation to be of type int')

        if provider_id is not None and not isinstance(provider_id, (bytes, str)):
            raise Exception('Expected provider_id to be of type str')

        if scale is not None and not isinstance(scale, int):
            raise Exception('Expected scale to be of type int')

        self.addresses = [Address.from_json(o) for o in addresses or []]
        self.application_tag = application_tag
        self.generation = generation
        self.provider_id = provider_id
        self.scale = scale
        self.unknown_fields = unknown_fields



class UpdateApplicationServiceArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~UpdateApplicationServiceArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [UpdateApplicationServiceArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class UpdateApplicationUnitArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~UpdateApplicationUnits]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [UpdateApplicationUnits.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class UpdateApplicationUnits(Type):
    _toSchema = {'application_tag': 'application-tag', 'generation': 'generation', 'scale': 'scale', 'status': 'status', 'units': 'units'}
    _toPy = {'application-tag': 'application_tag', 'generation': 'generation', 'scale': 'scale', 'status': 'status', 'units': 'units'}
    def __init__(self, application_tag=None, generation=None, scale=None, status=None, units=None, **unknown_fields):
        '''
        application_tag : str
        generation : int
        scale : int
        status : EntityStatus
        units : typing.Sequence[~ApplicationUnitParams]
        '''
        if application_tag is not None and not isinstance(application_tag, (bytes, str)):
            raise Exception('Expected application_tag to be of type str')

        if generation is not None and not isinstance(generation, int):
            raise Exception('Expected generation to be of type int')

        if scale is not None and not isinstance(scale, int):
            raise Exception('Expected scale to be of type int')

        if status is not None and not isinstance(status, EntityStatus):
            raise Exception('Expected status to be of type EntityStatus')

        if units is not None and not isinstance(units, list):
            raise Exception('Expected units to be of type Sequence')

        self.application_tag = application_tag
        self.generation = generation
        self.scale = scale
        self.status = EntityStatus.from_json(status) if status else None
        self.units = [ApplicationUnitParams.from_json(o) for o in units or []]
        self.unknown_fields = unknown_fields



class UpdateBehavior(Type):
    _toSchema = {'enable_os_refresh_update': 'enable-os-refresh-update', 'enable_os_upgrade': 'enable-os-upgrade'}
    _toPy = {'enable-os-refresh-update': 'enable_os_refresh_update', 'enable-os-upgrade': 'enable_os_upgrade'}
    def __init__(self, enable_os_refresh_update=None, enable_os_upgrade=None, **unknown_fields):
        '''
        enable_os_refresh_update : bool
        enable_os_upgrade : bool
        '''
        if enable_os_refresh_update is not None and not isinstance(enable_os_refresh_update, bool):
            raise Exception('Expected enable_os_refresh_update to be of type bool')

        if enable_os_upgrade is not None and not isinstance(enable_os_upgrade, bool):
            raise Exception('Expected enable_os_upgrade to be of type bool')

        self.enable_os_refresh_update = enable_os_refresh_update
        self.enable_os_upgrade = enable_os_upgrade
        self.unknown_fields = unknown_fields



class UpdateCloudArgs(Type):
    _toSchema = {'clouds': 'clouds'}
    _toPy = {'clouds': 'clouds'}
    def __init__(self, clouds=None, **unknown_fields):
        '''
        clouds : typing.Sequence[~AddCloudArgs]
        '''
        if clouds is not None and not isinstance(clouds, list):
            raise Exception('Expected clouds to be of type Sequence')

        self.clouds = [AddCloudArgs.from_json(o) for o in clouds or []]
        self.unknown_fields = unknown_fields



class UpdateCloudCredential(Type):
    _toSchema = {'credential': 'credential', 'tag': 'tag'}
    _toPy = {'credential': 'credential', 'tag': 'tag'}
    def __init__(self, credential=None, tag=None, **unknown_fields):
        '''
        credential : CloudCredential
        tag : str
        '''
        if credential is not None and not isinstance(credential, CloudCredential):
            raise Exception('Expected credential to be of type CloudCredential')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.credential = CloudCredential.from_json(credential) if credential else None
        self.tag = tag
        self.unknown_fields = unknown_fields



class UpdateCloudCredentials(Type):
    _toSchema = {'credentials': 'credentials'}
    _toPy = {'credentials': 'credentials'}
    def __init__(self, credentials=None, **unknown_fields):
        '''
        credentials : typing.Sequence[~UpdateCloudCredential]
        '''
        if credentials is not None and not isinstance(credentials, list):
            raise Exception('Expected credentials to be of type Sequence')

        self.credentials = [UpdateCloudCredential.from_json(o) for o in credentials or []]
        self.unknown_fields = unknown_fields



class UpdateCredentialArgs(Type):
    _toSchema = {'credentials': 'credentials', 'force': 'force'}
    _toPy = {'credentials': 'credentials', 'force': 'force'}
    def __init__(self, credentials=None, force=None, **unknown_fields):
        '''
        credentials : typing.Sequence[~TaggedCredential]
        force : bool
        '''
        if credentials is not None and not isinstance(credentials, list):
            raise Exception('Expected credentials to be of type Sequence')

        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        self.credentials = [TaggedCredential.from_json(o) for o in credentials or []]
        self.force = force
        self.unknown_fields = unknown_fields



class UpdateCredentialModelResult(Type):
    _toSchema = {'errors': 'errors', 'name': 'name', 'uuid': 'uuid'}
    _toPy = {'errors': 'errors', 'name': 'name', 'uuid': 'uuid'}
    def __init__(self, errors=None, name=None, uuid=None, **unknown_fields):
        '''
        errors : typing.Sequence[~ErrorResult]
        name : str
        uuid : str
        '''
        if errors is not None and not isinstance(errors, list):
            raise Exception('Expected errors to be of type Sequence')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        if uuid is not None and not isinstance(uuid, (bytes, str)):
            raise Exception('Expected uuid to be of type str')

        self.errors = [ErrorResult.from_json(o) for o in errors or []]
        self.name = name
        self.uuid = uuid
        self.unknown_fields = unknown_fields



class UpdateCredentialResult(Type):
    _toSchema = {'error': 'error', 'models': 'models', 'tag': 'tag'}
    _toPy = {'error': 'error', 'models': 'models', 'tag': 'tag'}
    def __init__(self, error=None, models=None, tag=None, **unknown_fields):
        '''
        error : Error
        models : typing.Sequence[~UpdateCredentialModelResult]
        tag : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if models is not None and not isinstance(models, list):
            raise Exception('Expected models to be of type Sequence')

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception('Expected tag to be of type str')

        self.error = Error.from_json(error) if error else None
        self.models = [UpdateCredentialModelResult.from_json(o) for o in models or []]
        self.tag = tag
        self.unknown_fields = unknown_fields



class UpdateCredentialResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~UpdateCredentialResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [UpdateCredentialResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class UpdateSeriesArg(Type):
    _toSchema = {'force': 'force', 'series': 'series', 'tag': 'tag'}
    _toPy = {'force': 'force', 'series': 'series', 'tag': 'tag'}
    def __init__(self, force=None, series=None, tag=None, **unknown_fields):
        '''
        force : bool
        series : str
        tag : Entity
        '''
        if force is not None and not isinstance(force, bool):
            raise Exception('Expected force to be of type bool')

        if series is not None and not isinstance(series, (bytes, str)):
            raise Exception('Expected series to be of type str')

        if tag is not None and not isinstance(tag, Entity):
            raise Exception('Expected tag to be of type Entity')

        self.force = force
        self.series = series
        self.tag = Entity.from_json(tag) if tag else None
        self.unknown_fields = unknown_fields



class UpdateSeriesArgs(Type):
    _toSchema = {'args': 'args'}
    _toPy = {'args': 'args'}
    def __init__(self, args=None, **unknown_fields):
        '''
        args : typing.Sequence[~UpdateSeriesArg]
        '''
        if args is not None and not isinstance(args, list):
            raise Exception('Expected args to be of type Sequence')

        self.args = [UpdateSeriesArg.from_json(o) for o in args or []]
        self.unknown_fields = unknown_fields



class UpgradeMongoParams(Type):
    _toSchema = {'target': 'target'}
    _toPy = {'target': 'target'}
    def __init__(self, target=None, **unknown_fields):
        '''
        target : MongoVersion
        '''
        if target is not None and not isinstance(target, MongoVersion):
            raise Exception('Expected target to be of type MongoVersion')

        self.target = MongoVersion.from_json(target) if target else None
        self.unknown_fields = unknown_fields



class UpgradeSeriesNotificationParam(Type):
    _toSchema = {'entity': 'entity', 'watcher_id': 'watcher-id'}
    _toPy = {'entity': 'entity', 'watcher-id': 'watcher_id'}
    def __init__(self, entity=None, watcher_id=None, **unknown_fields):
        '''
        entity : Entity
        watcher_id : str
        '''
        if entity is not None and not isinstance(entity, Entity):
            raise Exception('Expected entity to be of type Entity')

        if watcher_id is not None and not isinstance(watcher_id, (bytes, str)):
            raise Exception('Expected watcher_id to be of type str')

        self.entity = Entity.from_json(entity) if entity else None
        self.watcher_id = watcher_id
        self.unknown_fields = unknown_fields



class UpgradeSeriesNotificationParams(Type):
    _toSchema = {'params': 'params'}
    _toPy = {'params': 'params'}
    def __init__(self, params=None, **unknown_fields):
        '''
        params : typing.Sequence[~UpgradeSeriesNotificationParam]
        '''
        if params is not None and not isinstance(params, list):
            raise Exception('Expected params to be of type Sequence')

        self.params = [UpgradeSeriesNotificationParam.from_json(o) for o in params or []]
        self.unknown_fields = unknown_fields



class UpgradeSeriesStartUnitCompletionParam(Type):
    _toSchema = {'entities': 'entities', 'message': 'message'}
    _toPy = {'entities': 'entities', 'message': 'message'}
    def __init__(self, entities=None, message=None, **unknown_fields):
        '''
        entities : typing.Sequence[~Entity]
        message : str
        '''
        if entities is not None and not isinstance(entities, list):
            raise Exception('Expected entities to be of type Sequence')

        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        self.entities = [Entity.from_json(o) for o in entities or []]
        self.message = message
        self.unknown_fields = unknown_fields



class UpgradeSeriesStatusParam(Type):
    _toSchema = {'entity': 'entity', 'message': 'message', 'status': 'status'}
    _toPy = {'entity': 'entity', 'message': 'message', 'status': 'status'}
    def __init__(self, entity=None, message=None, status=None, **unknown_fields):
        '''
        entity : Entity
        message : str
        status : str
        '''
        if entity is not None and not isinstance(entity, Entity):
            raise Exception('Expected entity to be of type Entity')

        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception('Expected message to be of type str')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        self.entity = Entity.from_json(entity) if entity else None
        self.message = message
        self.status = status
        self.unknown_fields = unknown_fields



class UpgradeSeriesStatusParams(Type):
    _toSchema = {'params': 'params'}
    _toPy = {'params': 'params'}
    def __init__(self, params=None, **unknown_fields):
        '''
        params : typing.Sequence[~UpgradeSeriesStatusParam]
        '''
        if params is not None and not isinstance(params, list):
            raise Exception('Expected params to be of type Sequence')

        self.params = [UpgradeSeriesStatusParam.from_json(o) for o in params or []]
        self.unknown_fields = unknown_fields



class UpgradeSeriesStatusResult(Type):
    _toSchema = {'error': 'error', 'status': 'status'}
    _toPy = {'error': 'error', 'status': 'status'}
    def __init__(self, error=None, status=None, **unknown_fields):
        '''
        error : Error
        status : str
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if status is not None and not isinstance(status, (bytes, str)):
            raise Exception('Expected status to be of type str')

        self.error = Error.from_json(error) if error else None
        self.status = status
        self.unknown_fields = unknown_fields



class UpgradeSeriesStatusResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~UpgradeSeriesStatusResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [UpgradeSeriesStatusResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class UpgradeSeriesUnitsResult(Type):
    _toSchema = {'error': 'error', 'unit_names': 'unit-names'}
    _toPy = {'error': 'error', 'unit-names': 'unit_names'}
    def __init__(self, error=None, unit_names=None, **unknown_fields):
        '''
        error : Error
        unit_names : typing.Sequence[str]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if unit_names is not None and not isinstance(unit_names, list):
            raise Exception('Expected unit_names to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.unit_names = unit_names
        self.unknown_fields = unknown_fields



class UpgradeSeriesUnitsResults(Type):
    _toSchema = {'results': 'Results'}
    _toPy = {'Results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~UpgradeSeriesUnitsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [UpgradeSeriesUnitsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class UserAccess(Type):
    _toSchema = {'access': 'access', 'user_tag': 'user-tag'}
    _toPy = {'access': 'access', 'user-tag': 'user_tag'}
    def __init__(self, access=None, user_tag=None, **unknown_fields):
        '''
        access : str
        user_tag : str
        '''
        if access is not None and not isinstance(access, (bytes, str)):
            raise Exception('Expected access to be of type str')

        if user_tag is not None and not isinstance(user_tag, (bytes, str)):
            raise Exception('Expected user_tag to be of type str')

        self.access = access
        self.user_tag = user_tag
        self.unknown_fields = unknown_fields



class UserAccessResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : UserAccess
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, UserAccess):
            raise Exception('Expected result to be of type UserAccess')

        self.error = Error.from_json(error) if error else None
        self.result = UserAccess.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class UserAccessResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~UserAccessResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [UserAccessResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class UserCloud(Type):
    _toSchema = {'cloud_tag': 'cloud-tag', 'user_tag': 'user-tag'}
    _toPy = {'cloud-tag': 'cloud_tag', 'user-tag': 'user_tag'}
    def __init__(self, cloud_tag=None, user_tag=None, **unknown_fields):
        '''
        cloud_tag : str
        user_tag : str
        '''
        if cloud_tag is not None and not isinstance(cloud_tag, (bytes, str)):
            raise Exception('Expected cloud_tag to be of type str')

        if user_tag is not None and not isinstance(user_tag, (bytes, str)):
            raise Exception('Expected user_tag to be of type str')

        self.cloud_tag = cloud_tag
        self.user_tag = user_tag
        self.unknown_fields = unknown_fields



class UserClouds(Type):
    _toSchema = {'user_clouds': 'user-clouds'}
    _toPy = {'user-clouds': 'user_clouds'}
    def __init__(self, user_clouds=None, **unknown_fields):
        '''
        user_clouds : typing.Sequence[~UserCloud]
        '''
        if user_clouds is not None and not isinstance(user_clouds, list):
            raise Exception('Expected user_clouds to be of type Sequence')

        self.user_clouds = [UserCloud.from_json(o) for o in user_clouds or []]
        self.unknown_fields = unknown_fields



class UserInfo(Type):
    _toSchema = {'access': 'access', 'created_by': 'created-by', 'date_created': 'date-created', 'disabled': 'disabled', 'display_name': 'display-name', 'last_connection': 'last-connection', 'username': 'username'}
    _toPy = {'access': 'access', 'created-by': 'created_by', 'date-created': 'date_created', 'disabled': 'disabled', 'display-name': 'display_name', 'last-connection': 'last_connection', 'username': 'username'}
    def __init__(self, access=None, created_by=None, date_created=None, disabled=None, display_name=None, last_connection=None, username=None, **unknown_fields):
        '''
        access : str
        created_by : str
        date_created : str
        disabled : bool
        display_name : str
        last_connection : str
        username : str
        '''
        if access is not None and not isinstance(access, (bytes, str)):
            raise Exception('Expected access to be of type str')

        if created_by is not None and not isinstance(created_by, (bytes, str)):
            raise Exception('Expected created_by to be of type str')

        if date_created is not None and not isinstance(date_created, (bytes, str)):
            raise Exception('Expected date_created to be of type str')

        if disabled is not None and not isinstance(disabled, bool):
            raise Exception('Expected disabled to be of type bool')

        if display_name is not None and not isinstance(display_name, (bytes, str)):
            raise Exception('Expected display_name to be of type str')

        if last_connection is not None and not isinstance(last_connection, (bytes, str)):
            raise Exception('Expected last_connection to be of type str')

        if username is not None and not isinstance(username, (bytes, str)):
            raise Exception('Expected username to be of type str')

        self.access = access
        self.created_by = created_by
        self.date_created = date_created
        self.disabled = disabled
        self.display_name = display_name
        self.last_connection = last_connection
        self.username = username
        self.unknown_fields = unknown_fields



class UserInfoRequest(Type):
    _toSchema = {'entities': 'entities', 'include_disabled': 'include-disabled'}
    _toPy = {'entities': 'entities', 'include-disabled': 'include_disabled'}
    def __init__(self, entities=None, include_disabled=None, **unknown_fields):
        '''
        entities : typing.Sequence[~Entity]
        include_disabled : bool
        '''
        if entities is not None and not isinstance(entities, list):
            raise Exception('Expected entities to be of type Sequence')

        if include_disabled is not None and not isinstance(include_disabled, bool):
            raise Exception('Expected include_disabled to be of type bool')

        self.entities = [Entity.from_json(o) for o in entities or []]
        self.include_disabled = include_disabled
        self.unknown_fields = unknown_fields



class UserInfoResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : UserInfo
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, UserInfo):
            raise Exception('Expected result to be of type UserInfo')

        self.error = Error.from_json(error) if error else None
        self.result = UserInfo.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class UserInfoResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~UserInfoResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [UserInfoResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class UserModel(Type):
    _toSchema = {'last_connection': 'last-connection', 'model': 'model'}
    _toPy = {'last-connection': 'last_connection', 'model': 'model'}
    def __init__(self, last_connection=None, model=None, **unknown_fields):
        '''
        last_connection : str
        model : Model
        '''
        if last_connection is not None and not isinstance(last_connection, (bytes, str)):
            raise Exception('Expected last_connection to be of type str')

        if model is not None and not isinstance(model, Model):
            raise Exception('Expected model to be of type Model')

        self.last_connection = last_connection
        self.model = Model.from_json(model) if model else None
        self.unknown_fields = unknown_fields



class UserModelList(Type):
    _toSchema = {'user_models': 'user-models'}
    _toPy = {'user-models': 'user_models'}
    def __init__(self, user_models=None, **unknown_fields):
        '''
        user_models : typing.Sequence[~UserModel]
        '''
        if user_models is not None and not isinstance(user_models, list):
            raise Exception('Expected user_models to be of type Sequence')

        self.user_models = [UserModel.from_json(o) for o in user_models or []]
        self.unknown_fields = unknown_fields



class Value(Type):
    _toSchema = {'arch': 'arch', 'container': 'container', 'cores': 'cores', 'cpu_power': 'cpu-power', 'instance_type': 'instance-type', 'mem': 'mem', 'root_disk': 'root-disk', 'root_disk_source': 'root-disk-source', 'spaces': 'spaces', 'tags': 'tags', 'virt_type': 'virt-type', 'zones': 'zones'}
    _toPy = {'arch': 'arch', 'container': 'container', 'cores': 'cores', 'cpu-power': 'cpu_power', 'instance-type': 'instance_type', 'mem': 'mem', 'root-disk': 'root_disk', 'root-disk-source': 'root_disk_source', 'spaces': 'spaces', 'tags': 'tags', 'virt-type': 'virt_type', 'zones': 'zones'}
    def __init__(self, arch=None, container=None, cores=None, cpu_power=None, instance_type=None, mem=None, root_disk=None, root_disk_source=None, spaces=None, tags=None, virt_type=None, zones=None, **unknown_fields):
        '''
        arch : str
        container : str
        cores : int
        cpu_power : int
        instance_type : str
        mem : int
        root_disk : int
        root_disk_source : str
        spaces : typing.Sequence[str]
        tags : typing.Sequence[str]
        virt_type : str
        zones : typing.Sequence[str]
        '''
        if arch is not None and not isinstance(arch, (bytes, str)):
            raise Exception('Expected arch to be of type str')

        if container is not None and not isinstance(container, (bytes, str)):
            raise Exception('Expected container to be of type str')

        if cores is not None and not isinstance(cores, int):
            raise Exception('Expected cores to be of type int')

        if cpu_power is not None and not isinstance(cpu_power, int):
            raise Exception('Expected cpu_power to be of type int')

        if instance_type is not None and not isinstance(instance_type, (bytes, str)):
            raise Exception('Expected instance_type to be of type str')

        if mem is not None and not isinstance(mem, int):
            raise Exception('Expected mem to be of type int')

        if root_disk is not None and not isinstance(root_disk, int):
            raise Exception('Expected root_disk to be of type int')

        if root_disk_source is not None and not isinstance(root_disk_source, (bytes, str)):
            raise Exception('Expected root_disk_source to be of type str')

        if spaces is not None and not isinstance(spaces, list):
            raise Exception('Expected spaces to be of type Sequence')

        if tags is not None and not isinstance(tags, list):
            raise Exception('Expected tags to be of type Sequence')

        if virt_type is not None and not isinstance(virt_type, (bytes, str)):
            raise Exception('Expected virt_type to be of type str')

        if zones is not None and not isinstance(zones, list):
            raise Exception('Expected zones to be of type Sequence')

        self.arch = arch
        self.container = container
        self.cores = cores
        self.cpu_power = cpu_power
        self.instance_type = instance_type
        self.mem = mem
        self.root_disk = root_disk
        self.root_disk_source = root_disk_source
        self.spaces = spaces
        self.tags = tags
        self.virt_type = virt_type
        self.zones = zones
        self.unknown_fields = unknown_fields



class Version(Type):
    _toSchema = {'version': 'version'}
    _toPy = {'version': 'version'}
    def __init__(self, version=None, **unknown_fields):
        '''
        version : Binary
        '''
        if version is not None and not isinstance(version, Binary):
            raise Exception('Expected version to be of type Binary')

        self.version = Binary.from_json(version) if version else None
        self.unknown_fields = unknown_fields



class VersionResult(Type):
    _toSchema = {'error': 'error', 'version': 'version'}
    _toPy = {'error': 'error', 'version': 'version'}
    def __init__(self, error=None, version=None, **unknown_fields):
        '''
        error : Error
        version : Number
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if version is not None and not isinstance(version, Number):
            raise Exception('Expected version to be of type Number')

        self.error = Error.from_json(error) if error else None
        self.version = Number.from_json(version) if version else None
        self.unknown_fields = unknown_fields



class VersionResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~VersionResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [VersionResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class Volume(Type):
    _toSchema = {'info': 'info', 'volume_tag': 'volume-tag'}
    _toPy = {'info': 'info', 'volume-tag': 'volume_tag'}
    def __init__(self, info=None, volume_tag=None, **unknown_fields):
        '''
        info : VolumeInfo
        volume_tag : str
        '''
        if info is not None and not isinstance(info, VolumeInfo):
            raise Exception('Expected info to be of type VolumeInfo')

        if volume_tag is not None and not isinstance(volume_tag, (bytes, str)):
            raise Exception('Expected volume_tag to be of type str')

        self.info = VolumeInfo.from_json(info) if info else None
        self.volume_tag = volume_tag
        self.unknown_fields = unknown_fields



class VolumeAttachment(Type):
    _toSchema = {'info': 'info', 'machine_tag': 'machine-tag', 'volume_tag': 'volume-tag'}
    _toPy = {'info': 'info', 'machine-tag': 'machine_tag', 'volume-tag': 'volume_tag'}
    def __init__(self, info=None, machine_tag=None, volume_tag=None, **unknown_fields):
        '''
        info : VolumeAttachmentInfo
        machine_tag : str
        volume_tag : str
        '''
        if info is not None and not isinstance(info, VolumeAttachmentInfo):
            raise Exception('Expected info to be of type VolumeAttachmentInfo')

        if machine_tag is not None and not isinstance(machine_tag, (bytes, str)):
            raise Exception('Expected machine_tag to be of type str')

        if volume_tag is not None and not isinstance(volume_tag, (bytes, str)):
            raise Exception('Expected volume_tag to be of type str')

        self.info = VolumeAttachmentInfo.from_json(info) if info else None
        self.machine_tag = machine_tag
        self.volume_tag = volume_tag
        self.unknown_fields = unknown_fields



class VolumeAttachmentDetails(Type):
    _toSchema = {'bus_address': 'bus-address', 'device_link': 'device-link', 'device_name': 'device-name', 'life': 'life', 'plan_info': 'plan-info', 'read_only': 'read-only', 'volumeattachmentinfo': 'VolumeAttachmentInfo'}
    _toPy = {'VolumeAttachmentInfo': 'volumeattachmentinfo', 'bus-address': 'bus_address', 'device-link': 'device_link', 'device-name': 'device_name', 'life': 'life', 'plan-info': 'plan_info', 'read-only': 'read_only'}
    def __init__(self, volumeattachmentinfo=None, bus_address=None, device_link=None, device_name=None, life=None, plan_info=None, read_only=None, **unknown_fields):
        '''
        volumeattachmentinfo : VolumeAttachmentInfo
        bus_address : str
        device_link : str
        device_name : str
        life : str
        plan_info : VolumeAttachmentPlanInfo
        read_only : bool
        '''
        if volumeattachmentinfo is not None and not isinstance(volumeattachmentinfo, VolumeAttachmentInfo):
            raise Exception('Expected volumeattachmentinfo to be of type VolumeAttachmentInfo')

        if bus_address is not None and not isinstance(bus_address, (bytes, str)):
            raise Exception('Expected bus_address to be of type str')

        if device_link is not None and not isinstance(device_link, (bytes, str)):
            raise Exception('Expected device_link to be of type str')

        if device_name is not None and not isinstance(device_name, (bytes, str)):
            raise Exception('Expected device_name to be of type str')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if plan_info is not None and not isinstance(plan_info, VolumeAttachmentPlanInfo):
            raise Exception('Expected plan_info to be of type VolumeAttachmentPlanInfo')

        if read_only is not None and not isinstance(read_only, bool):
            raise Exception('Expected read_only to be of type bool')

        self.volumeattachmentinfo = VolumeAttachmentInfo.from_json(volumeattachmentinfo) if volumeattachmentinfo else None
        self.bus_address = bus_address
        self.device_link = device_link
        self.device_name = device_name
        self.life = life
        self.plan_info = VolumeAttachmentPlanInfo.from_json(plan_info) if plan_info else None
        self.read_only = read_only
        self.unknown_fields = unknown_fields



class VolumeAttachmentInfo(Type):
    _toSchema = {'bus_address': 'bus-address', 'device_link': 'device-link', 'device_name': 'device-name', 'plan_info': 'plan-info', 'read_only': 'read-only'}
    _toPy = {'bus-address': 'bus_address', 'device-link': 'device_link', 'device-name': 'device_name', 'plan-info': 'plan_info', 'read-only': 'read_only'}
    def __init__(self, bus_address=None, device_link=None, device_name=None, plan_info=None, read_only=None, **unknown_fields):
        '''
        bus_address : str
        device_link : str
        device_name : str
        plan_info : VolumeAttachmentPlanInfo
        read_only : bool
        '''
        if bus_address is not None and not isinstance(bus_address, (bytes, str)):
            raise Exception('Expected bus_address to be of type str')

        if device_link is not None and not isinstance(device_link, (bytes, str)):
            raise Exception('Expected device_link to be of type str')

        if device_name is not None and not isinstance(device_name, (bytes, str)):
            raise Exception('Expected device_name to be of type str')

        if plan_info is not None and not isinstance(plan_info, VolumeAttachmentPlanInfo):
            raise Exception('Expected plan_info to be of type VolumeAttachmentPlanInfo')

        if read_only is not None and not isinstance(read_only, bool):
            raise Exception('Expected read_only to be of type bool')

        self.bus_address = bus_address
        self.device_link = device_link
        self.device_name = device_name
        self.plan_info = VolumeAttachmentPlanInfo.from_json(plan_info) if plan_info else None
        self.read_only = read_only
        self.unknown_fields = unknown_fields



class VolumeAttachmentParams(Type):
    _toSchema = {'instance_id': 'instance-id', 'machine_tag': 'machine-tag', 'provider': 'provider', 'read_only': 'read-only', 'volume_id': 'volume-id', 'volume_tag': 'volume-tag'}
    _toPy = {'instance-id': 'instance_id', 'machine-tag': 'machine_tag', 'provider': 'provider', 'read-only': 'read_only', 'volume-id': 'volume_id', 'volume-tag': 'volume_tag'}
    def __init__(self, instance_id=None, machine_tag=None, provider=None, read_only=None, volume_id=None, volume_tag=None, **unknown_fields):
        '''
        instance_id : str
        machine_tag : str
        provider : str
        read_only : bool
        volume_id : str
        volume_tag : str
        '''
        if instance_id is not None and not isinstance(instance_id, (bytes, str)):
            raise Exception('Expected instance_id to be of type str')

        if machine_tag is not None and not isinstance(machine_tag, (bytes, str)):
            raise Exception('Expected machine_tag to be of type str')

        if provider is not None and not isinstance(provider, (bytes, str)):
            raise Exception('Expected provider to be of type str')

        if read_only is not None and not isinstance(read_only, bool):
            raise Exception('Expected read_only to be of type bool')

        if volume_id is not None and not isinstance(volume_id, (bytes, str)):
            raise Exception('Expected volume_id to be of type str')

        if volume_tag is not None and not isinstance(volume_tag, (bytes, str)):
            raise Exception('Expected volume_tag to be of type str')

        self.instance_id = instance_id
        self.machine_tag = machine_tag
        self.provider = provider
        self.read_only = read_only
        self.volume_id = volume_id
        self.volume_tag = volume_tag
        self.unknown_fields = unknown_fields



class VolumeAttachmentParamsResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : VolumeAttachmentParams
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, VolumeAttachmentParams):
            raise Exception('Expected result to be of type VolumeAttachmentParams')

        self.error = Error.from_json(error) if error else None
        self.result = VolumeAttachmentParams.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class VolumeAttachmentParamsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~VolumeAttachmentParamsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [VolumeAttachmentParamsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class VolumeAttachmentPlan(Type):
    _toSchema = {'block_device': 'block-device', 'life': 'life', 'machine_tag': 'machine-tag', 'plan_info': 'plan-info', 'volume_tag': 'volume-tag'}
    _toPy = {'block-device': 'block_device', 'life': 'life', 'machine-tag': 'machine_tag', 'plan-info': 'plan_info', 'volume-tag': 'volume_tag'}
    def __init__(self, block_device=None, life=None, machine_tag=None, plan_info=None, volume_tag=None, **unknown_fields):
        '''
        block_device : BlockDevice
        life : str
        machine_tag : str
        plan_info : VolumeAttachmentPlanInfo
        volume_tag : str
        '''
        if block_device is not None and not isinstance(block_device, BlockDevice):
            raise Exception('Expected block_device to be of type BlockDevice')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if machine_tag is not None and not isinstance(machine_tag, (bytes, str)):
            raise Exception('Expected machine_tag to be of type str')

        if plan_info is not None and not isinstance(plan_info, VolumeAttachmentPlanInfo):
            raise Exception('Expected plan_info to be of type VolumeAttachmentPlanInfo')

        if volume_tag is not None and not isinstance(volume_tag, (bytes, str)):
            raise Exception('Expected volume_tag to be of type str')

        self.block_device = BlockDevice.from_json(block_device) if block_device else None
        self.life = life
        self.machine_tag = machine_tag
        self.plan_info = VolumeAttachmentPlanInfo.from_json(plan_info) if plan_info else None
        self.volume_tag = volume_tag
        self.unknown_fields = unknown_fields



class VolumeAttachmentPlanInfo(Type):
    _toSchema = {'device_attributes': 'device-attributes', 'device_type': 'device-type'}
    _toPy = {'device-attributes': 'device_attributes', 'device-type': 'device_type'}
    def __init__(self, device_attributes=None, device_type=None, **unknown_fields):
        '''
        device_attributes : typing.Mapping[str, str]
        device_type : str
        '''
        if device_attributes is not None and not isinstance(device_attributes, dict):
            raise Exception('Expected device_attributes to be of type Mapping')

        if device_type is not None and not isinstance(device_type, (bytes, str)):
            raise Exception('Expected device_type to be of type str')

        self.device_attributes = device_attributes
        self.device_type = device_type
        self.unknown_fields = unknown_fields



class VolumeAttachmentPlanResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : VolumeAttachmentPlan
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, VolumeAttachmentPlan):
            raise Exception('Expected result to be of type VolumeAttachmentPlan')

        self.error = Error.from_json(error) if error else None
        self.result = VolumeAttachmentPlan.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class VolumeAttachmentPlanResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~VolumeAttachmentPlanResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [VolumeAttachmentPlanResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class VolumeAttachmentPlans(Type):
    _toSchema = {'volume_plans': 'volume-plans'}
    _toPy = {'volume-plans': 'volume_plans'}
    def __init__(self, volume_plans=None, **unknown_fields):
        '''
        volume_plans : typing.Sequence[~VolumeAttachmentPlan]
        '''
        if volume_plans is not None and not isinstance(volume_plans, list):
            raise Exception('Expected volume_plans to be of type Sequence')

        self.volume_plans = [VolumeAttachmentPlan.from_json(o) for o in volume_plans or []]
        self.unknown_fields = unknown_fields



class VolumeAttachmentResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : VolumeAttachment
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, VolumeAttachment):
            raise Exception('Expected result to be of type VolumeAttachment')

        self.error = Error.from_json(error) if error else None
        self.result = VolumeAttachment.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class VolumeAttachmentResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~VolumeAttachmentResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [VolumeAttachmentResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class VolumeAttachments(Type):
    _toSchema = {'volume_attachments': 'volume-attachments'}
    _toPy = {'volume-attachments': 'volume_attachments'}
    def __init__(self, volume_attachments=None, **unknown_fields):
        '''
        volume_attachments : typing.Sequence[~VolumeAttachment]
        '''
        if volume_attachments is not None and not isinstance(volume_attachments, list):
            raise Exception('Expected volume_attachments to be of type Sequence')

        self.volume_attachments = [VolumeAttachment.from_json(o) for o in volume_attachments or []]
        self.unknown_fields = unknown_fields



class VolumeDetails(Type):
    _toSchema = {'info': 'info', 'life': 'life', 'machine_attachments': 'machine-attachments', 'status': 'status', 'storage': 'storage', 'unit_attachments': 'unit-attachments', 'volume_tag': 'volume-tag'}
    _toPy = {'info': 'info', 'life': 'life', 'machine-attachments': 'machine_attachments', 'status': 'status', 'storage': 'storage', 'unit-attachments': 'unit_attachments', 'volume-tag': 'volume_tag'}
    def __init__(self, info=None, life=None, machine_attachments=None, status=None, storage=None, unit_attachments=None, volume_tag=None, **unknown_fields):
        '''
        info : VolumeInfo
        life : str
        machine_attachments : typing.Mapping[str, ~VolumeAttachmentDetails]
        status : EntityStatus
        storage : StorageDetails
        unit_attachments : typing.Mapping[str, ~VolumeAttachmentDetails]
        volume_tag : str
        '''
        if info is not None and not isinstance(info, VolumeInfo):
            raise Exception('Expected info to be of type VolumeInfo')

        if life is not None and not isinstance(life, (bytes, str)):
            raise Exception('Expected life to be of type str')

        if machine_attachments is not None and not isinstance(machine_attachments, dict):
            raise Exception('Expected machine_attachments to be of type Mapping')

        if status is not None and not isinstance(status, EntityStatus):
            raise Exception('Expected status to be of type EntityStatus')

        if storage is not None and not isinstance(storage, StorageDetails):
            raise Exception('Expected storage to be of type StorageDetails')

        if unit_attachments is not None and not isinstance(unit_attachments, dict):
            raise Exception('Expected unit_attachments to be of type Mapping')

        if volume_tag is not None and not isinstance(volume_tag, (bytes, str)):
            raise Exception('Expected volume_tag to be of type str')

        self.info = VolumeInfo.from_json(info) if info else None
        self.life = life
        self.machine_attachments = machine_attachments
        self.status = EntityStatus.from_json(status) if status else None
        self.storage = StorageDetails.from_json(storage) if storage else None
        self.unit_attachments = unit_attachments
        self.volume_tag = volume_tag
        self.unknown_fields = unknown_fields



class VolumeDetailsListResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : typing.Sequence[~VolumeDetails]
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, list):
            raise Exception('Expected result to be of type Sequence')

        self.error = Error.from_json(error) if error else None
        self.result = [VolumeDetails.from_json(o) for o in result or []]
        self.unknown_fields = unknown_fields



class VolumeDetailsListResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~VolumeDetailsListResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [VolumeDetailsListResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class VolumeFilter(Type):
    _toSchema = {'machines': 'machines'}
    _toPy = {'machines': 'machines'}
    def __init__(self, machines=None, **unknown_fields):
        '''
        machines : typing.Sequence[str]
        '''
        if machines is not None and not isinstance(machines, list):
            raise Exception('Expected machines to be of type Sequence')

        self.machines = machines
        self.unknown_fields = unknown_fields



class VolumeFilters(Type):
    _toSchema = {'filters': 'filters'}
    _toPy = {'filters': 'filters'}
    def __init__(self, filters=None, **unknown_fields):
        '''
        filters : typing.Sequence[~VolumeFilter]
        '''
        if filters is not None and not isinstance(filters, list):
            raise Exception('Expected filters to be of type Sequence')

        self.filters = [VolumeFilter.from_json(o) for o in filters or []]
        self.unknown_fields = unknown_fields



class VolumeInfo(Type):
    _toSchema = {'hardware_id': 'hardware-id', 'persistent': 'persistent', 'pool': 'pool', 'size': 'size', 'volume_id': 'volume-id', 'wwn': 'wwn'}
    _toPy = {'hardware-id': 'hardware_id', 'persistent': 'persistent', 'pool': 'pool', 'size': 'size', 'volume-id': 'volume_id', 'wwn': 'wwn'}
    def __init__(self, hardware_id=None, persistent=None, pool=None, size=None, volume_id=None, wwn=None, **unknown_fields):
        '''
        hardware_id : str
        persistent : bool
        pool : str
        size : int
        volume_id : str
        wwn : str
        '''
        if hardware_id is not None and not isinstance(hardware_id, (bytes, str)):
            raise Exception('Expected hardware_id to be of type str')

        if persistent is not None and not isinstance(persistent, bool):
            raise Exception('Expected persistent to be of type bool')

        if pool is not None and not isinstance(pool, (bytes, str)):
            raise Exception('Expected pool to be of type str')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if volume_id is not None and not isinstance(volume_id, (bytes, str)):
            raise Exception('Expected volume_id to be of type str')

        if wwn is not None and not isinstance(wwn, (bytes, str)):
            raise Exception('Expected wwn to be of type str')

        self.hardware_id = hardware_id
        self.persistent = persistent
        self.pool = pool
        self.size = size
        self.volume_id = volume_id
        self.wwn = wwn
        self.unknown_fields = unknown_fields



class VolumeParams(Type):
    _toSchema = {'attachment': 'attachment', 'attributes': 'attributes', 'provider': 'provider', 'size': 'size', 'tags': 'tags', 'volume_tag': 'volume-tag'}
    _toPy = {'attachment': 'attachment', 'attributes': 'attributes', 'provider': 'provider', 'size': 'size', 'tags': 'tags', 'volume-tag': 'volume_tag'}
    def __init__(self, attachment=None, attributes=None, provider=None, size=None, tags=None, volume_tag=None, **unknown_fields):
        '''
        attachment : VolumeAttachmentParams
        attributes : typing.Mapping[str, typing.Any]
        provider : str
        size : int
        tags : typing.Mapping[str, str]
        volume_tag : str
        '''
        if attachment is not None and not isinstance(attachment, VolumeAttachmentParams):
            raise Exception('Expected attachment to be of type VolumeAttachmentParams')

        if attributes is not None and not isinstance(attributes, dict):
            raise Exception('Expected attributes to be of type Mapping')

        if provider is not None and not isinstance(provider, (bytes, str)):
            raise Exception('Expected provider to be of type str')

        if size is not None and not isinstance(size, int):
            raise Exception('Expected size to be of type int')

        if tags is not None and not isinstance(tags, dict):
            raise Exception('Expected tags to be of type Mapping')

        if volume_tag is not None and not isinstance(volume_tag, (bytes, str)):
            raise Exception('Expected volume_tag to be of type str')

        self.attachment = VolumeAttachmentParams.from_json(attachment) if attachment else None
        self.attributes = attributes
        self.provider = provider
        self.size = size
        self.tags = tags
        self.volume_tag = volume_tag
        self.unknown_fields = unknown_fields



class VolumeParamsResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : VolumeParams
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, VolumeParams):
            raise Exception('Expected result to be of type VolumeParams')

        self.error = Error.from_json(error) if error else None
        self.result = VolumeParams.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class VolumeParamsResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~VolumeParamsResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [VolumeParamsResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class VolumeResult(Type):
    _toSchema = {'error': 'error', 'result': 'result'}
    _toPy = {'error': 'error', 'result': 'result'}
    def __init__(self, error=None, result=None, **unknown_fields):
        '''
        error : Error
        result : Volume
        '''
        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if result is not None and not isinstance(result, Volume):
            raise Exception('Expected result to be of type Volume')

        self.error = Error.from_json(error) if error else None
        self.result = Volume.from_json(result) if result else None
        self.unknown_fields = unknown_fields



class VolumeResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~VolumeResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [VolumeResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields



class Volumes(Type):
    _toSchema = {'volumes': 'volumes'}
    _toPy = {'volumes': 'volumes'}
    def __init__(self, volumes=None, **unknown_fields):
        '''
        volumes : typing.Sequence[~Volume]
        '''
        if volumes is not None and not isinstance(volumes, list):
            raise Exception('Expected volumes to be of type Sequence')

        self.volumes = [Volume.from_json(o) for o in volumes or []]
        self.unknown_fields = unknown_fields



class WatchContainer(Type):
    _toSchema = {'container_type': 'container-type', 'machine_tag': 'machine-tag'}
    _toPy = {'container-type': 'container_type', 'machine-tag': 'machine_tag'}
    def __init__(self, container_type=None, machine_tag=None, **unknown_fields):
        '''
        container_type : str
        machine_tag : str
        '''
        if container_type is not None and not isinstance(container_type, (bytes, str)):
            raise Exception('Expected container_type to be of type str')

        if machine_tag is not None and not isinstance(machine_tag, (bytes, str)):
            raise Exception('Expected machine_tag to be of type str')

        self.container_type = container_type
        self.machine_tag = machine_tag
        self.unknown_fields = unknown_fields



class WatchContainers(Type):
    _toSchema = {'params': 'params'}
    _toPy = {'params': 'params'}
    def __init__(self, params=None, **unknown_fields):
        '''
        params : typing.Sequence[~WatchContainer]
        '''
        if params is not None and not isinstance(params, list):
            raise Exception('Expected params to be of type Sequence')

        self.params = [WatchContainer.from_json(o) for o in params or []]
        self.unknown_fields = unknown_fields



class ZoneResult(Type):
    _toSchema = {'available': 'available', 'error': 'error', 'name': 'name'}
    _toPy = {'available': 'available', 'error': 'error', 'name': 'name'}
    def __init__(self, available=None, error=None, name=None, **unknown_fields):
        '''
        available : bool
        error : Error
        name : str
        '''
        if available is not None and not isinstance(available, bool):
            raise Exception('Expected available to be of type bool')

        if error is not None and not isinstance(error, Error):
            raise Exception('Expected error to be of type Error')

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception('Expected name to be of type str')

        self.available = available
        self.error = Error.from_json(error) if error else None
        self.name = name
        self.unknown_fields = unknown_fields



class ZoneResults(Type):
    _toSchema = {'results': 'results'}
    _toPy = {'results': 'results'}
    def __init__(self, results=None, **unknown_fields):
        '''
        results : typing.Sequence[~ZoneResult]
        '''
        if results is not None and not isinstance(results, list):
            raise Exception('Expected results to be of type Sequence')

        self.results = [ZoneResult.from_json(o) for o in results or []]
        self.unknown_fields = unknown_fields
